{
  "api/Holoride.ElasticSDK.BaseRotation.html": {
    "href": "api/Holoride.ElasticSDK.BaseRotation.html",
    "title": "Class BaseRotation | ElasticSDK Documentation",
    "keywords": "Class BaseRotation Inheritance object Object Component Behaviour MonoBehaviour BaseRotation StylizedVehicleRotation VehicleRotation Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public abstract class BaseRotation : MonoBehaviour Properties ActiveRotationAxes Declaration protected BaseRotation.RotationAxes ActiveRotationAxes { get; set; } Property Value Type Description BaseRotation.RotationAxes ShowDebugVisualization Declaration protected bool ShowDebugVisualization { get; set; } Property Value Type Description bool Methods Awake() Declaration protected virtual void Awake() OnDisable() Declaration protected virtual void OnDisable() OnDrawGizmos() Declaration protected virtual void OnDrawGizmos() OnEnable() Declaration protected virtual void OnEnable() Start() Declaration protected virtual void Start() Update() Declaration protected virtual void Update() UpdateEulerAngles() Declaration protected abstract Vector3 UpdateEulerAngles() Returns Type Description Vector3"
  },
  "api/Holoride.ElasticSDK.BaseRotation.RotationAxes.html": {
    "href": "api/Holoride.ElasticSDK.BaseRotation.RotationAxes.html",
    "title": "Enum BaseRotation.RotationAxes | ElasticSDK Documentation",
    "keywords": "Enum BaseRotation.RotationAxes Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [Flags] public enum BaseRotation.RotationAxes Fields Name Description Pitch Roll Yaw"
  },
  "api/Holoride.ElasticSDK.BufferPair-1.html": {
    "href": "api/Holoride.ElasticSDK.BufferPair-1.html",
    "title": "Class BufferPair<T> | ElasticSDK Documentation",
    "keywords": "Class BufferPair<T> A pair of equally sized CPU and GPU buffers. Inheritance object BufferPair<T> Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public sealed class BufferPair<T> Type Parameters Name Description T Constructors BufferPair(int) Initializes a BufferPair. Declaration public BufferPair(int length) Parameters Type Name Description int length The number of elements in this buffer. Fields CPUBuffer The CPU buffer. Declaration public readonly T[] CPUBuffer Field Value Type Description T[] GPUBuffer The GPU buffer. Declaration public readonly ComputeBuffer GPUBuffer Field Value Type Description ComputeBuffer Methods CleanUp() Cleans up by releasing the GPUBuffer. Declaration [Obsolete(\"Use Dispose() instead.\")] public void CleanUp() CopyFromCPUToGPU() Copies the data from the CPUBuffer to the GPUBuffer. Declaration public void CopyFromCPUToGPU() CopyFromGPUToCPU() Copies the data from the GPUBuffer to the CPUBuffer. Declaration public void CopyFromGPUToCPU() Dispose() Declaration public void Dispose()"
  },
  "api/Holoride.ElasticSDK.BufferPairExtensions.html": {
    "href": "api/Holoride.ElasticSDK.BufferPairExtensions.html",
    "title": "Class BufferPairExtensions | ElasticSDK Documentation",
    "keywords": "Class BufferPairExtensions Inheritance object BufferPairExtensions Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public static class BufferPairExtensions Methods CopyFromGPUToCPUAsync(BufferPair<float>, CancellationToken) Attempts to copy data from GPU to CPU asynchronously. Declaration public static UniTask CopyFromGPUToCPUAsync(this BufferPair<float> self, CancellationToken cancellationToken) Parameters Type Name Description BufferPair<float> self The buffer pair for which to copy GPU data to CPU data. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask"
  },
  "api/Holoride.ElasticSDK.CacheAnnotatedMethodsAttribute.html": {
    "href": "api/Holoride.ElasticSDK.CacheAnnotatedMethodsAttribute.html",
    "title": "Class CacheAnnotatedMethodsAttribute | ElasticSDK Documentation",
    "keywords": "Class CacheAnnotatedMethodsAttribute Inheritance object Attribute CacheAnnotatedMethodsAttribute Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Class)] [BaseTypeRequired(typeof(Attribute))] [MeansImplicitUse] public sealed class CacheAnnotatedMethodsAttribute : Attribute"
  },
  "api/Holoride.ElasticSDK.CacheSubTypesAttribute.html": {
    "href": "api/Holoride.ElasticSDK.CacheSubTypesAttribute.html",
    "title": "Class CacheSubTypesAttribute | ElasticSDK Documentation",
    "keywords": "Class CacheSubTypesAttribute Inheritance object Attribute CacheSubTypesAttribute Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Class|AttributeTargets.Interface)] [MeansImplicitUse] public sealed class CacheSubTypesAttribute : Attribute"
  },
  "api/Holoride.ElasticSDK.CameraRigParentRotation.html": {
    "href": "api/Holoride.ElasticSDK.CameraRigParentRotation.html",
    "title": "Class CameraRigParentRotation | ElasticSDK Documentation",
    "keywords": "Class CameraRigParentRotation Inheritance object Object Component Behaviour MonoBehaviour CameraRigParentRotation Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [HelpURL(\"http://localhost:8080/api/Holoride.ElasticSDK.CameraRigParentRotation.html\")] public sealed class CameraRigParentRotation : MonoBehaviour Methods Recenter() Declaration [ContextMenu(\"Recenter\")] public void Recenter()"
  },
  "api/Holoride.ElasticSDK.CollectionExtensions.html": {
    "href": "api/Holoride.ElasticSDK.CollectionExtensions.html",
    "title": "Class CollectionExtensions | ElasticSDK Documentation",
    "keywords": "Class CollectionExtensions Utility extensions for collections. Inheritance object CollectionExtensions Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public static class CollectionExtensions Methods AddDistinct<T>(ICollection<T>, T) Adds an element to a collection if the collection does not yet contain the element. Declaration public static void AddDistinct<T>(this ICollection<T> self, T element) Parameters Type Name Description ICollection<T> self The collection to add the element to. T element The element to add to the collection. Type Parameters Name Description T The type of the elements in the collection. AddRangeDistinct<T>(ICollection<T>, IEnumerable<T>) Adds each element in the list of elements to a collection if the collection does not yet contain the element. Declaration public static void AddRangeDistinct<T>(this ICollection<T> self, IEnumerable<T> elements) Parameters Type Name Description ICollection<T> self The collection to add the elements to. IEnumerable<T> elements The elements to add to the collection. Type Parameters Name Description T The type of the elements in the collection."
  },
  "api/Holoride.ElasticSDK.Compute.Blur.html": {
    "href": "api/Holoride.ElasticSDK.Compute.Blur.html",
    "title": "Class Blur | ElasticSDK Documentation",
    "keywords": "Class Blur Inheritance object Blur Namespace: Holoride.ElasticSDK.Compute Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] public static class Blur Methods DispatchAsync(ComputeBuffer, IList<ComputeBuffer>, int, uint, CancellationToken) Runs a blur push-pull-shader on the specified buffer. Buffers are expected to contain data that is semantically a 2D float array with equal edge lengths (i.e. is squared). Declaration public static UniTask DispatchAsync(ComputeBuffer buffer, IList<ComputeBuffer> pyramid, int resolution, uint maxLevel, CancellationToken cancellationToken = default) Parameters Type Name Description ComputeBuffer buffer The buffer to run the blur on. Serves as initial seed and final output buffer. IList<ComputeBuffer> pyramid The pyramid of buffers used by the algorithm. Typically created via AllocatePyramid(IList<ComputeBuffer>, int, int, uint). int resolution The edge length/resolution of the 2D data stored in the buffer. uint maxLevel The number of levels to blur. Higher values lead to more blur. Zero means no blur. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask An enumerator over the progress of the algorithm, expected to run in a Unity coroutine. DispatchAsync(ComputeBuffer, int, uint, CancellationToken) Runs a blur push-pull-shader on the specified buffer. Buffers are expected to contain data that is semantically a 2D float array with equal edge lengths (i.e. is squared). Declaration public static UniTask DispatchAsync(ComputeBuffer buffer, int resolution, uint maxLevel, CancellationToken cancellationToken = default) Parameters Type Name Description ComputeBuffer buffer The buffer to run the blur on. Serves as initial seed and final output buffer. int resolution The edge length/resolution of the 2D data stored in the buffer. uint maxLevel The number of levels to blur. Higher values lead to more blur. Zero means no blur. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask An enumerator over the progress of the algorithm, expected to run in a Unity coroutine. Initialize() Declaration public static void Initialize()"
  },
  "api/Holoride.ElasticSDK.Compute.ComputeAlgorithms.html": {
    "href": "api/Holoride.ElasticSDK.Compute.ComputeAlgorithms.html",
    "title": "Class ComputeAlgorithms | ElasticSDK Documentation",
    "keywords": "Class ComputeAlgorithms Provides multi-stage compute shader algorithms such as Push-Pull. Inheritance object ComputeAlgorithms Namespace: Holoride.ElasticSDK.Compute Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] public static class ComputeAlgorithms Methods AllocatePyramid(IList<ComputeBuffer>, int, int, uint) Allocates the lower level buffers for a buffer pyramid. Declaration public static void AllocatePyramid(IList<ComputeBuffer> pyramid, int resolution, int stride, uint maxLevel = 4294967295) Parameters Type Name Description IList<ComputeBuffer> pyramid The list the buffers will be added to. int resolution The resolution of the input buffer. int stride The stride of the compute buffers to generate. uint maxLevel The maximum number of levels to create. May be used to stop early. Otherwise bound by resolution (stops when level resolution is one). GetComputeShaderPath(string) Declaration public static string GetComputeShaderPath(string name) Parameters Type Name Description string name Returns Type Description string Initialize() Declaration public static void Initialize() RunPushPullShaderAsync(ComputeShader, ComputeBuffer, IList<ComputeBuffer>, int, int, int, int, int, uint, PushPullHookAsync, PushPullHookAsync, CancellationToken) Runs a generic Push-Pull-Shader. Declaration public static UniTask RunPushPullShaderAsync(ComputeShader shader, ComputeBuffer buffer, IList<ComputeBuffer> pyramid, int resolution, int pushKernelId, int pushThreadCount = -1, int pullKernelId = -1, int pullThreadCount = -1, uint maxLevel = 4294967295, ComputeAlgorithms.PushPullHookAsync onAfterPush = null, ComputeAlgorithms.PushPullHookAsync onAfterPull = null, CancellationToken cancellationToken = default) Parameters Type Name Description ComputeShader shader The compute shader implementing the push-pull kernels. ComputeBuffer buffer The buffer to perform the push-pull algorithm on. Serves as seeding input for the push phase and the as the final output buffer for the pull phase. IList<ComputeBuffer> pyramid The pyramid of buffers used by the algorithm. Typically created via AllocatePyramid(IList<ComputeBuffer>, int, int, uint). int resolution The resolution of the (assumed to be) 2D data in the buffer. Buffer is expected to be a square. int pushKernelId The id of the push kernel. This step is required to populate the levels. int pushThreadCount The number of threads per group for the push kernel. int pullKernelId The id of the pull kernel. This step is optional and will be skipped for invalid (negative) kernel ids. int pullThreadCount The number of threads per group for the pull kernel. uint maxLevel The max mip level to generate. ComputeAlgorithms.PushPullHookAsync onAfterPush Callback for performing operations on the generated command buffer pyramid after the push phase of the algorithm has completed. The passed pyramid becomes invalid after the onAfterPull callback returns. ComputeAlgorithms.PushPullHookAsync onAfterPull Callback for performing operations on the generated command buffer pyramid after the pull phase of the algorithm has completed. The passed pyramid becomes invalid after this callback returns. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask RunPushPullShaderAsync(ComputeShader, ComputeBuffer, int, int, int, int, int, uint, PushPullHookAsync, PushPullHookAsync, CancellationToken) Runs a generic Push-Pull-Shader. Declaration public static UniTask RunPushPullShaderAsync(ComputeShader shader, ComputeBuffer buffer, int resolution, int pushKernelId, int pushThreadCount = -1, int pullKernelId = -1, int pullThreadCount = -1, uint maxLevel = 4294967295, ComputeAlgorithms.PushPullHookAsync onAfterPush = null, ComputeAlgorithms.PushPullHookAsync onAfterPull = null, CancellationToken cancellationToken = default) Parameters Type Name Description ComputeShader shader The compute shader implementing the push-pull kernels. ComputeBuffer buffer The buffer to perform the push-pull algorithm on. Serves as seeding input for the push phase and the as the final output buffer for the pull phase. int resolution The resolution of the (assumed to be) 2D data in the buffer. Buffer is expected to be a square. int pushKernelId The id of the push kernel. This step is required to populate the levels. int pushThreadCount The number of threads per group for the push kernel. int pullKernelId The id of the pull kernel. This step is optional and will be skipped for invalid (negative) kernel ids. int pullThreadCount The number of threads per group for the pull kernel. uint maxLevel The max mip level to generate. ComputeAlgorithms.PushPullHookAsync onAfterPush Callback for performing operations on the generated command buffer pyramid after the push phase of the algorithm has completed. The passed pyramid becomes invalid after the onAfterPull callback returns. ComputeAlgorithms.PushPullHookAsync onAfterPull Callback for performing operations on the generated command buffer pyramid after the pull phase of the algorithm has completed. The passed pyramid becomes invalid after this callback returns. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask"
  },
  "api/Holoride.ElasticSDK.Compute.ComputeAlgorithms.PushPullHookAsync.html": {
    "href": "api/Holoride.ElasticSDK.Compute.ComputeAlgorithms.PushPullHookAsync.html",
    "title": "Delegate ComputeAlgorithms.PushPullHookAsync | ElasticSDK Documentation",
    "keywords": "Delegate ComputeAlgorithms.PushPullHookAsync Allows hooking into the push-pull algorithm implemented by RunPushPullShaderAsync(ComputeShader, ComputeBuffer, int, int, int, int, int, uint, PushPullHookAsync, PushPullHookAsync, CancellationToken). This can be useful for working with values on a specific mip level, e.g. for extracting the accumulated values on the highest level. Supports multi-frame processing; the hook can expect to be called from a Unity coroutine. Namespace: Holoride.ElasticSDK.Compute Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public delegate UniTask ComputeAlgorithms.PushPullHookAsync(List<ComputeBuffer> pyramid) Parameters Type Name Description List<ComputeBuffer> pyramid The compute buffer pyramid of the push-pull steps. The higher the level, the smaller the buffer. Think mipmaps. Returns Type Description Cysharp.Threading.Tasks.UniTask"
  },
  "api/Holoride.ElasticSDK.Compute.ComputeShaderKernel.html": {
    "href": "api/Holoride.ElasticSDK.Compute.ComputeShaderKernel.html",
    "title": "Struct ComputeShaderKernel | ElasticSDK Documentation",
    "keywords": "Struct ComputeShaderKernel Wrapper struct for caching information on a single kernel in a compute shader. Namespace: Holoride.ElasticSDK.Compute Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] public readonly struct ComputeShaderKernel Constructors ComputeShaderKernel(ComputeShader, string, int, uint, uint, uint) Declaration public ComputeShaderKernel(ComputeShader shader, string name, int id, uint threadsX, uint threadsY, uint threadsZ) Parameters Type Name Description ComputeShader shader string name int id uint threadsX uint threadsY uint threadsZ Fields Id The id of the kernel. Declaration public readonly int Id Field Value Type Description int Name The name of the kernel. Declaration public readonly string Name Field Value Type Description string Shader The compute shader containing the kernel. Declaration public readonly ComputeShader Shader Field Value Type Description ComputeShader ThreadsX The thread group size of the kernel for the X dimension. Declaration public readonly uint ThreadsX Field Value Type Description uint ThreadsY The thread group size of the kernel for the Y dimension. Declaration public readonly uint ThreadsY Field Value Type Description uint ThreadsZ The thread group size of the kernel for the Z dimension. Declaration public readonly uint ThreadsZ Field Value Type Description uint Methods Create(ComputeShader, string) Creates a new kernel descriptor for the specified shader and kernel. Declaration public static ComputeShaderKernel Create(ComputeShader shader, string kernelName) Parameters Type Name Description ComputeShader shader The shader containing the kernel. string kernelName The name of the kernel. Returns Type Description ComputeShaderKernel The descriptor for the specified kernel. Dispatch(int, int, int) Dispatches the kernel with the specified number of thread counts. These counts will be divided by the size of the thread groups declared by the kernel to dispatch the appropriate number of thread groups. Declaration public void Dispatch(int countX = 1, int countY = 1, int countZ = 1) Parameters Type Name Description int countX The count of cells the kernel should run on in the X axis. int countY The count of cells the kernel should run on in the Y axis. int countZ The count of cells the kernel should run on in the Z axis. Dispatch(CommandBuffer, int, int, int) Dispatches the kernel with the specified number of thread counts. These counts will be divided by the size of the thread groups declared by the kernel to dispatch the appropriate number of thread groups. Declaration public void Dispatch(CommandBuffer commandBuffer, int countX = 1, int countY = 1, int countZ = 1) Parameters Type Name Description CommandBuffer commandBuffer The command buffer to run the compute shader in. int countX The count of cells the kernel should run on in the X axis. int countY The count of cells the kernel should run on in the Y axis. int countZ The count of cells the kernel should run on in the Z axis. Equals(ComputeShaderKernel) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(ComputeShaderKernel other) Parameters Type Name Description ComputeShaderKernel other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Determines whether the specified object is equal to the current object. Declaration public override bool Equals(object obj) Parameters Type Name Description object obj The object to compare with the current object. Returns Type Description bool true if the specified object is equal to the current object; otherwise, false. Overrides ValueType.Equals(Object) GetHashCode() Serves as the default hash function. Declaration public override int GetHashCode() Returns Type Description int A hash code for the current object. Overrides ValueType.GetHashCode() ToString() Returns a string that represents the current object. Declaration public override string ToString() Returns Type Description string A string that represents the current object. Overrides ValueType.ToString() Operators operator ==(ComputeShaderKernel, ComputeShaderKernel) Declaration public static bool operator ==(ComputeShaderKernel left, ComputeShaderKernel right) Parameters Type Name Description ComputeShaderKernel left ComputeShaderKernel right Returns Type Description bool operator !=(ComputeShaderKernel, ComputeShaderKernel) Declaration public static bool operator !=(ComputeShaderKernel left, ComputeShaderKernel right) Parameters Type Name Description ComputeShaderKernel left ComputeShaderKernel right Returns Type Description bool"
  },
  "api/Holoride.ElasticSDK.Compute.CopyBufferToBuffer.html": {
    "href": "api/Holoride.ElasticSDK.Compute.CopyBufferToBuffer.html",
    "title": "Class CopyBufferToBuffer | ElasticSDK Documentation",
    "keywords": "Class CopyBufferToBuffer Wrapper for a compute shader that may be used to copy data from one compute buffer to another. Inheritance object CopyBufferToBuffer Namespace: Holoride.ElasticSDK.Compute Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] public static class CopyBufferToBuffer Methods Dispatch(ComputeBuffer, ComputeBuffer) Copies the contents from one compute buffer into another. Buffers must have the same size. Buffers elements must be of type float (or equivalently sized). Declaration public static void Dispatch(ComputeBuffer input, ComputeBuffer output) Parameters Type Name Description ComputeBuffer input The buffer to copy data from. ComputeBuffer output The buffer to copy data to. Exceptions Type Condition ArgumentException input differs in count from output. Dispatch(CommandBuffer, ComputeBuffer, ComputeBuffer) Copies the contents from one compute buffer into another. Buffers must have the same size. Buffers elements must be of type float (or equivalently sized). Declaration public static void Dispatch(CommandBuffer commandBuffer, ComputeBuffer input, ComputeBuffer output) Parameters Type Name Description CommandBuffer commandBuffer The command buffer to run the compute shader in. ComputeBuffer input The buffer to copy data from. ComputeBuffer output The buffer to copy data to. Remarks This overload requires input buffers to not change until execution of the command buffer. Exceptions Type Condition ArgumentException input differs in count from output. Initialize() Declaration public static void Initialize()"
  },
  "api/Holoride.ElasticSDK.Compute.CopyBufferToPreviewTexture.html": {
    "href": "api/Holoride.ElasticSDK.Compute.CopyBufferToPreviewTexture.html",
    "title": "Class CopyBufferToPreviewTexture | ElasticSDK Documentation",
    "keywords": "Class CopyBufferToPreviewTexture Wrapper for a compute shader that may be used to copy data from a compute buffer to a texture that will be used as a preview texture in the graph editor. In particular the compute shader may perform additional mappings of the input data for visualization, e.g. of negative values. Inheritance object CopyBufferToPreviewTexture Namespace: Holoride.ElasticSDK.Compute Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] public static class CopyBufferToPreviewTexture Methods Dispatch(ComputeBuffer, Texture, float, float) Declaration public static void Dispatch(ComputeBuffer input, Texture output, float inputMinValue, float inputMaxValue) Parameters Type Name Description ComputeBuffer input Texture output float inputMinValue float inputMaxValue Dispatch(CommandBuffer, ComputeBuffer, Texture, float, float) Declaration public static void Dispatch(CommandBuffer commandBuffer, ComputeBuffer input, Texture output, float inputMinValue, float inputMaxValue) Parameters Type Name Description CommandBuffer commandBuffer ComputeBuffer input Texture output float inputMinValue float inputMaxValue Initialize() Declaration public static void Initialize()"
  },
  "api/Holoride.ElasticSDK.Compute.CopyBufferToTexture.html": {
    "href": "api/Holoride.ElasticSDK.Compute.CopyBufferToTexture.html",
    "title": "Class CopyBufferToTexture | ElasticSDK Documentation",
    "keywords": "Class CopyBufferToTexture Wrapper for a compute shader that may be used to copy data from a compute buffer to a texture. Inheritance object CopyBufferToTexture Namespace: Holoride.ElasticSDK.Compute Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] public static class CopyBufferToTexture Methods Dispatch(ComputeBuffer, Texture) Declaration public static void Dispatch(ComputeBuffer input, Texture output) Parameters Type Name Description ComputeBuffer input Texture output Dispatch(CommandBuffer, ComputeBuffer, Texture) Declaration public static void Dispatch(CommandBuffer commandBuffer, ComputeBuffer input, Texture output) Parameters Type Name Description CommandBuffer commandBuffer ComputeBuffer input Texture output Initialize() Declaration public static void Initialize()"
  },
  "api/Holoride.ElasticSDK.Compute.CopyTextureToBuffer.GrayScaleConversion.html": {
    "href": "api/Holoride.ElasticSDK.Compute.CopyTextureToBuffer.GrayScaleConversion.html",
    "title": "Enum CopyTextureToBuffer.GrayScaleConversion | ElasticSDK Documentation",
    "keywords": "Enum CopyTextureToBuffer.GrayScaleConversion Options on how the sampled texture is converted to grayscale. Namespace: Holoride.ElasticSDK.Compute Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public enum CopyTextureToBuffer.GrayScaleConversion Fields Name Description A B G R RGBAverage RGBToLuminance"
  },
  "api/Holoride.ElasticSDK.Compute.CopyTextureToBuffer.html": {
    "href": "api/Holoride.ElasticSDK.Compute.CopyTextureToBuffer.html",
    "title": "Class CopyTextureToBuffer | ElasticSDK Documentation",
    "keywords": "Class CopyTextureToBuffer Wrapper for a compute shader that may be used to copy data from a texture into a compute buffer. Inheritance object CopyTextureToBuffer Namespace: Holoride.ElasticSDK.Compute Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] public static class CopyTextureToBuffer Methods Dispatch(Rect, Texture, ComputeBuffer, int, GrayScaleConversion, float, bool) Dispatches the compute shader for copying a texture into the specified compute buffer representing a 2D float map. This will use the provided bounds to generate the UV coordinates to sample the texture. Imagine these bounds as a rectangle in 2D world space describing the position and size of the compute buffer with the texture being sampled using world space coordinates. Declaration public static void Dispatch(Rect bounds, Texture input, ComputeBuffer output, int outputWidth, CopyTextureToBuffer.GrayScaleConversion channel, float scale = 1, bool sampleInterpolated = true) Parameters Type Name Description Rect bounds The bounds describing the target buffers position and size. Texture input The texture to sample from. ComputeBuffer output The compute buffer to write into. int outputWidth The width of the 2D map represented by the compute buffer. CopyTextureToBuffer.GrayScaleConversion channel The channel of the texture to sample. float scale A custom scaling to be used when sampling the texture. bool sampleInterpolated States whether to sample the texture interpolated. Uses point sampling if false. Dispatch(CommandBuffer, Rect, Texture, ComputeBuffer, int, GrayScaleConversion, float, bool) Dispatches the compute shader for copying a texture into the specified compute buffer representing a 2D float map. This will use the provided bounds to generate the UV coordinates to sample the texture. Imagine these bounds as a rectangle in 2D world space describing the position and size of the compute buffer with the texture being sampled using world space coordinates. Declaration public static void Dispatch(CommandBuffer commandBuffer, Rect bounds, Texture input, ComputeBuffer output, int outputWidth, CopyTextureToBuffer.GrayScaleConversion channel, float scale = 1, bool sampleInterpolated = true) Parameters Type Name Description CommandBuffer commandBuffer The command buffer to run the compute shader in. Rect bounds The bounds describing the target buffers position and size. Texture input The texture to sample from. ComputeBuffer output The compute buffer to write into. int outputWidth The width of the 2D map represented by the compute buffer. CopyTextureToBuffer.GrayScaleConversion channel The channel of the texture to sample. float scale A custom scaling to be used when sampling the texture. bool sampleInterpolated States whether to sample the texture interpolated. Uses point sampling if false. Dispatch(CommandBuffer, Texture, ComputeBuffer, int, GrayScaleConversion, float, bool) Copies data from a texture into a compute buffer. Declaration public static void Dispatch(CommandBuffer commandBuffer, Texture input, ComputeBuffer output, int outputWidth, CopyTextureToBuffer.GrayScaleConversion channel = GrayScaleConversion.R, float scale = 1, bool sampleInterpolated = true) Parameters Type Name Description CommandBuffer commandBuffer The command buffer to run the compute shader in. Texture input The texture to sample from. ComputeBuffer output The compute buffer to write into. int outputWidth The width of the 2D map represented by the compute buffer. CopyTextureToBuffer.GrayScaleConversion channel The channel of the texture to sample. float scale A custom scaling to be used when sampling the texture. bool sampleInterpolated States whether to sample the texture interpolated. Uses point sampling if false. Dispatch(Texture, ComputeBuffer, int, GrayScaleConversion, float, bool) Copies data from a texture into a compute buffer. Declaration public static void Dispatch(Texture input, ComputeBuffer output, int outputWidth, CopyTextureToBuffer.GrayScaleConversion channel = GrayScaleConversion.R, float scale = 1, bool sampleInterpolated = true) Parameters Type Name Description Texture input The texture to sample from. ComputeBuffer output The compute buffer to write into. int outputWidth The width of the 2D map represented by the compute buffer. CopyTextureToBuffer.GrayScaleConversion channel The channel of the texture to sample. float scale A custom scaling to be used when sampling the texture. bool sampleInterpolated States whether to sample the texture interpolated. Uses point sampling if false. Initialize() Declaration public static void Initialize()"
  },
  "api/Holoride.ElasticSDK.Compute.html": {
    "href": "api/Holoride.ElasticSDK.Compute.html",
    "title": "Namespace Holoride.ElasticSDK.Compute | ElasticSDK Documentation",
    "keywords": "Namespace Holoride.ElasticSDK.Compute Classes Blur ComputeAlgorithms Provides multi-stage compute shader algorithms such as Push-Pull. CopyBufferToBuffer Wrapper for a compute shader that may be used to copy data from one compute buffer to another. CopyBufferToPreviewTexture Wrapper for a compute shader that may be used to copy data from a compute buffer to a texture that will be used as a preview texture in the graph editor. In particular the compute shader may perform additional mappings of the input data for visualization, e.g. of negative values. CopyBufferToTexture Wrapper for a compute shader that may be used to copy data from a compute buffer to a texture. CopyTextureToBuffer Wrapper for a compute shader that may be used to copy data from a texture into a compute buffer. Inpaint MathOperators MinMax Remap Swizzle Threshold Structs ComputeShaderKernel Wrapper struct for caching information on a single kernel in a compute shader. Enums CopyTextureToBuffer.GrayScaleConversion Options on how the sampled texture is converted to grayscale. Delegates ComputeAlgorithms.PushPullHookAsync Allows hooking into the push-pull algorithm implemented by RunPushPullShaderAsync(ComputeShader, ComputeBuffer, int, int, int, int, int, uint, PushPullHookAsync, PushPullHookAsync, CancellationToken). This can be useful for working with values on a specific mip level, e.g. for extracting the accumulated values on the highest level. Supports multi-frame processing; the hook can expect to be called from a Unity coroutine. MinMax.MinMaxResultConsumer"
  },
  "api/Holoride.ElasticSDK.Compute.Inpaint.html": {
    "href": "api/Holoride.ElasticSDK.Compute.Inpaint.html",
    "title": "Class Inpaint | ElasticSDK Documentation",
    "keywords": "Class Inpaint Inheritance object Inpaint Namespace: Holoride.ElasticSDK.Compute Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] public static class Inpaint Methods DispatchAsync(ComputeBuffer, IList<ComputeBuffer>, int, CancellationToken) Runs an inpaint push-pull-shader on the specified buffer. Buffers are expected to contain data that is semantically a 2D float array with equal edge lengths (i.e. is squared). Declaration public static UniTask DispatchAsync(ComputeBuffer buffer, IList<ComputeBuffer> pyramid, int resolution, CancellationToken cancellationToken = default) Parameters Type Name Description ComputeBuffer buffer The buffer to run the inpaint on. Serves as initial seed and final output buffer. IList<ComputeBuffer> pyramid The pyramid of buffers used by the algorithm. Typically created via AllocatePyramid(IList<ComputeBuffer>, int, int, uint). int resolution The edge length/resolution of the 2D data stored in the buffer. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask An enumerator over the progress of the algorithm, expected to run in a Unity coroutine. DispatchAsync(ComputeBuffer, int, CancellationToken) Runs an inpaint push-pull-shader on the specified buffer. Buffers are expected to contain data that is semantically a 2D float array with equal edge lengths (i.e. is squared). Declaration public static UniTask DispatchAsync(ComputeBuffer buffer, int resolution, CancellationToken cancellationToken = default) Parameters Type Name Description ComputeBuffer buffer The buffer to run the inpaint on. Serves as initial seed and final output buffer. int resolution The edge length/resolution of the 2D data stored in the buffer. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask An enumerator over the progress of the algorithm, expected to run in a Unity coroutine. Initialize() Declaration public static void Initialize()"
  },
  "api/Holoride.ElasticSDK.Compute.MathOperators.html": {
    "href": "api/Holoride.ElasticSDK.Compute.MathOperators.html",
    "title": "Class MathOperators | ElasticSDK Documentation",
    "keywords": "Class MathOperators Inheritance object MathOperators Namespace: Holoride.ElasticSDK.Compute Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] public static class MathOperators Methods Abs(ComputeBuffer, ComputeBuffer) Declaration public static void Abs(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Acos(ComputeBuffer, ComputeBuffer) Declaration public static void Acos(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Add(ComputeBuffer, ComputeBuffer, ComputeBuffer) Declaration public static void Add(ComputeBuffer a, ComputeBuffer b, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer b ComputeBuffer output AddConstant(ComputeBuffer, float, ComputeBuffer) Declaration public static void AddConstant(ComputeBuffer a, float b, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a float b ComputeBuffer output Asin(ComputeBuffer, ComputeBuffer) Declaration public static void Asin(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Atan(ComputeBuffer, ComputeBuffer) Declaration public static void Atan(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Atan2(ComputeBuffer, ComputeBuffer, ComputeBuffer) Declaration public static void Atan2(ComputeBuffer a, ComputeBuffer b, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer b ComputeBuffer output Ceil(ComputeBuffer, ComputeBuffer) Declaration public static void Ceil(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Clamp(ComputeBuffer, ComputeBuffer, ComputeBuffer, ComputeBuffer) Declaration public static void Clamp(ComputeBuffer x, ComputeBuffer a, ComputeBuffer b, ComputeBuffer output) Parameters Type Name Description ComputeBuffer x ComputeBuffer a ComputeBuffer b ComputeBuffer output Cos(ComputeBuffer, ComputeBuffer) Declaration public static void Cos(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Cosh(ComputeBuffer, ComputeBuffer) Declaration public static void Cosh(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Div(ComputeBuffer, ComputeBuffer, ComputeBuffer) Declaration public static void Div(ComputeBuffer a, ComputeBuffer b, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer b ComputeBuffer output Exp(ComputeBuffer, ComputeBuffer) Declaration public static void Exp(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Exp2(ComputeBuffer, ComputeBuffer) Declaration public static void Exp2(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Floor(ComputeBuffer, ComputeBuffer) Declaration public static void Floor(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Frac(ComputeBuffer, ComputeBuffer) Declaration public static void Frac(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Initialize() Declaration public static void Initialize() Lerp(ComputeBuffer, ComputeBuffer, ComputeBuffer, ComputeBuffer) Declaration public static void Lerp(ComputeBuffer a, ComputeBuffer b, ComputeBuffer t, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer b ComputeBuffer t ComputeBuffer output Log(ComputeBuffer, ComputeBuffer) Declaration public static void Log(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Log10(ComputeBuffer, ComputeBuffer) Declaration public static void Log10(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Log2(ComputeBuffer, ComputeBuffer) Declaration public static void Log2(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Max(ComputeBuffer, ComputeBuffer, ComputeBuffer) Declaration public static void Max(ComputeBuffer a, ComputeBuffer b, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer b ComputeBuffer output Min(ComputeBuffer, ComputeBuffer, ComputeBuffer) Declaration public static void Min(ComputeBuffer a, ComputeBuffer b, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer b ComputeBuffer output Mod(ComputeBuffer, ComputeBuffer, ComputeBuffer) Declaration public static void Mod(ComputeBuffer a, ComputeBuffer b, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer b ComputeBuffer output Mul(ComputeBuffer, ComputeBuffer, ComputeBuffer) Declaration public static void Mul(ComputeBuffer a, ComputeBuffer b, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer b ComputeBuffer output MultiplyConstant(ComputeBuffer, float, ComputeBuffer) Declaration public static void MultiplyConstant(ComputeBuffer a, float b, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a float b ComputeBuffer output Neg(ComputeBuffer, ComputeBuffer) Declaration public static void Neg(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output OneMinus(ComputeBuffer, ComputeBuffer) Declaration public static void OneMinus(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Pow(ComputeBuffer, ComputeBuffer, ComputeBuffer) Declaration public static void Pow(ComputeBuffer a, ComputeBuffer b, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer b ComputeBuffer output Round(ComputeBuffer, ComputeBuffer) Declaration public static void Round(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Sign(ComputeBuffer, ComputeBuffer) Declaration public static void Sign(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Sin(ComputeBuffer, ComputeBuffer) Declaration public static void Sin(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Sinh(ComputeBuffer, ComputeBuffer) Declaration public static void Sinh(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output SmoothStep(ComputeBuffer, ComputeBuffer, ComputeBuffer, ComputeBuffer) Declaration public static void SmoothStep(ComputeBuffer a, ComputeBuffer b, ComputeBuffer x, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer b ComputeBuffer x ComputeBuffer output Sqrt(ComputeBuffer, ComputeBuffer) Declaration public static void Sqrt(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Step(ComputeBuffer, ComputeBuffer, ComputeBuffer) Declaration public static void Step(ComputeBuffer a, ComputeBuffer b, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer b ComputeBuffer output Sub(ComputeBuffer, ComputeBuffer, ComputeBuffer) Declaration public static void Sub(ComputeBuffer a, ComputeBuffer b, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer b ComputeBuffer output Tan(ComputeBuffer, ComputeBuffer) Declaration public static void Tan(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Tanh(ComputeBuffer, ComputeBuffer) Declaration public static void Tanh(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output Trunc(ComputeBuffer, ComputeBuffer) Declaration public static void Trunc(ComputeBuffer a, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a ComputeBuffer output"
  },
  "api/Holoride.ElasticSDK.Compute.MinMax.html": {
    "href": "api/Holoride.ElasticSDK.Compute.MinMax.html",
    "title": "Class MinMax | ElasticSDK Documentation",
    "keywords": "Class MinMax Inheritance object MinMax Namespace: Holoride.ElasticSDK.Compute Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] public static class MinMax Methods DispatchAsync(ComputeBuffer, IList<ComputeBuffer>, int, MinMaxResultConsumer, CancellationToken) Computes the global minimum and maximum in float a compute buffer that is expected to semantically be a 2D array. This uses the push step of the push-pull algorithm, and thus needs to run asynchronously. Results are provided using a callback for this reason. Declaration public static UniTask DispatchAsync(ComputeBuffer input, IList<ComputeBuffer> pyramid, int resolution, MinMax.MinMaxResultConsumer resultConsumer, CancellationToken cancellationToken = default) Parameters Type Name Description ComputeBuffer input The buffer to compute the min and max in. IList<ComputeBuffer> pyramid The pyramid of buffers used by the algorithm. Typically created via AllocatePyramid(IList<ComputeBuffer>, int, int, uint). int resolution The edge length/resolution of the 2D data stored in the buffer. MinMax.MinMaxResultConsumer resultConsumer Callback invoked with the minimum and maximum when they have been computed. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask An enumerator over the progress of the algorithm, expected to run in a Unity coroutine. Exceptions Type Condition ArgumentException input has a stride incompatible to float. DispatchAsync(ComputeBuffer, int, MinMaxResultConsumer, CancellationToken) Computes the global minimum and maximum in float a compute buffer that is expected to semantically be a 2D array. This uses the push step of the push-pull algorithm, and thus needs to run asynchronously. Results are provided using a callback for this reason. Declaration public static UniTask DispatchAsync(ComputeBuffer input, int resolution, MinMax.MinMaxResultConsumer resultConsumer, CancellationToken cancellationToken = default) Parameters Type Name Description ComputeBuffer input The buffer to compute the min and max in. int resolution The edge length/resolution of the 2D data stored in the buffer. MinMax.MinMaxResultConsumer resultConsumer Callback invoked with the minimum and maximum when they have been computed. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask An enumerator over the progress of the algorithm, expected to run in a Unity coroutine. Exceptions Type Condition ArgumentException input has a stride incompatible to float . Initialize() Declaration public static void Initialize()"
  },
  "api/Holoride.ElasticSDK.Compute.MinMax.MinMaxResultConsumer.html": {
    "href": "api/Holoride.ElasticSDK.Compute.MinMax.MinMaxResultConsumer.html",
    "title": "Delegate MinMax.MinMaxResultConsumer | ElasticSDK Documentation",
    "keywords": "Delegate MinMax.MinMaxResultConsumer Namespace: Holoride.ElasticSDK.Compute Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public delegate void MinMax.MinMaxResultConsumer(float min, float max) Parameters Type Name Description float min float max"
  },
  "api/Holoride.ElasticSDK.Compute.Remap.html": {
    "href": "api/Holoride.ElasticSDK.Compute.Remap.html",
    "title": "Class Remap | ElasticSDK Documentation",
    "keywords": "Class Remap Inheritance object Remap Namespace: Holoride.ElasticSDK.Compute Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] public static class Remap Methods Dispatch(ComputeBuffer, ComputeBuffer, float, float, float, float, AnimationCurve) Declaration public static void Dispatch(ComputeBuffer input, ComputeBuffer output, float inputMinValue, float inputMaxValue, float outputMinValue, float outputMaxValue, AnimationCurve curve) Parameters Type Name Description ComputeBuffer input ComputeBuffer output float inputMinValue float inputMaxValue float outputMinValue float outputMaxValue AnimationCurve curve Dispatch(ComputeBuffer, ComputeBuffer, float, float, float, float, Vector4[]) Declaration public static void Dispatch(ComputeBuffer input, ComputeBuffer output, float inputMinValue, float inputMaxValue, float outputMinValue, float outputMaxValue, Vector4[] curveSamples) Parameters Type Name Description ComputeBuffer input ComputeBuffer output float inputMinValue float inputMaxValue float outputMinValue float outputMaxValue Vector4[] curveSamples Dispatch(ComputeBuffer, ComputeBuffer, float, float) Declaration public static void Dispatch(ComputeBuffer input, ComputeBuffer output, float inputMinValue, float inputMaxValue) Parameters Type Name Description ComputeBuffer input ComputeBuffer output float inputMinValue float inputMaxValue Dispatch(CommandBuffer, ComputeBuffer, ComputeBuffer, float, float, float, float, AnimationCurve) Declaration public static void Dispatch(CommandBuffer commandBuffer, ComputeBuffer input, ComputeBuffer output, float inputMinValue, float inputMaxValue, float outputMinValue, float outputMaxValue, AnimationCurve curve) Parameters Type Name Description CommandBuffer commandBuffer ComputeBuffer input ComputeBuffer output float inputMinValue float inputMaxValue float outputMinValue float outputMaxValue AnimationCurve curve Dispatch(CommandBuffer, ComputeBuffer, ComputeBuffer, float, float, float, float, Vector4[]) Declaration public static void Dispatch(CommandBuffer commandBuffer, ComputeBuffer input, ComputeBuffer output, float inputMinValue, float inputMaxValue, float outputMinValue, float outputMaxValue, Vector4[] curveSamples) Parameters Type Name Description CommandBuffer commandBuffer ComputeBuffer input ComputeBuffer output float inputMinValue float inputMaxValue float outputMinValue float outputMaxValue Vector4[] curveSamples Dispatch(CommandBuffer, ComputeBuffer, ComputeBuffer, float, float) Declaration public static void Dispatch(CommandBuffer commandBuffer, ComputeBuffer input, ComputeBuffer output, float inputMinValue, float inputMaxValue) Parameters Type Name Description CommandBuffer commandBuffer ComputeBuffer input ComputeBuffer output float inputMinValue float inputMaxValue Initialize() Declaration public static void Initialize()"
  },
  "api/Holoride.ElasticSDK.Compute.Swizzle.html": {
    "href": "api/Holoride.ElasticSDK.Compute.Swizzle.html",
    "title": "Class Swizzle | ElasticSDK Documentation",
    "keywords": "Class Swizzle Inheritance object Swizzle Namespace: Holoride.ElasticSDK.Compute Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] public static class Swizzle Methods Dispatch2D1DXX(ComputeBuffer, ComputeBuffer) Copies a float compute buffer into a float2 compute buffer by using a .xx swizzle. Declaration public static void Dispatch2D1DXX(ComputeBuffer input, ComputeBuffer output) Parameters Type Name Description ComputeBuffer input The buffer to copy the data from. ComputeBuffer output The buffer to copy the data to. Exceptions Type Condition ArgumentException input is the same buffer as output. ArgumentException input differs in count from output. ArgumentException input has a stride incompatible to float. ArgumentException output has a stride incompatible to float2. Initialize() Declaration public static void Initialize()"
  },
  "api/Holoride.ElasticSDK.Compute.Threshold.html": {
    "href": "api/Holoride.ElasticSDK.Compute.Threshold.html",
    "title": "Class Threshold | ElasticSDK Documentation",
    "keywords": "Class Threshold Inheritance object Threshold Namespace: Holoride.ElasticSDK.Compute Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] public static class Threshold Methods Dispatch(ComputeBuffer, ComputeBuffer, float, float) Declaration public static void Dispatch(ComputeBuffer input, ComputeBuffer output, float minThreshold, float maxThreshold) Parameters Type Name Description ComputeBuffer input ComputeBuffer output float minThreshold float maxThreshold Dispatch(CommandBuffer, ComputeBuffer, ComputeBuffer, float, float) Declaration public static void Dispatch(CommandBuffer commandBuffer, ComputeBuffer input, ComputeBuffer output, float minThreshold, float maxThreshold) Parameters Type Name Description CommandBuffer commandBuffer ComputeBuffer input ComputeBuffer output float minThreshold float maxThreshold Initialize() Declaration public static void Initialize()"
  },
  "api/Holoride.ElasticSDK.ContextProviderAttribute.html": {
    "href": "api/Holoride.ElasticSDK.ContextProviderAttribute.html",
    "title": "Class ContextProviderAttribute | ElasticSDK Documentation",
    "keywords": "Class ContextProviderAttribute Declares that the annotated IContextProvider provides the context type specified in this attribute. This is used to automatically attach instances of this provider to systems that execute a Pipeline consuming the context provided by this provider. Inheritance object Attribute ContextProviderAttribute Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] [BaseTypeRequired(typeof(IContextProvider))] public class ContextProviderAttribute : Attribute Constructors ContextProviderAttribute(Type) Declaration public ContextProviderAttribute(Type contextType) Parameters Type Name Description Type contextType Properties ContextType Declaration public Type ContextType { get; } Property Value Type Description Type"
  },
  "api/Holoride.ElasticSDK.DataProviderWorker-1.html": {
    "href": "api/Holoride.ElasticSDK.DataProviderWorker-1.html",
    "title": "Class DataProviderWorker<TDataType> | ElasticSDK Documentation",
    "keywords": "Class DataProviderWorker<TDataType> The worker with a back reference to the node. Represents the result of the different evaluations of structs. Inheritance object PipelineWorkerBase DataProviderWorker<TDataType> DataProviderNode<TDataType>.DataProviderNodeWorker<T> Implements IPipelineWorker Inherited Members PipelineWorkerBase.GenerationSettings PipelineWorkerBase.GenerationState PipelineWorkerBase.CurrentGenerationContext PipelineWorkerBase.Pipeline PipelineWorkerBase.IsGatheringResources PipelineWorkerBase.IsProcessing PipelineWorkerBase.Inputs PipelineWorkerBase.MissingMandatoryInputs PipelineWorkerBase.AddMissingMandatoryInput(string) PipelineWorkerBase.HasMissingMandatoryInputInHierarchy PipelineWorkerBase.AddInput(string, IPipelineWorker) PipelineWorkerBase.GetInput(string) PipelineWorkerBase.GetInput<T>(string) PipelineWorkerBase.InitResources() PipelineWorkerBase.CallInitResources() PipelineWorkerBase.Init() PipelineWorkerBase.CallInit() PipelineWorkerBase.GatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.CallGatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.ProcessAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.CallProcessAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.Dispose() PipelineWorkerBase.CleanUp() PipelineWorkerBase.CallCleanUp() Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] public class DataProviderWorker<TDataType> : PipelineWorkerBase, IPipelineWorker Type Parameters Name Description TDataType The type of data that the specific structs hold. Properties ProviderData Gets the provided data in a whole without the need to evaluate it. Declaration public virtual IEnumerable<TDataType> ProviderData { get; } Property Value Type Description IEnumerable<TDataType> Implements IPipelineWorker"
  },
  "api/Holoride.ElasticSDK.DataRegion.html": {
    "href": "api/Holoride.ElasticSDK.DataRegion.html",
    "title": "Enum DataRegion | ElasticSDK Documentation",
    "keywords": "Enum DataRegion Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public enum DataRegion Fields Name Description EU US"
  },
  "api/Holoride.ElasticSDK.DefaultRequestAttribute.html": {
    "href": "api/Holoride.ElasticSDK.DefaultRequestAttribute.html",
    "title": "Class DefaultRequestAttribute | ElasticSDK Documentation",
    "keywords": "Class DefaultRequestAttribute The class implementing this interface is the default subtype. A random subtype is returned in the undefined case of multiple IDefault implementations of the same base type. Inheritance object Attribute DefaultRequestAttribute Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Class)] [MeansImplicitUse] public class DefaultRequestAttribute : Attribute"
  },
  "api/Holoride.ElasticSDK.ElasticObjectPoolDefaultSettings.html": {
    "href": "api/Holoride.ElasticSDK.ElasticObjectPoolDefaultSettings.html",
    "title": "Class ElasticObjectPoolDefaultSettings | ElasticSDK Documentation",
    "keywords": "Class ElasticObjectPoolDefaultSettings Inheritance object ElasticObjectPoolDefaultSettings Implements IElasticObjectPoolSettings Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [Serializable] public class ElasticObjectPoolDefaultSettings : IElasticObjectPoolSettings Constructors ElasticObjectPoolDefaultSettings(int, int, int) Declaration public ElasticObjectPoolDefaultSettings(int maxPoolSize = 10, int initPoolSize = 0, int maxInitFrames = 1) Parameters Type Name Description int maxPoolSize int initPoolSize int maxInitFrames Properties InitPoolSize Gets or sets the initial amount of instances the spawning pool is going to be instantiated with. Declaration public int InitPoolSize { get; set; } Property Value Type Description int MaxInitFrames Gets or sets the maximum amount of frames taken to instantiate initial spawning pool. Declaration public int MaxInitFrames { get; set; } Property Value Type Description int MaxPoolSize Gets or sets the maximum amount of instances the spawning pool is going to create. Supports runtime change. Declaration public int MaxPoolSize { get; set; } Property Value Type Description int Implements IElasticObjectPoolSettings"
  },
  "api/Holoride.ElasticSDK.ElasticObjectPoolManager.html": {
    "href": "api/Holoride.ElasticSDK.ElasticObjectPoolManager.html",
    "title": "Class ElasticObjectPoolManager | ElasticSDK Documentation",
    "keywords": "Class ElasticObjectPoolManager Default object pooling implementation using the PooledObject component to mark prefabs for object pooling. Inheritance object Object Component Behaviour MonoBehaviour ElasticObjectPoolManager Implements IPrefabInstantiationProvider IContextProvider Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [ContextProvider(typeof(PrefabInstantiationContext))] [HelpURL(\"http://localhost:8080/api/Holoride.ElasticSDK.ElasticObjectPoolManager.html\")] public class ElasticObjectPoolManager : MonoBehaviour, IPrefabInstantiationProvider, IContextProvider Fields DefaultSettings Default pool settings that will be used if there was no specific settings asset for an individual pool specified. Declaration [Tooltip(\"Default pool settings that will be used if there was no specific settings asset for an individual pool specified.\")] public ElasticObjectPoolDefaultSettings DefaultSettings Field Value Type Description ElasticObjectPoolDefaultSettings PoolSettings Declaration public List<ElasticObjectPoolSettings> PoolSettings Field Value Type Description List<ElasticObjectPoolSettings> Properties IsDirty Gets a value indicating whether data provided by this context has changed and requires the Pipeline using this context needs to run again. Declaration public bool IsDirty { get; } Property Value Type Description bool Methods Clear(PooledObject) Manually clears (but does not destroy) a pool in the context dictionary. Declaration public void Clear(PooledObject poolKey) Parameters Type Name Description PooledObject poolKey The component key of the pool that should be cleared. ClearAll() Manually clears (but does not destroy) all pools in the context dictionary. Declaration public void ClearAll() Despawn(GameObject) Releases an instance previously obtained via Spawn(GameObject, Vector3, Quaternion, Vector3, Func<GameObject, UniTask>, CancellationToken). Declaration public bool Despawn(GameObject instance) Parameters Type Name Description GameObject instance The instance to release. Returns Type Description bool Whether the implementation handled the specified instance. When this returns false, it is the responsibility of the caller to decide whether the instance should be destroyed or treated otherwise. Init(GameObject, Action<GameObject>) Creates initial instances of the specified prefab. Declaration [Obsolete(\"Use the async overload instead.\")] public IEnumerator Init(GameObject prefab, Action<GameObject> initAction = null) Parameters Type Name Description GameObject prefab Action<GameObject> initAction Returns Type Description IEnumerator InitAsync(GameObject, Action<GameObject>, CancellationToken) Creates initial instances of the specified prefab. Declaration public UniTask InitAsync(GameObject prefab, Action<GameObject> initAction = null, CancellationToken cancellationToken = default) Parameters Type Name Description GameObject prefab The prefab to instantiate. Action<GameObject> initAction Optional initial action to invoke specific initialization behavior. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask ProvideContextAsync(GenerationSettings, GenerationContext, ISet<Type>, CancellationToken) Adds the IGenerationContext instances provided by this provider to the specified GenerationContext as an extension. To add IGenerationSettings instances to the passed GenerationSettings instance, use an ISettingsProvider. Declaration public UniTask ProvideContextAsync(GenerationSettings settings, GenerationContext context, ISet<Type> requiredContextTypes, CancellationToken cancellationToken) Parameters Type Name Description GenerationSettings settings The global generation settings used. GenerationContext context The context to add the provided extension contexts to. ISet<Type> requiredContextTypes The set of context types that workers in the pipeline the context is being built for require. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask Optional enumerator in case context initialization must run asynchronously. Spawn(GameObject, Vector3, Quaternion, Vector3, Func<GameObject, UniTask>, CancellationToken) Creates an instance of the specified prefab. Declaration public UniTask<(bool Success, GameObject Result)> Spawn(GameObject prefab, Vector3 position, Quaternion rotation, Vector3 scale, Func<GameObject, UniTask> preSpawnAction = null, CancellationToken cancellationToken = default) Parameters Type Name Description GameObject prefab The prefab to spawn. Vector3 position The global position to place the instance at. Quaternion rotation The global rotation to set on the instance. Vector3 scale The scale to set on the instance. Func<GameObject, Cysharp.Threading.Tasks.UniTask> preSpawnAction Func delegate to be invoked before the GameObject is activated. Currently used for graph data injection. CancellationToken cancellationToken Token to cancel the async UniTask operation. Returns Type Description Cysharp.Threading.Tasks.UniTask<T><(bool Success, GameObject Result)> Indicates whether an instance was created. When this returns false, this indicates the instantiation should not be performed. Implements IPrefabInstantiationProvider IContextProvider"
  },
  "api/Holoride.ElasticSDK.ElasticObjectPoolSettings.html": {
    "href": "api/Holoride.ElasticSDK.ElasticObjectPoolSettings.html",
    "title": "Class ElasticObjectPoolSettings | ElasticSDK Documentation",
    "keywords": "Class ElasticObjectPoolSettings Inheritance object Object ScriptableObject ElasticObjectPoolSettings Implements IElasticObjectPoolSettings Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [CreateAssetMenu(fileName = \"Elastic Object Pool Settings\", menuName = \"holoride/Elastic Object Pool Settings\", order = 9)] public class ElasticObjectPoolSettings : ScriptableObject, IElasticObjectPoolSettings Fields PooledPrefab The referenced GameObject Prefab whose spawning pool will be configured according to these settings. Declaration [Tooltip(\"The referenced GameObject Prefab whose pool will be configured according to these settings.\")] public GameObject PooledPrefab Field Value Type Description GameObject Properties InitPoolSize Gets or sets the initial amount of instances the spawning pool is going to be instantiated with. Declaration public int InitPoolSize { get; set; } Property Value Type Description int MaxInitFrames Gets or sets the maximum amount of frames taken to instantiate initial spawning pool. Declaration public int MaxInitFrames { get; set; } Property Value Type Description int MaxPoolSize Gets or sets the maximum amount of instances the spawning pool is going to create. Supports runtime change. Declaration public int MaxPoolSize { get; set; } Property Value Type Description int Methods Init(GameObject, int, int, int) Declaration public void Init(GameObject pooledPrefab, int maxPoolSize = 0, int initPoolSize = 0, int maxInitFrames = 1) Parameters Type Name Description GameObject pooledPrefab int maxPoolSize int initPoolSize int maxInitFrames OnValidate() Declaration public void OnValidate() Implements IElasticObjectPoolSettings"
  },
  "api/Holoride.ElasticSDK.ElasticSceneGenerator.html": {
    "href": "api/Holoride.ElasticSDK.ElasticSceneGenerator.html",
    "title": "Class ElasticSceneGenerator | ElasticSDK Documentation",
    "keywords": "Class ElasticSceneGenerator This class produces a realized scene from a Graph.ElasticSceneDefinitionNode for the current center location (specified via GenerationOrigin). In addition to running any spawners in the defined scene definition, this entails generation of a Terrain if a height map has been specified. During movement of the player, the generator takes care that the generated terrain and any spawned objects get refreshed. For the terrain, this means re-creating the current terrain area when the player moves past a threshold. For spawned objects, this means updating their spawners, so they may discard instances that have gone out of range and instantiate new spawn candidates that have come in range. The TerrainGenerator maintains all the basic information about the terrain like the different resolutions of the heightmap, the alphamaps, the base map and the spawn areas. Also the general extents of the resulting terrain are defined here. Inheritance object Object Component Behaviour MonoBehaviour ElasticSceneGenerator Implements IPipelineContainer Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [AddComponentMenu(\"holoride/Elastic Scene Generator\")] [HelpURL(\"http://localhost:8080/api/Holoride.ElasticSDK.ElasticSceneGenerator.html\")] public class ElasticSceneGenerator : MonoBehaviour, IPipelineContainer Fields AutoGenerate States if the terrain start generating automatically. Declaration [Tooltip(\"States if the terrain start generating automatically.\")] public bool AutoGenerate Field Value Type Description bool AutoUpdate States if the terrain should update/refresh automatically. Declaration [Tooltip(\"States if the terrain should update/refresh automatically.\")] public bool AutoUpdate Field Value Type Description bool BasemapDistance The distance the terrain rendering falls back to a pre-lightened basemap. Declaration [Tooltip(\"The distance the terrain rendering falls back to a pre-lightened basemap.\")] [Range(1, 20000)] public float BasemapDistance Field Value Type Description float BaseMapResolution The resolution of the basemap as defined by the Unity's Terrain class. Declaration [Tooltip(\"The resolution of the basemap as defined by the Unity's Terrain class.\")] [Range(64, 2048)] public int BaseMapResolution Field Value Type Description int BlendMargin The blend margin between overlapping terrains. Declaration [Tooltip(\"The blend margin between overlapping terrains.\")] [Range(0, 1)] public float BlendMargin Field Value Type Description float BoundsDistanceThreshold Offset from the InnerBounds of the latest finished generation context, in meters. When this threshold is reached, the OnEnterGenerationOverdue event is invoked. Declaration [Tooltip(\"Offset from GenerationContext.InnerBounds of the latest finished generation context, in meters. When this threshold is reached, the OnGenerationOverdue event is invoked.\")] public float BoundsDistanceThreshold Field Value Type Description float CurrentTerrain The current Terrain object. Declaration [HideInInspector] public Terrain CurrentTerrain Field Value Type Description Terrain DisabledCollisionGOLayer A layer that's excluded from terrain collision which is particularly important for collision solving. Declaration [Tooltip(\"A layer that's excluded from terrain collision which is particularly important for collision solving.\")] public int DisabledCollisionGOLayer Field Value Type Description int DrawInstanced States whether to enable instanced drawing of the terrain. Declaration [Tooltip(\"States whether to enable instanced drawing of the terrain.\")] public bool DrawInstanced Field Value Type Description bool Extents The edge length of the square terrain. Declaration [Tooltip(\"The edge length of the square terrain.\")] public float Extents Field Value Type Description float GenerationOrigin The transform position where the terrain is generated. Declaration [Tooltip(\"The transform position where the terrain is generated.\")] public Transform GenerationOrigin Field Value Type Description Transform GridDivisions The divisions of a terrain to trigger updates. Declaration public int GridDivisions Field Value Type Description int HeightmapPixelError The PixelError property as defined by Unity's Terrain class that controls the trade-off between rendering performance and popup artifacts. Declaration [Tooltip(\"The PixelError property as defined by Unity's Terrain class that controls the trade-off between rendering performance and popup artifacts.\")] [Range(1, 200)] public float HeightmapPixelError Field Value Type Description float HeightOffset The height offset between the pivot altitude and the terrain zero value. Changing this value lowers or raises the entire terrain. Declaration [Tooltip(\"The height offset between the pivot altitude and the terrain zero value. Changing this value lowers or raises the entire terrain.\")] public float HeightOffset Field Value Type Description float HeightUploadChunkCount The number of frames the upload process of the heightmap to the VRAM is distributed into. A trade-off between performance and the time-span it takes. Declaration [Tooltip(\"The number of frames the upload process of the heightmap into VRAM is distributed into. A trade-off between performance and the time-span it takes.\")] [Range(1, 256)] public int HeightUploadChunkCount Field Value Type Description int MapResolution The resolution of the heightmap of the Terrain and the maps of the graph. This value has a large influence on the terrain rendering performance, the memory consumption and the time it takes to generate the terrain. Declaration [Tooltip(\"The resolution of the heightmap of the Terrain and the maps of the graph. This value has a large influence on the terrain rendering performance, the memory consumption and the time it takes to generate the terrain.\")] [Range(64, 2048)] [FormerlySerializedAs(\"TerrainResolution\")] public int MapResolution Field Value Type Description int MaxHeight The maximum height above/below sea level. Declaration [Tooltip(\"The maximum height above/below sea level.\")] public float MaxHeight Field Value Type Description float MinHeight The minimum height above/below sea level. Declaration [Tooltip(\"The minimum height above/below sea level.\")] public float MinHeight Field Value Type Description float OnEnterGenerationOverdue The event which is invoked when the GenerationOrigin, i.e. the Player, got too close to the latest finished generation context's InnerBounds, based on the given BoundsDistanceThreshold. Declaration public UnityEvent OnEnterGenerationOverdue Field Value Type Description UnityEvent OnGenerationFinished The event which is called when the initial generation process is finished. Declaration public UnityEvent<GenerationContext> OnGenerationFinished Field Value Type Description UnityEvent<GenerationContext> Remarks Propagates the latest finished GenerationContext. OnGenerationStarted The event which is called when the initial generation process has started. Declaration public UnityEvent OnGenerationStarted Field Value Type Description UnityEvent OnLeaveGenerationOverdue The event which is invoked when the current generation left the overdue state. Declaration public UnityEvent OnLeaveGenerationOverdue Field Value Type Description UnityEvent OnUpdateFinished The event which is called every time a generation process has finished. Declaration public UnityEvent<GenerationContext> OnUpdateFinished Field Value Type Description UnityEvent<GenerationContext> Remarks Propagates the latest finished GenerationContext. OnUpdateStarted The event which is called every time a generation process has started. Declaration public UnityEvent OnUpdateStarted Field Value Type Description UnityEvent Parent The parent of the terrain and all spawned objects. Declaration [Tooltip(\"The parent of the terrain and all spawned objects.\")] public GameObject Parent Field Value Type Description GameObject QuarterSizedTerrainObject States whether to quarter the size of the generated terrain. This reduces the popup effects caused by incoming data. Declaration [Tooltip(\"States whether to quarter the size of the generated terrain. This reduces the popup effects caused by incoming data.\")] public bool QuarterSizedTerrainObject Field Value Type Description bool SceneDefinition The terrain compositing node that was added to an elastic graph. Declaration [FormerlySerializedAs(\"TerrainCompositing\")] [Tooltip(\"The terrain compositing node that was added to an elastic graph.\")] public ElasticSceneDefinitionNode SceneDefinition Field Value Type Description ElasticSceneDefinitionNode TerrainGenerationState Contains the current terrain related state of the generation process and will be updated over time. Declaration public TerrainGenerationState TerrainGenerationState Field Value Type Description TerrainGenerationState TerrainGOLayer The GameObject layer of the generated terrain. Declaration [Tooltip(\"The GameObject layer of the generated terrain.\")] public int TerrainGOLayer Field Value Type Description int TerrainMaterial The material used for terrain rendering. Declaration [Tooltip(\"The material used for terrain rendering.\")] public Material TerrainMaterial Field Value Type Description Material TextureWeightmapUploadChunkCount The number of frames the upload process of the texture weightmap to the VRAM is distributed into. A trade-off between performance and the time-span it takes. Declaration [Tooltip(\"The number of frames the upload process of the texture weightmap into VRAM is distributed into. A trade-off between performance and the time-span it takes.\")] [Range(1, 256)] public int TextureWeightmapUploadChunkCount Field Value Type Description int Properties FrameBudget Gets or sets the frame budget when processing a pipeline. If zero, it will proceed with the least possible impact on every frame. Declaration public TimeSpan FrameBudget { get; set; } Property Value Type Description TimeSpan GeneratedNodeWorkers Gets a mapping between the current graph nodes and their generated workers. Declaration public Dictionary<IPipelineNode, IPipelineWorker> GeneratedNodeWorkers { get; } Property Value Type Description Dictionary<IPipelineNode, IPipelineWorker> IsGenerationStateOverdue Gets a value indicating whether the current generation is overdue. Declaration public bool IsGenerationStateOverdue { get; } Property Value Type Description bool IsGeneratorRunning Gets a value indicating whether the generation process is running. Declaration public bool IsGeneratorRunning { get; } Property Value Type Description bool Pipeline Gets the pipeline that is generated from the node graph when starting the generation process. Declaration public Pipeline Pipeline { get; } Property Value Type Description Pipeline ShiftManager Declaration public WorldShiftManager ShiftManager { get; set; } Property Value Type Description WorldShiftManager TerrainExtents Gets the terrain extents while taking the half resolution option into account. Declaration public float TerrainExtents { get; } Property Value Type Description float TerrainResolution Gets the terrain resolution while taking the half resolution option into account. Declaration public int TerrainResolution { get; } Property Value Type Description int Methods OnValidate() Implements the OnValidate method of the MonoBehaviour life-cycle. Declaration public void OnValidate() StartGenerator() Generates the Terrain and starts the spawning process. Declaration public void StartGenerator() StopGenerator() Destroys the terrain. Declaration public void StopGenerator() TryGetGlobalOutput<T>(int, GlobalPosition, CancellationToken) Returns the data of the connected OutputNode at a specific position.. Declaration public UniTask<(bool Success, T Result)> TryGetGlobalOutput<T>(int portIndex, GlobalPosition position, CancellationToken cancellationToken = default) Parameters Type Name Description int portIndex Index starting at 0 of the OutputNodes. GlobalPosition position Samples the OutputNode at a certain position. CancellationToken cancellationToken Token to cancel the async UniTask operation. Returns Type Description Cysharp.Threading.Tasks.UniTask<T><(bool Success, T Result)> The value returned from the mapper by passing the input node. Type Parameters Name Description T Used to select which IWorkerMapper will be used. TryGetGlobalOutput<T>(int, CancellationToken) Returns the data of the connected OutputNode. Declaration public UniTask<(bool Success, T Result)> TryGetGlobalOutput<T>(int portIndex, CancellationToken cancellationToken = default) Parameters Type Name Description int portIndex Index starting at 0 of the OutputNodes. CancellationToken cancellationToken Token to cancel the async UniTask operation. Returns Type Description Cysharp.Threading.Tasks.UniTask<T><(bool Success, T Result)> The value returned from the mapper by passing the input node. Type Parameters Name Description T Used to select which IWorkerMapper will be used. TryGetGlobalOutput<T>(string, GlobalPosition, CancellationToken) Returns the data of the connected OutputNode at a specific position. Declaration public UniTask<(bool Success, T Result)> TryGetGlobalOutput<T>(string portName, GlobalPosition position, CancellationToken cancellationToken = default) Parameters Type Name Description string portName Name of the port as displayed in the node graph. GlobalPosition position Samples the OutputNode at a certain position. CancellationToken cancellationToken Token to cancel the async UniTask operation. Returns Type Description Cysharp.Threading.Tasks.UniTask<T><(bool Success, T Result)> The value returned from the mapper by passing the input node. Type Parameters Name Description T Used to select which Mapper (either INodeMapper or IWorkerMapper) will be used. TryGetGlobalOutput<T>(string, CancellationToken) Returns the data of the connected OutputNode. Declaration public UniTask<(bool Success, T Result)> TryGetGlobalOutput<T>(string portName, CancellationToken cancellationToken = default) Parameters Type Name Description string portName Name of the port as displayed in the node graph. CancellationToken cancellationToken Token to cancel the async UniTask operation. Returns Type Description Cysharp.Threading.Tasks.UniTask<T><(bool Success, T Result)> The value returned from the mapper by passing the input node. Type Parameters Name Description T Used to select which Mapper (either INodeMapper or IWorkerMapper) will be used. Implements IPipelineContainer"
  },
  "api/Holoride.ElasticSDK.ExtensibleObject-1.html": {
    "href": "api/Holoride.ElasticSDK.ExtensibleObject-1.html",
    "title": "Class ExtensibleObject<TBase> | ElasticSDK Documentation",
    "keywords": "Class ExtensibleObject<TBase> Derived objects can be extended by fields and functions. Extending classes need to be derivations from Supertype. Inheritance object ExtensibleObject<TBase> GenerationContext GenerationSettings GenerationState Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class ExtensibleObject<TBase> Type Parameters Name Description TBase Fields Extensions The extensions attached to this object. Declaration protected readonly Dictionary<Type, TBase> Extensions Field Value Type Description Dictionary<Type, TBase> Methods GetExtension<T>() Gets an extension of a given type. Declaration public T GetExtension<T>() where T : class, TBase Returns Type Description T The extension of the given type. Type Parameters Name Description T SetExtension(TBase) Sets an extension. Declaration public void SetExtension(TBase extension) Parameters Type Name Description TBase extension The extension to set. TryGetExtension<T>(out T) Gets an extension of a given type. Declaration public bool TryGetExtension<T>(out T result) where T : class, TBase Parameters Type Name Description T result The extension. Returns Type Description bool Whether the extension was set. Type Parameters Name Description T"
  },
  "api/Holoride.ElasticSDK.FileUtils.html": {
    "href": "api/Holoride.ElasticSDK.FileUtils.html",
    "title": "Class FileUtils | ElasticSDK Documentation",
    "keywords": "Class FileUtils Inheritance object FileUtils Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public static class FileUtils Methods CreateDirectoryIfMissing(string) Creates a directoy at the given path in the case it doesn't exist. Declaration public static DirectoryInfo CreateDirectoryIfMissing(string path) Parameters Type Name Description string path The path where to create the drectory. Returns Type Description DirectoryInfo The DirectoryInfo of the created directory or null if the directory already existed. ReadStringFromFile(string) Reads a string from a file. Declaration public static string ReadStringFromFile(string filePath) Parameters Type Name Description string filePath The string read from a file. Returns Type Description string The read string or null if the file could not be read. RemoveInvalidChars(string) Removes all invalid characters from a filename. Declaration public static string RemoveInvalidChars(string filename) Parameters Type Name Description string filename The name of the file. Returns Type Description string The cleaned name of the file. WriteStringToFile(string, string) Writes a string to a file. Declaration public static void WriteStringToFile(string s, string filePath) Parameters Type Name Description string s The string to write into the file. string filePath The path of the file."
  },
  "api/Holoride.ElasticSDK.FixedPositionStateReceiverBackend.html": {
    "href": "api/Holoride.ElasticSDK.FixedPositionStateReceiverBackend.html",
    "title": "Class FixedPositionStateReceiverBackend | ElasticSDK Documentation",
    "keywords": "Class FixedPositionStateReceiverBackend Inheritance object Object ScriptableObject StateReceiverBackend FixedPositionStateReceiverBackend Inherited Members StateReceiverBackend.State StateReceiverBackend.TravelInformationState StateReceiverBackend.Route StateReceiverBackend.AllListeners StateReceiverBackend.LocalizationListeners StateReceiverBackend.AddListener(IStateReceiverListener) StateReceiverBackend.RemoveListener(IStateReceiverListener) StateReceiverBackend.NotifyListenerConfigurationChanged() StateReceiverBackend.Pivot StateReceiverBackend.IsEnabled StateReceiverBackend.Disable() StateReceiverBackend.Update() StateReceiverBackend.OnApplicationResume() StateReceiverBackend.OnListenerAdded(IStateReceiverListener) StateReceiverBackend.OnListenerRemoved(IStateReceiverListener) StateReceiverBackend.OnDestroy() StateReceiverBackend.OnStateUpdated() StateReceiverBackend.OnStateReceivedAsync(VehicleSensorState) StateReceiverBackend.OnRouteChanged() StateReceiverBackend.OnMapAccessTokenReceived(string) StateReceiverBackend.UpdatePivot(GeoCoordinate) Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.StateReceivers.dll Syntax [PublicAPI] public sealed class FixedPositionStateReceiverBackend : StateReceiverBackend Properties Location Gets or sets the GeoCoordinate this state receiver backend emits. Declaration public GeoCoordinate Location { get; set; } Property Value Type Description GeoCoordinate VehicleSensorState Declaration public override VehicleSensorState VehicleSensorState { get; protected set; } Property Value Type Description VehicleSensorState Overrides StateReceiverBackend.VehicleSensorState Methods Enable() Declaration public override void Enable() Overrides StateReceiverBackend.Enable()"
  },
  "api/Holoride.ElasticSDK.FloatingPlatform.html": {
    "href": "api/Holoride.ElasticSDK.FloatingPlatform.html",
    "title": "Class FloatingPlatform | ElasticSDK Documentation",
    "keywords": "Class FloatingPlatform Inheritance object Object Component Behaviour MonoBehaviour FloatingPlatform Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [HelpURL(\"http://localhost:8080/api/Holoride.ElasticSDK.FloatingPlatform.html\")] [Obsolete(\"FloatingPlatform is obsolete. Use StylizedVehicleRotation instead.\", false)] public class FloatingPlatform : MonoBehaviour Fields LateralAccelerationRollCurve Defines how the absolute left-right acceleration (in m/s^2) affects the transform's signed roll rotation around the z-axis (in degrees). Declaration [Tooltip(\"Defines how the absolute left-right acceleration (in m/s^2) affects the transform's signed roll rotation around the z-axis (in degrees).\")] public AnimationCurve LateralAccelerationRollCurve Field Value Type Description AnimationCurve LateralAccelerationSmoothingCount The strength of the lateral motion smoothing. Note: This induces latency which might affect UX and motion sickness. Declaration [Tooltip(\"The strength of the lateral motion smoothing. Note: This induces latency which might affect UX and motion sickness.\")] [SerializeField] [Range(1, 100)] public int LateralAccelerationSmoothingCount Field Value Type Description int LongitudinalAccelerationPitchCurve Defines how the absolute forward-backward acceleration (in m/s^2) affects the transform's signed pitch rotation around the x-axis (in degrees). Declaration [Tooltip(\"Defines how the absolute forward-backward acceleration (in m/s^2) affects the transform's signed pitch rotation around the x-axis (in degrees).\")] public AnimationCurve LongitudinalAccelerationPitchCurve Field Value Type Description AnimationCurve LongitudinalAccelerationSmoothingCount The strength of the longitudinal motion smoothing. Note: This induces latency which might affect UX and motion sickness. Declaration [Tooltip(\"The strength of the longitudinal motion smoothing. Note: This induces latency which might affect UX and motion sickness.\")] [SerializeField] [Range(1, 100)] public int LongitudinalAccelerationSmoothingCount Field Value Type Description int Methods MapLateralAccelerationToRoll(float) The function to map the lateral acceleration from the sensors to the roll rotation of the floating platform. Declaration public float MapLateralAccelerationToRoll(float lateralAcceleration) Parameters Type Name Description float lateralAcceleration The smoothed lateral acceleration in m/s^2 coming from the coming from the sensors. Returns Type Description float The roll rotation in degrees. MapLongitudinalAccelerationToPitch(float) The function to map the longitudinal acceleration from the sensors to the roll rotation of the floating platform. Declaration public float MapLongitudinalAccelerationToPitch(float longitudinalAcceleration) Parameters Type Name Description float longitudinalAcceleration The smoothed longitudinal acceleration in m/s^2 coming from the sensors. Returns Type Description float The pitch rotation in degrees."
  },
  "api/Holoride.ElasticSDK.FrameBudgetTask.html": {
    "href": "api/Holoride.ElasticSDK.FrameBudgetTask.html",
    "title": "Class FrameBudgetTask | ElasticSDK Documentation",
    "keywords": "Class FrameBudgetTask Provides frame budget observing tasks. Inheritance object FrameBudgetTask Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public static class FrameBudgetTask Properties FrameBudget Gets or sets the global, shared frame budget for tasks that may run over several frames. Used to wait for the next frame if the budget is exceeded, otherwise continue synchronously by using the tasks returned from NextFrameIfNecessary(CancellationToken). Declaration public static TimeSpan FrameBudget { get; set; } Property Value Type Description TimeSpan Methods NextFrameIfNecessary(CancellationToken) Returns a task that completes synchronously if there is still some frame budget remaining, otherwise a task that delays execution to the next frame, in the same way Cysharp.Threading.Tasks.UniTask.NextFrame does. Declaration public static UniTask NextFrameIfNecessary(CancellationToken cancellationToken = default) Parameters Type Name Description CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask"
  },
  "api/Holoride.ElasticSDK.GenerationContext.html": {
    "href": "api/Holoride.ElasticSDK.GenerationContext.html",
    "title": "Class GenerationContext | ElasticSDK Documentation",
    "keywords": "Class GenerationContext Contains the immutable meta-information of a single update iteration. Will be discarded when the update is done but can be kept by functions that need information about former iterations - such as async operations that may last longer than an update period. Inheritance object ExtensibleObject<IGenerationContext> GenerationContext Inherited Members ExtensibleObject<IGenerationContext>.Extensions ExtensibleObject<IGenerationContext>.SetExtension(IGenerationContext) ExtensibleObject<IGenerationContext>.GetExtension<T>() ExtensibleObject<IGenerationContext>.TryGetExtension<T>(out T) Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class GenerationContext : ExtensibleObject<IGenerationContext> Constructors GenerationContext(GlobalPosition, GeoCoordinate, GenerationSettings) Instantiates a GenerationContext. Declaration public GenerationContext(GlobalPosition generationOrigin, GeoCoordinate pivot, GenerationSettings settings) Parameters Type Name Description GlobalPosition generationOrigin GeoCoordinate pivot The pivot GeoCoordinate. GenerationSettings settings Fields Bounds The current terrain aligned bounds not respecting the blend margin. Declaration public readonly GlobalBounds Bounds Field Value Type Description GlobalBounds InnerBounds The current terrain aligned bounds respecting the blend margin. Use this for processes that require consistent Map data. Declaration public readonly GlobalBounds InnerBounds Field Value Type Description GlobalBounds Pivot The pivot GeoCoordinate. Declaration public readonly GeoCoordinate Pivot Field Value Type Description GeoCoordinate Settings The Generation Settings. Declaration public readonly GenerationSettings Settings Field Value Type Description GenerationSettings WorkersWithoutResources The set of workers that failed to acquire some of their required resources. Declaration public readonly ISet<IPipelineWorker> WorkersWithoutResources Field Value Type Description ISet<IPipelineWorker> Methods GatherAllResourcesAsync(GenerationSettings, IProgress<float>, CancellationToken) Performs the resource gathering step for all registered IPreprocessingGenerationContext instances registered with this context. Declaration public UniTask GatherAllResourcesAsync(GenerationSettings settings, IProgress<float> onProgressUpdate = null, CancellationToken cancellationToken = default) Parameters Type Name Description GenerationSettings settings Contains immutable data that cannot be changed during the whole generation loop. IProgress<float> onProgressUpdate Called with relative progress in [0, 1]. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask ProcessAllAsync(GenerationSettings, IProgress<float>, CancellationToken) Performs the processing step for all registered IPreprocessingGenerationContext instances registered with this context. Declaration public UniTask ProcessAllAsync(GenerationSettings settings, IProgress<float> onProgressUpdate = null, CancellationToken cancellationToken = default) Parameters Type Name Description GenerationSettings settings Contains immutable data that cannot be changed during the whole generation loop. IProgress<float> onProgressUpdate Called with relative progress in [0, 1]. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask"
  },
  "api/Holoride.ElasticSDK.GenerationSettings.html": {
    "href": "api/Holoride.ElasticSDK.GenerationSettings.html",
    "title": "Class GenerationSettings | ElasticSDK Documentation",
    "keywords": "Class GenerationSettings Contains immutable data that cannot be changed during the whole generation loop. Inheritance object ExtensibleObject<IGenerationSettings> GenerationSettings Inherited Members ExtensibleObject<IGenerationSettings>.Extensions ExtensibleObject<IGenerationSettings>.SetExtension(IGenerationSettings) ExtensibleObject<IGenerationSettings>.GetExtension<T>() ExtensibleObject<IGenerationSettings>.TryGetExtension<T>(out T) Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class GenerationSettings : ExtensibleObject<IGenerationSettings> Constructors GenerationSettings(float, int, float, Transform, float, int, int, bool, int) Instantiates immutable generation settings. Declaration public GenerationSettings(float extents, int filterResolution, float heightOffset, Transform parent, float blendMargin, int disabledCollisionLayer, int gridDivisions = 5, bool ignoreMissingInputs = false, int seed = 1752132719) Parameters Type Name Description float extents The supported extents of the generation process that determines where maps are downloaded, spawn candidates are set and terrain is generated. int filterResolution The resolution of the maps. float heightOffset The height offset all spawners can access to instantiate objects with a shared reference height. Transform parent The parent transform to all generated objects. float blendMargin The blend ratio between overlapping filter iterations. A lower value indicates less blending with harder seams. Therefore earlier processed values will change less after updates leading to fewer popup-effects. int disabledCollisionLayer The collision layer to temporarily disable collisions during the generation process. int gridDivisions The divisions of a terrain to trigger updates. bool ignoreMissingInputs Whether to silently ignore missing inputs or throw exceptions instead. int seed The seed value to use for randomization. Fields BlendMargin The blend ratio between overlapping filter iterations. A lower value indicates less blending with harder seams. Therefore earlier processed values will change less after updates leading to fewer popup-effects. Declaration public readonly float BlendMargin Field Value Type Description float DefaultHeightmapZoomLevel Default zoom level for heightmap data provider. Declaration public const int DefaultHeightmapZoomLevel = 14 Field Value Type Description int DefaultOverpassZoomLevel Default zoom level for overpass data provider. Declaration public const int DefaultOverpassZoomLevel = 13 Field Value Type Description int DisabledCollisionLayer The collision layer to temporarily disable collisions during the generation process. Declaration public readonly int DisabledCollisionLayer Field Value Type Description int Extents The supported extents of the generation process that determines where maps are downloaded, spawn candidates are set and terrain is generated. Declaration public readonly float Extents Field Value Type Description float FilterResolution The resolution of the maps. Declaration public readonly int FilterResolution Field Value Type Description int GridDivisions The resolution of each terrain chunk to trigger updates. Declaration public readonly int GridDivisions Field Value Type Description int HeightOffset The height offset all spawners can access to instantiate objects with a shared reference height. Declaration public readonly float HeightOffset Field Value Type Description float IgnoreMissingInputs States whether workers silently return or throw exceptions in the case of missing inputs. Declaration public readonly bool IgnoreMissingInputs Field Value Type Description bool Parent The parent transform to all generated objects. Declaration public readonly Transform Parent Field Value Type Description Transform Seed Seed used when initializing random number generators. Declaration public readonly int Seed Field Value Type Description int Properties GridResolution Declaration public int GridResolution { get; } Property Value Type Description int Methods GetRandom(GlobalPose, int, int) Declaration public Random GetRandom(GlobalPose pose, int precision = 100, int latOffset = 1000) Parameters Type Name Description GlobalPose pose int precision int latOffset Returns Type Description Random GetRandom(int) Declaration public Random GetRandom(int seed) Parameters Type Name Description int seed Returns Type Description Random GetRandom(Vector2Int) Declaration public Random GetRandom(Vector2Int cell) Parameters Type Name Description Vector2Int cell Returns Type Description Random GetSeedFromPose(GlobalPose, int, int) Declaration public int GetSeedFromPose(GlobalPose pose, int precision = 100, int latOffset = 1000) Parameters Type Name Description GlobalPose pose int precision int latOffset Returns Type Description int"
  },
  "api/Holoride.ElasticSDK.GenerationState.html": {
    "href": "api/Holoride.ElasticSDK.GenerationState.html",
    "title": "Class GenerationState | ElasticSDK Documentation",
    "keywords": "Class GenerationState Contains the current state of the generation process and will be updated over time. Inheritance object ExtensibleObject<IGenerationState> GenerationState Inherited Members ExtensibleObject<IGenerationState>.Extensions ExtensibleObject<IGenerationState>.SetExtension(IGenerationState) ExtensibleObject<IGenerationState>.GetExtension<T>() ExtensibleObject<IGenerationState>.TryGetExtension<T>(out T) Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public sealed class GenerationState : ExtensibleObject<IGenerationState> Methods Dispose() Declaration public void Dispose() GetCachedComputeBufferPyramid(int, int) Declaration public IList<ComputeBuffer> GetCachedComputeBufferPyramid(int baseResolution, int stride = 4) Parameters Type Name Description int baseResolution int stride Returns Type Description IList<ComputeBuffer>"
  },
  "api/Holoride.ElasticSDK.GeoCoordinate.html": {
    "href": "api/Holoride.ElasticSDK.GeoCoordinate.html",
    "title": "Struct GeoCoordinate | ElasticSDK Documentation",
    "keywords": "Struct GeoCoordinate Stores latitude, longitude and altitude of a geo coordinate and performs conversion to cartesian. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [Serializable] public struct GeoCoordinate Constructors GeoCoordinate(GlobalPosition, GeoCoordinate) Initializes a new instance of the GeoCoordinate class from a vector3 unity position and a predefined world pivot. Declaration public GeoCoordinate(GlobalPosition vector, GeoCoordinate pivot) Parameters Type Name Description GlobalPosition vector A double precision vector in Unity coordinates. GeoCoordinate pivot The pivot of the grid containing the specified position. GeoCoordinate(double, double, double) Initializes a new instance of the GeoCoordinate class. Declaration public GeoCoordinate(double latitude, double longitude, double altitude = 0) Parameters Type Name Description double latitude The coordinate's latitude in degrees. double longitude The coordinate's longitude in degrees. double altitude The coordinate's altitude in meters. GeoCoordinate(Vector2, GeoCoordinate) Initializes a new instance of the GeoCoordinate class from a vector2 unity position and a pivot point geoCoordinate. Declaration public GeoCoordinate(Vector2 vector, GeoCoordinate pivot) Parameters Type Name Description Vector2 vector A unity position vector interpreted as NED. GeoCoordinate pivot The pivot point geoCoordinate. GeoCoordinate(Vector3, GeoCoordinate) Initializes a new instance of the GeoCoordinate class from a vector3 unity position and a pivot point geoCoordinate. Declaration public GeoCoordinate(Vector3 vector, GeoCoordinate pivot) Parameters Type Name Description Vector3 vector A unity position vector interpreted as NED. GeoCoordinate pivot The pivot point geoCoordinate. Fields Altitude The coordinate's altitude in meters. Declaration public double Altitude Field Value Type Description double Latitude The coordinate's latitude in degrees. Declaration public double Latitude Field Value Type Description double Longitude The coordinate's longitude in degrees. Declaration public double Longitude Field Value Type Description double MajorEarthRadius The earth radius. Declaration public static double MajorEarthRadius Field Value Type Description double Methods AzimuthTo(GeoCoordinate, GeoCoordinate) Calculates the azimuth, i.e. horizontal angle measured clockwise by degrees between the north and the direction towards the target location starting from the passed start location. Declaration public static double AzimuthTo(GeoCoordinate start, GeoCoordinate target) Parameters Type Name Description GeoCoordinate start The location from which the azimuth will be calculated. GeoCoordinate target The location to which the azimuth will be calculated. Returns Type Description double The angle in degrees between north and the direction towards the passed target as seen from the passed start location. AzimuthTo(GeoCoordinate) Calculates the azimuth, i.e. horizontal angle measured clockwise by degrees between north and the direction towards the target location starting from the this location. Declaration public double AzimuthTo(GeoCoordinate target) Parameters Type Name Description GeoCoordinate target The location to which the azimuth will be calculated. Returns Type Description double The angle in degrees between north and the direction towards the passed target as seen from this location. Equals(GeoCoordinate) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(GeoCoordinate other) Parameters Type Name Description GeoCoordinate other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Determines whether the specified object is equal to the current object. Declaration public override bool Equals(object obj) Parameters Type Name Description object obj The object to compare with the current object. Returns Type Description bool true if the specified object is equal to the current object; otherwise, false. Overrides ValueType.Equals(Object) GetHashCode() Serves as the default hash function. Declaration public override int GetHashCode() Returns Type Description int A hash code for the current object. Overrides ValueType.GetHashCode() HaversineDistance(GeoCoordinate) Returns the shortest distance between two GeoCoordinates on the earth in meters. Declaration public double HaversineDistance(GeoCoordinate to) Parameters Type Name Description GeoCoordinate to The distance of this location to the passed location. Returns Type Description double The shortest distance between the two locations on the earth in meters. LatitudeToYTile(double, int) Calculates the tile coordinate for a given latitude and a zoom level. Declaration public static double LatitudeToYTile(double latitude, int zoom) Parameters Type Name Description double latitude The latitude. int zoom The zoom level. Returns Type Description double The tile value of a latitude. LLHToXYZ(GeoCoordinate) Transforms geoCoordinates to ECEF (WGS84) cartesian coordinates. Declaration public static GlobalPosition LLHToXYZ(GeoCoordinate geoCoordinate) Parameters Type Name Description GeoCoordinate geoCoordinate The geoCoordinate to transform. Returns Type Description GlobalPosition The ECEF (WGS84) cartesian coordinate. LongitudeToXTile(double, int) Calculates the tile coordinate for a given longitude and a zoom level. Declaration public static double LongitudeToXTile(double longitude, int zoom) Parameters Type Name Description double longitude The longitude. int zoom The zoom level. Returns Type Description double The tile value of a longitude. MaximumTileExtents(int) Calculates maximum extents a tile has at a given zoom. Declaration public static double MaximumTileExtents(int zoom) Parameters Type Name Description int zoom The zoom level. Returns Type Description double The maximum tile extents. NEDToXYZ(GlobalPosition, GeoCoordinate) Transforms local ned-coordinates to ECEF (WGS84) cartesian coordinates with a given pivot. See https://en.wikipedia.org/wiki/North_east_down. Declaration public static GlobalPosition NEDToXYZ(GlobalPosition ned, GeoCoordinate pivotLLH) Parameters Type Name Description GlobalPosition ned The nec-coordinates to transform. GeoCoordinate pivotLLH The pivot geoCoordinate. Returns Type Description GlobalPosition The ECEF (WGS84) cartesian coordinate. TileBounds(Vector2Int, int, out double, out double, out double, out double) Computes the outer latitude-longitude-bounds of a tile. Declaration public static void TileBounds(Vector2Int globalTilePosition, int zoom, out double longitudeMin, out double longitudeMax, out double latitudeMin, out double latitudeMax) Parameters Type Name Description Vector2Int globalTilePosition The global tile position. int zoom The zoom level. double longitudeMin The resulting minimum longitude. double longitudeMax The resulting maximum longitude. double latitudeMin The resulting minimum latitude. double latitudeMax The resulting maximum latitude. TileToGeoCoordinate(Vector2Int, int) Calculates the GeoCoordinate for a given global tile position and zoom level. Declaration public static GeoCoordinate TileToGeoCoordinate(Vector2Int globalTilePosition, int zoomLevel) Parameters Type Name Description Vector2Int globalTilePosition The tile position. int zoomLevel The zoom level of the tile position. Returns Type Description GeoCoordinate The GeoCoordinate of the tile position. ToCartesian(GeoCoordinate) Gets the cartesian representation of the coordinate relative to the pivot. Declaration public Vector3 ToCartesian(GeoCoordinate pivot) Parameters Type Name Description GeoCoordinate pivot The pivot point geoCoordinate. Returns Type Description Vector3 The NED cartesian representation of this geoCoordinate. in shifted space. ToCartesian2D(GeoCoordinate) Gets the cartesian representation of the coordinate relative to the pivot as a Vector2D. Declaration public Vector2 ToCartesian2D(GeoCoordinate pivot) Parameters Type Name Description GeoCoordinate pivot The pivot point geoCoordinate. Returns Type Description Vector2 The NED cartesian representation of this geoCoordinate as a Vector2D. ToCartesianDouble(GeoCoordinate) Gets the cartesian representation of the coordinate in world scale. As this representation is not pinned to a pivot, it has to support double precision to make sense. Declaration public readonly GlobalPosition ToCartesianDouble(GeoCoordinate pivot) Parameters Type Name Description GeoCoordinate pivot The pivot point geoCoordinate. Returns Type Description GlobalPosition The NED cartesian representation of this geoCoordinate. ToString() Returns a string that represents the current object. Declaration public override string ToString() Returns Type Description string A string that represents the current object. Overrides ValueType.ToString() ToTileCoord(int) Converts a GeoCoordinate to a float tile position based on a given zoom level. Declaration public Vector2 ToTileCoord(int zoom) Parameters Type Name Description int zoom The zoom level. Returns Type Description Vector2 The tile coordinate as Vector2. Remarks See https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#C.23. ToTilePos(int, out Vector2) Converts a GeoCoordinate to an integer tile position based on a given zoom level. Also writes the exact uv-coordinates of the GeoCoordinate on the tile in an out parameter as Vector2. Declaration public Vector2Int ToTilePos(int zoom, out Vector2 uv) Parameters Type Name Description int zoom The zoom level. Vector2 uv Out parameter for the UV-Coordinates. Returns Type Description Vector2Int The tile position as Vector2Int. Remarks See https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#C.23. ToTilePos(int) Converts a GeoCoordinate to an integer tile position based on a given zoom level. Declaration public Vector2Int ToTilePos(int zoom) Parameters Type Name Description int zoom The zoom level. Returns Type Description Vector2Int The tile position as Vector2Int. Remarks See https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#C.23. XTileToLongitude(int, int) Calculates the longitude for a given tile coordinate and a zoom level. Declaration public static double XTileToLongitude(int xTile, int zoom) Parameters Type Name Description int xTile The tile's x coordinate. int zoom The zoom level. Returns Type Description double The longitude value of a tile. XYZToLLH(GlobalPosition, out GeoCoordinate) Transforms ECEF (WGS84) cartesian coordinates to geoCoordinates. Declaration public static bool XYZToLLH(GlobalPosition position, out GeoCoordinate result) Parameters Type Name Description GlobalPosition position The given ECEF (WGS84) cartesian coordinate. GeoCoordinate result The resulting geo-coordinate. Returns Type Description bool XYZToNED(GlobalPosition, GeoCoordinate) Transforms ECEF (WGS84) cartesian coordinates to local ned-coordinates with a given pivot. See https://en.wikipedia.org/wiki/North_east_down. Declaration public static GlobalPosition XYZToNED(GlobalPosition xyz, GeoCoordinate pivotLLH) Parameters Type Name Description GlobalPosition xyz The ECEF (WGS84) cartesian coordinates to transform. GeoCoordinate pivotLLH The pivot geoCoordinate. Returns Type Description GlobalPosition The ned-coordinates. YTileToLatitude(int, int) Calculates the latitude for a given tile coordinate and a zoom level. Declaration public static double YTileToLatitude(int yTile, int zoom) Parameters Type Name Description int yTile The tile's y coordinate. int zoom The zoom level. Returns Type Description double The latitude of a tile. Operators operator ==(GeoCoordinate, GeoCoordinate) Declaration public static bool operator ==(GeoCoordinate left, GeoCoordinate right) Parameters Type Name Description GeoCoordinate left GeoCoordinate right Returns Type Description bool operator !=(GeoCoordinate, GeoCoordinate) Declaration public static bool operator !=(GeoCoordinate left, GeoCoordinate right) Parameters Type Name Description GeoCoordinate left GeoCoordinate right Returns Type Description bool"
  },
  "api/Holoride.ElasticSDK.GlobalBounds.html": {
    "href": "api/Holoride.ElasticSDK.GlobalBounds.html",
    "title": "Struct GlobalBounds | ElasticSDK Documentation",
    "keywords": "Struct GlobalBounds Creates min and max latitude and longitude to define an area. Mind that this area is not a square or a rectangle on the earth surface. However, smaller areas which are closer to the equator approximate a rectangular shape. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [Serializable] public struct GlobalBounds Constructors GlobalBounds(double, double, double, double) Initializes a new instance of the GlobalBounds class. Declaration public GlobalBounds(double xMin, double zMin, double xMax, double zMax) Parameters Type Name Description double xMin The minimum X value. double zMin The minimum Z value. double xMax The maximum X value. double zMax The maximum Z value. Fields Empty Represents empty bounds (with max value being smaller than min values). Declaration public static readonly GlobalBounds Empty Field Value Type Description GlobalBounds XMax The coordinate's maximum x-value. Declaration public double XMax Field Value Type Description double XMin The coordinate's minimum x-value. Declaration public double XMin Field Value Type Description double ZMax The coordinate's maximum z-value. Declaration public double ZMax Field Value Type Description double ZMin The coordinate's minimum z-value. Declaration public double ZMin Field Value Type Description double Properties Center Gets the Vector3Double of the center of an area defined by GeoBounds. Declaration public GlobalPosition Center { get; } Property Value Type Description GlobalPosition Extents Gets the extents of the bounds. Declaration public readonly Vector2 Extents { get; } Property Value Type Description Vector2 Radius Gets the distance from the center of the square grid area to any one of its four edges. Declaration public float Radius { get; } Property Value Type Description float SquareExtents Gets the extents as the edge length of the outermost square with the same center as the bounds. Declaration public float SquareExtents { get; } Property Value Type Description float Methods Clamp(GlobalPosition) Clamps a vector representing a position along the X and Z axes to lie within the bounds. Declaration public readonly GlobalPosition Clamp(GlobalPosition value) Parameters Type Name Description GlobalPosition value The position to clamp to within the bounds. Returns Type Description GlobalPosition A vector representing the clamped position. Clamp(ref double, ref double) Clamps a position represented by the specified X and Y coordinates to lie within the bounds. Declaration public readonly void Clamp(ref double x, ref double z) Parameters Type Name Description double x The X coordinate to clamp in-place. double z The Z coordinate to clamp in-place. ClipLine(GlobalPosition, GlobalPosition, List<GlobalPosition>) Clips a line from P0 = (x0, y0) to P1 = (x1, y1) against a rectangle with diagonal from (xmin, ymin) to (xmax, ymax). Declaration public int ClipLine(GlobalPosition p0, GlobalPosition p1, List<GlobalPosition> result) Parameters Type Name Description GlobalPosition p0 The start position of the line. GlobalPosition p1 The end position of the line. List<GlobalPosition> result A list to be cleared and filled with two clipping points if the line intersects the rectangle. Returns Type Description int The number of returned points in the result list which is either 0 or 2. ComputeOuterGeoBounds(GeoCoordinate, out double, out double, out double, out double) Computes the outer corners of geo bounds. Declaration [Pure] public void ComputeOuterGeoBounds(GeoCoordinate pivot, out double minLatitude, out double maxLatitude, out double minLongitude, out double maxLongitude) Parameters Type Name Description GeoCoordinate pivot The pivot. double minLatitude Min Latitude output. double maxLatitude Max Latitude output. double minLongitude Min Longitude output. double maxLongitude Max Longitude output. Contains(GlobalPosition) States whether the given position is within these bounds. Declaration public readonly bool Contains(GlobalPosition position) Parameters Type Name Description GlobalPosition position The position to check. Returns Type Description bool Whether the given position lay within these bounds. Contains(double, double, GeoCoordinate) States whether the given coordinate is within these bounds. Declaration public bool Contains(double latitude, double longitude, GeoCoordinate pivot) Parameters Type Name Description double latitude The latitude to locate. double longitude The longitude to locate. GeoCoordinate pivot The pivot. Returns Type Description bool Whether the given coordinate lay within these bounds. Create(GeoCoordinate, params GeoCoordinate[]) Initializes a new instance of the GlobalBounds class. Declaration public static GlobalBounds Create(GeoCoordinate pivot, params GeoCoordinate[] coordinates) Parameters Type Name Description GeoCoordinate pivot The pivot. GeoCoordinate[] coordinates A list of geo coordinates to wrap. Returns Type Description GlobalBounds Create(GeoCoordinate, int, Vector2Int) Initializes a new instance of the GlobalBounds class for a tile. Declaration public static GlobalBounds Create(GeoCoordinate pivot, int zoomLevel, Vector2Int tilePosition) Parameters Type Name Description GeoCoordinate pivot The pivot. int zoomLevel The tile zoom level. Vector2Int tilePosition The tile position. Returns Type Description GlobalBounds Create(GlobalPosition, float) Initializes a new instance of the GlobalBounds class. Declaration public static GlobalBounds Create(GlobalPosition center, float extents) Parameters Type Name Description GlobalPosition center The bounds' center. float extents The bounds' extend. Returns Type Description GlobalBounds Create(params GlobalPosition[]) Initializes a new instance of the GlobalBounds class. Declaration public static GlobalBounds Create(params GlobalPosition[] positions) Parameters Type Name Description GlobalPosition[] positions A list of positions to wrap. Returns Type Description GlobalBounds Create(IEnumerable<GlobalPosition>) Initializes a new instance of the GlobalBounds class. Declaration public static GlobalBounds Create(IEnumerable<GlobalPosition> positions) Parameters Type Name Description IEnumerable<GlobalPosition> positions A list of positions to wrap. Returns Type Description GlobalBounds Create(Vector2, float, GlobalPosition) Initializes a new instance of the GlobalBounds class. Declaration public static GlobalBounds Create(Vector2 center, float squareExtents, GlobalPosition offset) Parameters Type Name Description Vector2 center The bounds' center. float squareExtents The bounds' square extents. GlobalPosition offset The offset in double precision. Returns Type Description GlobalBounds DoublePositionAtUV(Vector2) Locates the position of a given uv within the bounds. Declaration public GlobalPosition DoublePositionAtUV(Vector2 uv) Parameters Type Name Description Vector2 uv The position. Returns Type Description GlobalPosition The position at the given uv. Equals(GlobalBounds) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(GlobalBounds other) Parameters Type Name Description GlobalBounds other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Determines whether the specified object is equal to the current object. Declaration public override bool Equals(object obj) Parameters Type Name Description object obj The object to compare with the current object. Returns Type Description bool true if the specified object is equal to the current object; otherwise, false. Overrides ValueType.Equals(Object) GeoCoordinateAtUV(Vector2, GeoCoordinate) Locates the position of a given uv within the bounds. Declaration public GeoCoordinate GeoCoordinateAtUV(Vector2 uv, GeoCoordinate pivot) Parameters Type Name Description Vector2 uv The position. GeoCoordinate pivot The pivot. Returns Type Description GeoCoordinate The geo coordinate at the given uv. GetHashCode() Serves as the default hash function. Declaration public override int GetHashCode() Returns Type Description int A hash code for the current object. Overrides ValueType.GetHashCode() GetRandomPoint(Random) Returns a random point lying inside this bounding rectangle. Declaration public GlobalPosition GetRandomPoint(Random random) Parameters Type Name Description Random random The random number generator to use. Returns Type Description GlobalPosition A random point in this bounding rectangle. Grow(double, double) Grows the bounds along the X and the Z axis by the specified amounts. Declaration public readonly GlobalBounds Grow(double amountX, double amountZ) Parameters Type Name Description double amountX The amount by which to grow the bounds along the X axis. double amountZ The amount by which to grow the bounds along the Z axis. Returns Type Description GlobalBounds The bounds grown by the specified amounts. Grow(double) Grows the bounds along the X and the Z axis by the specified amount. Declaration public readonly GlobalBounds Grow(double amount) Parameters Type Name Description double amount The amount by which to grow the bounds. Returns Type Description GlobalBounds The bounds grown by the specified amount. Overlaps(GlobalBounds) States whether the given bounds overlaps with these bounds. Declaration public bool Overlaps(GlobalBounds other) Parameters Type Name Description GlobalBounds other The bounds to check. Returns Type Description bool Whether the given bounds overlap with these bounds. ToString() Returns a string that represents the current object. Declaration public override string ToString() Returns Type Description string A string that represents the current object. Overrides ValueType.ToString() UVAtDoublePose(GlobalPose) Locates the uv of a given pose position within the bounds. Declaration public Vector2 UVAtDoublePose(GlobalPose pose) Parameters Type Name Description GlobalPose pose The pose. Returns Type Description Vector2 The uv of a given pose position. UVAtDoublePosition(GlobalPosition) Locates the uv of a given position within the bounds. Declaration [Pure] public Vector2 UVAtDoublePosition(GlobalPosition position) Parameters Type Name Description GlobalPosition position The position. Returns Type Description Vector2 The uv of a given position. UVAtGeoCoordinate(GeoCoordinate, GeoCoordinate) Locates the uv of a given coordinate within the bounds. Declaration public Vector2 UVAtGeoCoordinate(GeoCoordinate coordinate, GeoCoordinate pivot) Parameters Type Name Description GeoCoordinate coordinate The coordinate to locate. GeoCoordinate pivot The pivot. Returns Type Description Vector2 The uv of a given coordinate. Operators operator ==(GlobalBounds, GlobalBounds) Declaration public static bool operator ==(GlobalBounds left, GlobalBounds right) Parameters Type Name Description GlobalBounds left GlobalBounds right Returns Type Description bool operator !=(GlobalBounds, GlobalBounds) Declaration public static bool operator !=(GlobalBounds left, GlobalBounds right) Parameters Type Name Description GlobalBounds left GlobalBounds right Returns Type Description bool"
  },
  "api/Holoride.ElasticSDK.GlobalPose.html": {
    "href": "api/Holoride.ElasticSDK.GlobalPose.html",
    "title": "Struct GlobalPose | ElasticSDK Documentation",
    "keywords": "Struct GlobalPose Stores a position with double precision and a look rotation. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [Serializable] public struct GlobalPose Constructors GlobalPose(GlobalPosition, Quaternion) Creates a new double precision pose from the specified position and rotation. Declaration public GlobalPose(GlobalPosition position, Quaternion rotation) Parameters Type Name Description GlobalPosition position The position of the pose. Quaternion rotation The rotation of the pose. Fields Position The position. Declaration public GlobalPosition Position Field Value Type Description GlobalPosition Rotation The rotation. Declaration public Quaternion Rotation Field Value Type Description Quaternion Methods Create(GlobalPosition, Quaternion) Creates a new double precision pose from the specified position and rotation. Declaration public static GlobalPose Create(GlobalPosition position, Quaternion rotation) Parameters Type Name Description GlobalPosition position The position of the pose. Quaternion rotation The rotation of the pose. Returns Type Description GlobalPose A pose with the specified position and rotation. Equals(GlobalPose) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(GlobalPose other) Parameters Type Name Description GlobalPose other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Determines whether the specified object is equal to the current object. Declaration public override bool Equals(object obj) Parameters Type Name Description object obj The object to compare with the current object. Returns Type Description bool true if the specified object is equal to the current object; otherwise, false. Overrides ValueType.Equals(Object) GetHashCode() Serves as the default hash function. Declaration public override int GetHashCode() Returns Type Description int A hash code for the current object. Overrides ValueType.GetHashCode() ToShiftedPose() Shifts the double precision pose into single precision shifted space using the global shift offset. Declaration public Pose ToShiftedPose() Returns Type Description Pose The floating point precision pose in un-shifted space. ToString() Returns a string that represents the current object. Declaration public override string ToString() Returns Type Description string A string that represents the current object. Overrides ValueType.ToString() Operators operator ==(GlobalPose, GlobalPose) Declaration public static bool operator ==(GlobalPose left, GlobalPose right) Parameters Type Name Description GlobalPose left GlobalPose right Returns Type Description bool operator !=(GlobalPose, GlobalPose) Declaration public static bool operator !=(GlobalPose left, GlobalPose right) Parameters Type Name Description GlobalPose left GlobalPose right Returns Type Description bool"
  },
  "api/Holoride.ElasticSDK.GlobalPosition.html": {
    "href": "api/Holoride.ElasticSDK.GlobalPosition.html",
    "title": "Struct GlobalPosition | ElasticSDK Documentation",
    "keywords": "Struct GlobalPosition A vector3 representation that supports double precision. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [Serializable] public struct GlobalPosition Constructors GlobalPosition(double, double, double, GlobalPosition) Creates a new three dimensional double vector from the specified components, shifted by the specified shift offset. Declaration public GlobalPosition(double x, double y, double z, GlobalPosition offset) Parameters Type Name Description double x The x component of the vector. double y The y component of the vector. double z The z component of the vector. GlobalPosition offset The shift offset to apply in the conversion. GlobalPosition(double, double, double) Initializes a new instance of the GlobalPosition class. Declaration public GlobalPosition(double x, double y, double z) Parameters Type Name Description double x The x-value. double y The y-value. double z The z-value. GlobalPosition(Vector3, GlobalPosition) Creates a new three dimensional double vector from the specified float vector, shifted by the specified shift offset. Declaration public GlobalPosition(Vector3 value, GlobalPosition offset) Parameters Type Name Description Vector3 value The vector to convert to a double vector. GlobalPosition offset The shift offset to apply in the conversion. GlobalPosition(Vector3) Creates a new three dimensional double vector from the specified float vector. Declaration public GlobalPosition(Vector3 value) Parameters Type Name Description Vector3 value The vector to convert to a double vector. Fields ShiftOffset The shift offset. Declaration public static GlobalPosition ShiftOffset Field Value Type Description GlobalPosition X The x-value. Declaration public double X Field Value Type Description double Y The y-value. Declaration public double Y Field Value Type Description double Z The z-value. Declaration public double Z Field Value Type Description double Zero The zero vector. Declaration public static readonly GlobalPosition Zero Field Value Type Description GlobalPosition Properties Length Gets the length. Declaration public double Length { get; } Property Value Type Description double SquaredLength Gets the squared length. Declaration public double SquaredLength { get; } Property Value Type Description double Methods Create(double, double, double) Creates a new three dimensional double vector from the specified components. Declaration public static GlobalPosition Create(double x, double y, double z) Parameters Type Name Description double x The x component of the vector. double y The y component of the vector. double z The z component of the vector. Returns Type Description GlobalPosition A new double vector. Create(Vector3) Creates a new three dimensional double vector from the specified float vector. Declaration public static GlobalPosition Create(Vector3 value) Parameters Type Name Description Vector3 value The vector to convert to a double vector. Returns Type Description GlobalPosition A new double vector. DeltaAsVector2XZ(GlobalPosition, GlobalPosition) Computes the delta vector between two vectors and returns the resulting X and Z components in float precision. Declaration public static Vector2 DeltaAsVector2XZ(GlobalPosition a, GlobalPosition b) Parameters Type Name Description GlobalPosition a The minuend. GlobalPosition b The subtrahend. Returns Type Description Vector2 The difference. DeltaAsVector3(GlobalPosition, GlobalPosition) Computes the delta vector between two vectors and returns the result in float precision. Declaration public static Vector3 DeltaAsVector3(GlobalPosition a, GlobalPosition b) Parameters Type Name Description GlobalPosition a The minuend. GlobalPosition b The subtrahend. Returns Type Description Vector3 The difference. Direction(GlobalPosition, GlobalPosition) Computes the direction. Declaration public static Vector3 Direction(GlobalPosition a, GlobalPosition b) Parameters Type Name Description GlobalPosition a The first vector. GlobalPosition b The second vector. Returns Type Description Vector3 The direction vector with a length of 1. Distance(GlobalPosition, GlobalPosition) Computes the distance between two vectors. Declaration public static double Distance(GlobalPosition a, GlobalPosition b) Parameters Type Name Description GlobalPosition a The first position. GlobalPosition b The second position. Returns Type Description double The distance. Dot(GlobalPosition, GlobalPosition) The dot product of two Vector3Double. Declaration public static double Dot(GlobalPosition lhs, GlobalPosition rhs) Parameters Type Name Description GlobalPosition lhs Left hand side vector. GlobalPosition rhs Right hand side vector. Returns Type Description double The dot product. Equals(GlobalPosition) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(GlobalPosition other) Parameters Type Name Description GlobalPosition other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Determines whether the specified object is equal to the current object. Declaration public override bool Equals(object obj) Parameters Type Name Description object obj The object to compare with the current object. Returns Type Description bool true if the specified object is equal to the current object; otherwise, false. Overrides ValueType.Equals(Object) FromShifted(double, double, double, GlobalPosition) Creates a new three dimensional double vector from the specified components, from shifted space defined by the specified shift offset. Declaration public static GlobalPosition FromShifted(double x, double y, double z, GlobalPosition offset) Parameters Type Name Description double x The x component of the vector. double y The y component of the vector. double z The z component of the vector. GlobalPosition offset The shift offset to apply in the conversion. Returns Type Description GlobalPosition A new un-shifted double vector. FromShifted(double, double, double) Creates a new three dimensional double vector from the specified components, from shifted space defined by the global shift offset. Declaration public static GlobalPosition FromShifted(double x, double y, double z) Parameters Type Name Description double x The x component of the vector. double y The y component of the vector. double z The z component of the vector. Returns Type Description GlobalPosition A new un-shifted double vector. FromShifted(Vector3, GlobalPosition) Creates a new three dimensional double vector from the specified float vector, from shifted space defined by the specified shift offset. Declaration public static GlobalPosition FromShifted(Vector3 value, GlobalPosition offset) Parameters Type Name Description Vector3 value The vector to convert to a double vector. GlobalPosition offset The shift offset to apply in the conversion. Returns Type Description GlobalPosition A new un-shifted double vector. FromShifted(Vector3) Creates a new three dimensional double vector from the specified float vector, from shifted space defined by the global shift offset. Declaration public static GlobalPosition FromShifted(Vector3 value) Parameters Type Name Description Vector3 value The vector to convert to a double vector. Returns Type Description GlobalPosition A new un-shifted double vector. GetHashCode() Serves as the default hash function. Declaration public override int GetHashCode() Returns Type Description int A hash code for the current object. Overrides ValueType.GetHashCode() Lerp(GlobalPosition, GlobalPosition, double) Lerps between two Vector3Doubles. Declaration public static GlobalPosition Lerp(GlobalPosition a, GlobalPosition b, double t) Parameters Type Name Description GlobalPosition a The first vector. GlobalPosition b The second vector. double t The lerp ratio. Returns Type Description GlobalPosition The lerped Vector3Double. SqrDistance(GlobalPosition, GlobalPosition) Computes the squared distance between two vectors. Squared distances are faster to compute than distances while still providing comparability. Declaration public static double SqrDistance(GlobalPosition a, GlobalPosition b) Parameters Type Name Description GlobalPosition a The first position. GlobalPosition b The second position. Returns Type Description double The squared distance. ToShiftedVector2XZ() Converts this double precision vector to single point precision shifted space using the global shift offset. Declaration public Vector2 ToShiftedVector2XZ() Returns Type Description Vector2 The shifted floating point precision vector. ToShiftedVector3() Converts this double precision vector to single point precision shifted space using the global shift offset. Declaration public Vector3 ToShiftedVector3() Returns Type Description Vector3 The shifted floating point precision vector. ToString() Returns a string that represents the current object. Declaration public override string ToString() Returns Type Description string A string that represents the current object. Overrides ValueType.ToString() ToYMinusZX() Converts the vector components. x -> y y -> -z z -> x Declaration public GlobalPosition ToYMinusZX() Returns Type Description GlobalPosition The converted vector. ToZXMinusY() Converts the vector components. x -> z y -> x z -> -y Declaration public GlobalPosition ToZXMinusY() Returns Type Description GlobalPosition The converted vector. Operators operator +(GlobalPosition, GlobalPosition) Adds two Vector3Doubles. Declaration public static GlobalPosition operator +(GlobalPosition a, GlobalPosition b) Parameters Type Name Description GlobalPosition a The first vector. GlobalPosition b The second vector. Returns Type Description GlobalPosition The sum of a and b. operator +(GlobalPosition, Vector3) Adds a Vector3 to a Vector3Double. Declaration public static GlobalPosition operator +(GlobalPosition a, Vector3 b) Parameters Type Name Description GlobalPosition a The first vector as Vector3Double. Vector3 b The second vector as Vector3. Returns Type Description GlobalPosition The sum of a and b. operator /(GlobalPosition, double) Scales a vector by a divisor. Declaration public static GlobalPosition operator /(GlobalPosition v, double divisor) Parameters Type Name Description GlobalPosition v The vector to scale. double divisor The scale divisor. Returns Type Description GlobalPosition The scaled vector. operator ==(GlobalPosition, GlobalPosition) Declaration public static bool operator ==(GlobalPosition left, GlobalPosition right) Parameters Type Name Description GlobalPosition left GlobalPosition right Returns Type Description bool operator !=(GlobalPosition, GlobalPosition) Declaration public static bool operator !=(GlobalPosition left, GlobalPosition right) Parameters Type Name Description GlobalPosition left GlobalPosition right Returns Type Description bool operator *(GlobalPosition, GlobalPosition) Multiplies two Vector3Doubles. Declaration public static GlobalPosition operator *(GlobalPosition a, GlobalPosition b) Parameters Type Name Description GlobalPosition a The first vector. GlobalPosition b The second vector. Returns Type Description GlobalPosition The product of a multiplied by b. operator *(GlobalPosition, double) Scales a vector by a factor. Declaration public static GlobalPosition operator *(GlobalPosition v, double factor) Parameters Type Name Description GlobalPosition v The vector to scale. double factor The scale factor. Returns Type Description GlobalPosition The scaled vector. operator -(GlobalPosition, GlobalPosition) Subtracts two Vector3Doubles. Declaration public static GlobalPosition operator -(GlobalPosition a, GlobalPosition b) Parameters Type Name Description GlobalPosition a The first vector. GlobalPosition b The second vector. Returns Type Description GlobalPosition The subtraction of a minus b."
  },
  "api/Holoride.ElasticSDK.GlobalSettings.html": {
    "href": "api/Holoride.ElasticSDK.GlobalSettings.html",
    "title": "Class GlobalSettings | ElasticSDK Documentation",
    "keywords": "Class GlobalSettings Contains globally accessible values. Inheritance object Object ScriptableObject SingletonBase Singleton<GlobalSettings> GlobalSettings Inherited Members Singleton<GlobalSettings>.Instance SingletonBase.SingletonOnDisable() Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [HelpURL(\"http://localhost:8080/api/Holoride.ElasticSDK.GlobalSettings.html\")] public sealed class GlobalSettings : Singleton<GlobalSettings> Fields MaximumSupportedLatitude The maximum supported latitude between 0 and 90 degrees. Declaration public const double MaximumSupportedLatitude = 74 Field Value Type Description double MaxWorkersByGroup The maximum number of OSM nodes that are allowed in a single graph. Declaration public static readonly Dictionary<string, int> MaxWorkersByGroup Field Value Type Description Dictionary<string, int> Properties ApplyPrefabRootTransform Gets a value indicating whether spawned objects should apply the root rotation and position. The scale is applied either way. Declaration public static bool ApplyPrefabRootTransform { get; } Property Value Type Description bool DefaultLaneCount Gets the default lane count if not provided by the map service. Declaration public static int DefaultLaneCount { get; } Property Value Type Description int DeviceTrackingReference Gets the tracking reference of the device. Usually, visual tracking is relative to the Vehicle, while IMU- and Magnetometer-based tracking is relative to the World. Declaration public static GlobalSettings.TrackingReference DeviceTrackingReference { get; } Property Value Type Description GlobalSettings.TrackingReference EnableVerboseLogging Gets or sets a value indicating whether to enable verbose logging. Declaration public static bool EnableVerboseLogging { get; set; } Property Value Type Description bool LaneWidth Gets the default lane width. Declaration public static float LaneWidth { get; } Property Value Type Description float LogDownloadURLs Gets or sets a value indicating whether to log download URLs for map data providers and such. Declaration [Obsolete(\"Use EnableVerboseLogging\")] public static bool LogDownloadURLs { get; set; } Property Value Type Description bool LogNodeTimings Gets or sets a value indicating whether to log all node timings. Declaration [Obsolete(\"Use EnableVerboseLogging\")] public static bool LogNodeTimings { get; set; } Property Value Type Description bool LogToFile Gets or sets a value indicating whether to log into a file located in the [PersistentDataPath] /Holoride/Logs/. Declaration public static bool LogToFile { get; set; } Property Value Type Description bool Manifest Gets the signed manifest for this project. Declaration public static string Manifest { get; } Property Value Type Description string RoadSideWidth Gets the default width added on both sides of each road. Declaration public static float RoadSideWidth { get; } Property Value Type Description float Methods SingletonOnCreate() Declaration protected override void SingletonOnCreate() Overrides SingletonBase.SingletonOnCreate() SingletonOnEnable() Declaration protected override void SingletonOnEnable() Overrides SingletonBase.SingletonOnEnable()"
  },
  "api/Holoride.ElasticSDK.GlobalSettings.TrackingReference.html": {
    "href": "api/Holoride.ElasticSDK.GlobalSettings.TrackingReference.html",
    "title": "Enum GlobalSettings.TrackingReference | ElasticSDK Documentation",
    "keywords": "Enum GlobalSettings.TrackingReference Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public enum GlobalSettings.TrackingReference Fields Name Description Vehicle World"
  },
  "api/Holoride.ElasticSDK.Graph.DataProviders.DataProviderNode-1.DataProviderNodeWorker-1.html": {
    "href": "api/Holoride.ElasticSDK.Graph.DataProviders.DataProviderNode-1.DataProviderNodeWorker-1.html",
    "title": "Class DataProviderNode<TDataType>.DataProviderNodeWorker<T> | ElasticSDK Documentation",
    "keywords": "Class DataProviderNode<TDataType>.DataProviderNodeWorker<T> The worker with a back reference to the node. Represents the result of the different evaluations of ProviderDataBase<TDataType> structs. Inheritance object PipelineWorkerBase DataProviderWorker<TDataType> DataProviderNode<TDataType>.DataProviderNodeWorker<T> Implements IPipelineWorker Inherited Members PipelineWorkerBase.GenerationSettings PipelineWorkerBase.GenerationState PipelineWorkerBase.CurrentGenerationContext PipelineWorkerBase.Pipeline PipelineWorkerBase.IsGatheringResources PipelineWorkerBase.IsProcessing PipelineWorkerBase.Inputs PipelineWorkerBase.MissingMandatoryInputs PipelineWorkerBase.AddMissingMandatoryInput(string) PipelineWorkerBase.HasMissingMandatoryInputInHierarchy PipelineWorkerBase.AddInput(string, IPipelineWorker) PipelineWorkerBase.GetInput(string) PipelineWorkerBase.GetInput<T>(string) PipelineWorkerBase.InitResources() PipelineWorkerBase.CallInitResources() PipelineWorkerBase.Init() PipelineWorkerBase.CallInit() PipelineWorkerBase.GatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.CallGatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.ProcessAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.CallProcessAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.Dispose() PipelineWorkerBase.CleanUp() PipelineWorkerBase.CallCleanUp() Namespace: Holoride.ElasticSDK.Graph.DataProviders Assembly: Holoride.ElasticSDK.Runtime.dll Syntax protected abstract class DataProviderNode<TDataType>.DataProviderNodeWorker<T> : DataProviderWorker<TDataType>, IPipelineWorker where T : DataProviderNode<TDataType> Type Parameters Name Description T The generating node type deriving from DataProviderWorker<TDataType>. Constructors DataProviderNodeWorker(T) Instantiates the worker. Declaration protected DataProviderNodeWorker(T node) Parameters Type Name Description T node A back reference to the node that created this worker. Fields Node A reference to the node that generated this worker in order to access its serialized data. Declaration protected readonly T Node Field Value Type Description T Properties ProviderData Gets the provided data in a whole without the need to evaluate it. Declaration public override IEnumerable<TDataType> ProviderData { get; } Property Value Type Description IEnumerable<TDataType> Overrides Holoride.ElasticSDK.DataProviderWorker<TDataType>.ProviderData Implements IPipelineWorker"
  },
  "api/Holoride.ElasticSDK.Graph.DataProviders.DataProviderNode-1.html": {
    "href": "api/Holoride.ElasticSDK.Graph.DataProviders.DataProviderNode-1.html",
    "title": "Class DataProviderNode<TDataType> | ElasticSDK Documentation",
    "keywords": "Class DataProviderNode<TDataType> A node that generates a worker that can be added to the pipeline. Inheritance object Object ScriptableObject XNode.Node Node Node<DataProviderNode<TDataType>> DataProviderNode<TDataType> PrefabSelectorNode Implements IPipelineNode Inherited Members Node<DataProviderNode<TDataType>>.Output Node<DataProviderNode<TDataType>>.GetValue(NodePort) Node.Awake() Node.IsPortOptional(NodePort) Node.GetNodeCategoryType() Node.XNodePrettyName(Type) Node.TraverseSubGraph() Node.CallRecursive(Action<Node>, ISet<Node>) Node.ForEachOutput<T>(Action<T>) Node.GetInputSourcePorts(string) Node.GetOutputSinkPorts(string) Namespace: Holoride.ElasticSDK.Graph.DataProviders Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [Serializable] [DefaultNodeColor(\"#FFBF4A\")] public abstract class DataProviderNode<TDataType> : Node<DataProviderNode<TDataType>>, IPipelineNode Type Parameters Name Description TDataType Properties ProviderData Gets the provided data in a whole without the need to evaluate it. Mainly used for editor purposes. Declaration public abstract IEnumerable<TDataType> ProviderData { get; } Property Value Type Description IEnumerable<TDataType> Methods GeneratePipelineWorker() Declaration public abstract IPipelineWorker GeneratePipelineWorker() Returns Type Description IPipelineWorker Implements IPipelineNode"
  },
  "api/Holoride.ElasticSDK.Graph.DataProviders.html": {
    "href": "api/Holoride.ElasticSDK.Graph.DataProviders.html",
    "title": "Namespace Holoride.ElasticSDK.Graph.DataProviders | ElasticSDK Documentation",
    "keywords": "Namespace Holoride.ElasticSDK.Graph.DataProviders Classes DataProviderNode<TDataType> A node that generates a worker that can be added to the pipeline. DataProviderNode<TDataType>.DataProviderNodeWorker<T> The worker with a back reference to the node. Represents the result of the different evaluations of ProviderDataBase<TDataType> structs. MapAndFloatWeightedPrefabData PrefabSelectorNode Node that provides a list of prefabs to spawn from. ProviderDataBase<TDataType> Interfaces IPrefabProviderEvaluationHandler"
  },
  "api/Holoride.ElasticSDK.Graph.DataProviders.IPrefabProviderEvaluationHandler.html": {
    "href": "api/Holoride.ElasticSDK.Graph.DataProviders.IPrefabProviderEvaluationHandler.html",
    "title": "Interface IPrefabProviderEvaluationHandler | ElasticSDK Documentation",
    "keywords": "Interface IPrefabProviderEvaluationHandler Namespace: Holoride.ElasticSDK.Graph.DataProviders Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public interface IPrefabProviderEvaluationHandler Methods EvaluateData(int, GlobalPosition, CancellationToken) Evaluates the collection of data that this worker processes, so that it can return one specific data point. Declaration UniTask<GameObject> EvaluateData(int seed, GlobalPosition spawnCandidatePosition = default, CancellationToken cancellationToken = default) Parameters Type Name Description int seed A seed needed for a deterministic evaluation process. GlobalPosition spawnCandidatePosition The spawn candidates global position that is used to derive an optional map input for evaluation. CancellationToken cancellationToken Token to cancel the async UniTask operation. Returns Type Description Cysharp.Threading.Tasks.UniTask<T><GameObject> The specific data point as a result of the evaluation process."
  },
  "api/Holoride.ElasticSDK.Graph.DataProviders.MapAndFloatWeightedPrefabData.html": {
    "href": "api/Holoride.ElasticSDK.Graph.DataProviders.MapAndFloatWeightedPrefabData.html",
    "title": "Class MapAndFloatWeightedPrefabData | ElasticSDK Documentation",
    "keywords": "Class MapAndFloatWeightedPrefabData Inheritance object ProviderDataBase<GameObject> MapAndFloatWeightedPrefabData Inherited Members ProviderDataBase<GameObject>.data ProviderDataBase<GameObject>.Data Namespace: Holoride.ElasticSDK.Graph.DataProviders Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [Serializable] public class MapAndFloatWeightedPrefabData : ProviderDataBase<GameObject> Constructors MapAndFloatWeightedPrefabData(GameObject, float, string) Declaration public MapAndFloatWeightedPrefabData(GameObject data, float weight, string portName) Parameters Type Name Description GameObject data float weight string portName Properties PortName Declaration public string PortName { get; set; } Property Value Type Description string Weight Declaration public float Weight { get; } Property Value Type Description float"
  },
  "api/Holoride.ElasticSDK.Graph.DataProviders.PrefabSelectorNode.html": {
    "href": "api/Holoride.ElasticSDK.Graph.DataProviders.PrefabSelectorNode.html",
    "title": "Class PrefabSelectorNode | ElasticSDK Documentation",
    "keywords": "Class PrefabSelectorNode Node that provides a list of prefabs to spawn from. Inheritance object Object ScriptableObject XNode.Node Node Node<DataProviderNode<GameObject>> DataProviderNode<GameObject> PrefabSelectorNode Implements IPipelineNode Inherited Members Node<DataProviderNode<GameObject>>.Output Node<DataProviderNode<GameObject>>.GetValue(NodePort) Node.Awake() Node.GetNodeCategoryType() Node.XNodePrettyName(Type) Node.TraverseSubGraph() Node.CallRecursive(Action<Node>, ISet<Node>) Node.ForEachOutput<T>(Action<T>) Node.GetInputSourcePorts(string) Node.GetOutputSinkPorts(string) Namespace: Holoride.ElasticSDK.Graph.DataProviders Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [NodePath(new string[] { \"Data Provider\", \"PrefabSelectorNode\" })] public class PrefabSelectorNode : DataProviderNode<GameObject>, IPipelineNode Properties ProviderData Gets the provided data in a whole without the need to evaluate it. Mainly used for editor purposes. Declaration public override IEnumerable<GameObject> ProviderData { get; } Property Value Type Description IEnumerable<GameObject> Overrides Holoride.ElasticSDK.Graph.DataProviders.DataProviderNode<UnityEngine.GameObject>.ProviderData Methods GeneratePipelineWorker() Declaration public override IPipelineWorker GeneratePipelineWorker() Returns Type Description IPipelineWorker Overrides Holoride.ElasticSDK.Graph.DataProviders.DataProviderNode<UnityEngine.GameObject>.GeneratePipelineWorker() IsPortOptional(NodePort) Declaration public override bool IsPortOptional(NodePort port) Parameters Type Name Description XNode.NodePort port Returns Type Description bool Overrides Node.IsPortOptional(NodePort) Implements IPipelineNode"
  },
  "api/Holoride.ElasticSDK.Graph.DataProviders.ProviderDataBase-1.html": {
    "href": "api/Holoride.ElasticSDK.Graph.DataProviders.ProviderDataBase-1.html",
    "title": "Class ProviderDataBase<TDataType> | ElasticSDK Documentation",
    "keywords": "Class ProviderDataBase<TDataType> Inheritance object ProviderDataBase<TDataType> MapAndFloatWeightedPrefabData Namespace: Holoride.ElasticSDK.Graph.DataProviders Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [Serializable] public abstract class ProviderDataBase<TDataType> Type Parameters Name Description TDataType Fields data Declaration [SerializeField] [Tooltip(\"The data of the element that is provided to the graph.\")] protected TDataType data Field Value Type Description TDataType Properties Data Declaration public virtual TDataType Data { get; } Property Value Type Description TDataType"
  },
  "api/Holoride.ElasticSDK.Graph.DefaultNodeColorAttribute.html": {
    "href": "api/Holoride.ElasticSDK.Graph.DefaultNodeColorAttribute.html",
    "title": "Class DefaultNodeColorAttribute | ElasticSDK Documentation",
    "keywords": "Class DefaultNodeColorAttribute Attribute that may be used to specify the default color tint for a not type and its sub-types. Inheritance object Attribute DefaultNodeColorAttribute Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public class DefaultNodeColorAttribute : Attribute Constructors DefaultNodeColorAttribute(string) Declaration public DefaultNodeColorAttribute(string color) Parameters Type Name Description string color Fields Value The default color of the annotated node. Declaration public readonly Color Value Field Value Type Description Color"
  },
  "api/Holoride.ElasticSDK.Graph.DefaultNodeNameAttribute.html": {
    "href": "api/Holoride.ElasticSDK.Graph.DefaultNodeNameAttribute.html",
    "title": "Class DefaultNodeNameAttribute | ElasticSDK Documentation",
    "keywords": "Class DefaultNodeNameAttribute Attribute that may be added to Node implementations to define the default name they will be created with when added to a graph. Inheritance object Attribute DefaultNodeNameAttribute Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Class)] [BaseTypeRequired(typeof(IPipelineNode))] public class DefaultNodeNameAttribute : Attribute Constructors DefaultNodeNameAttribute(string) Declaration public DefaultNodeNameAttribute(string name) Parameters Type Name Description string name Properties Name Declaration public string Name { get; } Property Value Type Description string"
  },
  "api/Holoride.ElasticSDK.Graph.DefaultPreviewVisibilityAttribute.html": {
    "href": "api/Holoride.ElasticSDK.Graph.DefaultPreviewVisibilityAttribute.html",
    "title": "Class DefaultPreviewVisibilityAttribute | ElasticSDK Documentation",
    "keywords": "Class DefaultPreviewVisibilityAttribute Allows overriding default node preview visibility in the node graph. By default previews are visible. Inheritance object Attribute DefaultPreviewVisibilityAttribute Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Class)] public sealed class DefaultPreviewVisibilityAttribute : Attribute Constructors DefaultPreviewVisibilityAttribute(bool) Declaration public DefaultPreviewVisibilityAttribute(bool value) Parameters Type Name Description bool value Fields Value Declaration public readonly bool Value Field Value Type Description bool"
  },
  "api/Holoride.ElasticSDK.Graph.ElasticNodeGraph.html": {
    "href": "api/Holoride.ElasticSDK.Graph.ElasticNodeGraph.html",
    "title": "Class ElasticNodeGraph | ElasticSDK Documentation",
    "keywords": "Class ElasticNodeGraph A holoride specific graph that is instantiable from the create menu. Inheritance object Object ScriptableObject XNode.NodeGraph ElasticNodeGraph Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [CreateAssetMenu(menuName = \"holoride/Elastic Graph\", order = 8)] public class ElasticNodeGraph : NodeGraph Methods AddNode(Type) Add a node to the graph by type. Declaration public override Node AddNode(Type type) Parameters Type Name Description Type type The type of the node to add. Returns Type Description XNode.Node The instance of the node that was added to the graph. Overrides XNode.NodeGraph.AddNode(System.Type) FindReferencedGraphs() Declaration public IEnumerable<ElasticNodeGraph> FindReferencedGraphs() Returns Type Description IEnumerable<ElasticNodeGraph>"
  },
  "api/Holoride.ElasticSDK.Graph.ElasticSceneDefinitionNode.html": {
    "href": "api/Holoride.ElasticSDK.Graph.ElasticSceneDefinitionNode.html",
    "title": "Class ElasticSceneDefinitionNode | ElasticSDK Documentation",
    "keywords": "Class ElasticSceneDefinitionNode The root node where all terrain generation information is gathered. Inheritance object Object ScriptableObject XNode.Node Node ElasticSceneDefinitionNode Inherited Members Node.Awake() Node.IsPortOptional(NodePort) Node.GetNodeCategoryType() Node.XNodePrettyName(Type) Node.TraverseSubGraph() Node.CallRecursive(Action<Node>, ISet<Node>) Node.ForEachOutput<T>(Action<T>) Node.GetInputSourcePorts(string) Node.GetOutputSinkPorts(string) Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [Serializable] [DefaultNodeColor(\"#6AA889\")] [NodePath(new string[] { \"ElasticSceneDefinitionNode\" })] [HelpURL(\"http://localhost:8080/articles/Procedural-Generation/Graph-Node-Overview.html#elastic-scene-definition\")] public class ElasticSceneDefinitionNode : Node Methods OnCreateConnection(NodePort, NodePort) Declaration public override void OnCreateConnection(NodePort from, NodePort to) Parameters Type Name Description XNode.NodePort from XNode.NodePort to Overrides XNode.Node.OnCreateConnection(XNode.NodePort, XNode.NodePort)"
  },
  "api/Holoride.ElasticSDK.Graph.ExperimentalNodeAttribute.html": {
    "href": "api/Holoride.ElasticSDK.Graph.ExperimentalNodeAttribute.html",
    "title": "Class ExperimentalNodeAttribute | ElasticSDK Documentation",
    "keywords": "Class ExperimentalNodeAttribute Attribute that may be added to experimental Node implementations to render a experimental node warning box on the graph node gui. Inheritance object Attribute ExperimentalNodeAttribute Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Class)] [BaseTypeRequired(typeof(IPipelineNode))] public class ExperimentalNodeAttribute : Attribute"
  },
  "api/Holoride.ElasticSDK.Graph.FloatListFromMapProvider.html": {
    "href": "api/Holoride.ElasticSDK.Graph.FloatListFromMapProvider.html",
    "title": "Class FloatListFromMapProvider | ElasticSDK Documentation",
    "keywords": "Class FloatListFromMapProvider Inheritance object FloatListFromMapProvider Implements IWorkerMapper<IReadOnlyList<float>> IWorkerMapper Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public class FloatListFromMapProvider : IWorkerMapper<IReadOnlyList<float>>, IWorkerMapper Properties SourceNodeType Declaration public Type SourceNodeType { get; } Property Value Type Description Type Methods Map(IPipelineWorker, GlobalPosition, CancellationToken) Declaration public UniTask<IReadOnlyList<float>> Map(IPipelineWorker worker, GlobalPosition position, CancellationToken cancellationToken = default) Parameters Type Name Description IPipelineWorker worker GlobalPosition position CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask<T><IReadOnlyList<float>> Map(IPipelineWorker, CancellationToken) Declaration public UniTask<IReadOnlyList<float>> Map(IPipelineWorker worker, CancellationToken cancellationToken = default) Parameters Type Name Description IPipelineWorker worker CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask<T><IReadOnlyList<float>> Explicit Interface Implementations IWorkerMapper.Map(IPipelineWorker, GlobalPosition, CancellationToken) Declaration UniTask<object> IWorkerMapper.Map(IPipelineWorker worker, GlobalPosition position, CancellationToken cancellationToken) Parameters Type Name Description IPipelineWorker worker GlobalPosition position CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask<T><object> IWorkerMapper.Map(IPipelineWorker, CancellationToken) Declaration UniTask<object> IWorkerMapper.Map(IPipelineWorker worker, CancellationToken cancellationToken) Parameters Type Name Description IPipelineWorker worker CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask<T><object> Implements IWorkerMapper<T> IWorkerMapper"
  },
  "api/Holoride.ElasticSDK.Graph.FloatValueFromMapProvider.FloatValue.html": {
    "href": "api/Holoride.ElasticSDK.Graph.FloatValueFromMapProvider.FloatValue.html",
    "title": "Struct FloatValueFromMapProvider.FloatValue | ElasticSDK Documentation",
    "keywords": "Struct FloatValueFromMapProvider.FloatValue Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public struct FloatValueFromMapProvider.FloatValue Fields Value Declaration public float Value Field Value Type Description float Methods ToString() Declaration public override string ToString() Returns Type Description string Overrides ValueType.ToString() Operators implicit operator float(FloatValue) Declaration public static implicit operator float(FloatValueFromMapProvider.FloatValue val) Parameters Type Name Description FloatValueFromMapProvider.FloatValue val Returns Type Description float implicit operator FloatValue(float) Declaration public static implicit operator FloatValueFromMapProvider.FloatValue(float value) Parameters Type Name Description float value Returns Type Description FloatValueFromMapProvider.FloatValue"
  },
  "api/Holoride.ElasticSDK.Graph.FloatValueFromMapProvider.html": {
    "href": "api/Holoride.ElasticSDK.Graph.FloatValueFromMapProvider.html",
    "title": "Class FloatValueFromMapProvider | ElasticSDK Documentation",
    "keywords": "Class FloatValueFromMapProvider Inheritance object FloatValueFromMapProvider Implements IWorkerMapper<FloatValueFromMapProvider.FloatValue> IWorkerMapper Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public class FloatValueFromMapProvider : IWorkerMapper<FloatValueFromMapProvider.FloatValue>, IWorkerMapper Properties SourceNodeType Declaration public Type SourceNodeType { get; } Property Value Type Description Type Methods Map(IPipelineWorker, GlobalPosition, CancellationToken) Declaration public UniTask<FloatValueFromMapProvider.FloatValue> Map(IPipelineWorker worker, GlobalPosition position, CancellationToken cancellationToken = default) Parameters Type Name Description IPipelineWorker worker GlobalPosition position CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask<T><FloatValueFromMapProvider.FloatValue> Map(IPipelineWorker, CancellationToken) Declaration public UniTask<FloatValueFromMapProvider.FloatValue> Map(IPipelineWorker worker, CancellationToken cancellationToken = default) Parameters Type Name Description IPipelineWorker worker CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask<T><FloatValueFromMapProvider.FloatValue> Explicit Interface Implementations IWorkerMapper.Map(IPipelineWorker, GlobalPosition, CancellationToken) Declaration UniTask<object> IWorkerMapper.Map(IPipelineWorker worker, GlobalPosition position, CancellationToken cancellationToken) Parameters Type Name Description IPipelineWorker worker GlobalPosition position CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask<T><object> IWorkerMapper.Map(IPipelineWorker, CancellationToken) Declaration UniTask<object> IWorkerMapper.Map(IPipelineWorker worker, CancellationToken cancellationToken) Parameters Type Name Description IPipelineWorker worker CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask<T><object> Implements IWorkerMapper<T> IWorkerMapper"
  },
  "api/Holoride.ElasticSDK.Graph.HidePreviewAttribute.html": {
    "href": "api/Holoride.ElasticSDK.Graph.HidePreviewAttribute.html",
    "title": "Class HidePreviewAttribute | ElasticSDK Documentation",
    "keywords": "Class HidePreviewAttribute Attribute that may be attached to Node implementations to permanently disable previews for nodes of that type in the graph editor. Inheritance object Attribute HidePreviewAttribute Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Class)] public class HidePreviewAttribute : Attribute"
  },
  "api/Holoride.ElasticSDK.Graph.html": {
    "href": "api/Holoride.ElasticSDK.Graph.html",
    "title": "Namespace Holoride.ElasticSDK.Graph | ElasticSDK Documentation",
    "keywords": "Namespace Holoride.ElasticSDK.Graph Classes DefaultNodeColorAttribute Attribute that may be used to specify the default color tint for a not type and its sub-types. DefaultNodeNameAttribute Attribute that may be added to Node implementations to define the default name they will be created with when added to a graph. DefaultPreviewVisibilityAttribute Allows overriding default node preview visibility in the node graph. By default previews are visible. ElasticNodeGraph A holoride specific graph that is instantiable from the create menu. ElasticSceneDefinitionNode The root node where all terrain generation information is gathered. ExperimentalNodeAttribute Attribute that may be added to experimental Node implementations to render a experimental node warning box on the graph node gui. FloatListFromMapProvider FloatValueFromMapProvider HidePreviewAttribute Attribute that may be attached to Node implementations to permanently disable previews for nodes of that type in the graph editor. InjectGraphDataAttribute Prefab-based spawners in the node graph will scan scripts for fields/properties with this attribute. Annotated fields/properties will automatically display input ports in the node graph from where the data for the fields will be pulled. Node An elastic graph node using XNode, that defines how sub-graphs are traversed. Node.InputAttribute Overrides XNode.Node.InputAttribute with custom default values. Node.OutputAttribute Overrides XNode.Node.OutputAttribute with custom default values. Node<T> A elastic graph node with a specific primary output. NodePath Collection of commonly used node path segments. NodePathAttribute Attribute that allows manually specifying the path a node will appear at in the node creation dialog. Individual path segments are to specified as individual constructor parameters. PoseSetProvider XNodePipelineAssembler Assembles a pipeline from a XNode sub-graph consisting of interconnected IPipelineWorkers. Structs FloatValueFromMapProvider.FloatValue Interfaces IGenerationSettings The interface to extend the GenerationSettings from other modules. IWorkerMapper Implementations of this interface will be used for accessing data of nodes in the node graph. In addition to implementing this interface the implementing class needs to be annotated with the DataMappingReturnType specifying the type that this Mapper returns. Directly implement the specialized IWorkerMapper<T> instead of this interface. Otherwise runtime errors will occur when looking up the corresponding mapper for a return type. IWorkerMapper<T>"
  },
  "api/Holoride.ElasticSDK.Graph.IGenerationSettings.html": {
    "href": "api/Holoride.ElasticSDK.Graph.IGenerationSettings.html",
    "title": "Interface IGenerationSettings | ElasticSDK Documentation",
    "keywords": "Interface IGenerationSettings The interface to extend the GenerationSettings from other modules. Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public interface IGenerationSettings"
  },
  "api/Holoride.ElasticSDK.Graph.InjectGraphDataAttribute.html": {
    "href": "api/Holoride.ElasticSDK.Graph.InjectGraphDataAttribute.html",
    "title": "Class InjectGraphDataAttribute | ElasticSDK Documentation",
    "keywords": "Class InjectGraphDataAttribute Prefab-based spawners in the node graph will scan scripts for fields/properties with this attribute. Annotated fields/properties will automatically display input ports in the node graph from where the data for the fields will be pulled. Inheritance object Attribute InjectGraphDataAttribute Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Property|AttributeTargets.Field)] [MeansImplicitUse] public class InjectGraphDataAttribute : Attribute Properties PortName Declaration public string PortName { get; set; } Property Value Type Description string"
  },
  "api/Holoride.ElasticSDK.Graph.IWorkerMapper-1.html": {
    "href": "api/Holoride.ElasticSDK.Graph.IWorkerMapper-1.html",
    "title": "Interface IWorkerMapper<T> | ElasticSDK Documentation",
    "keywords": "Interface IWorkerMapper<T> Inherited Members IWorkerMapper.SourceNodeType Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public interface IWorkerMapper<T> : IWorkerMapper Type Parameters Name Description T Methods Map(IPipelineWorker, GlobalPosition, CancellationToken) This method maps the data from the connected worker at the position to the type defined by the DataMappingProviderInfoAttribute. Declaration UniTask<T> Map(IPipelineWorker worker, GlobalPosition position, CancellationToken cancellationToken = default) Parameters Type Name Description IPipelineWorker worker GlobalPosition position CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask<T><T> Map(IPipelineWorker, CancellationToken) This method maps the data from the connected worker to the type defined by the DataMappingProviderInfoAttribute. Declaration UniTask<T> Map(IPipelineWorker worker, CancellationToken cancellationToken = default) Parameters Type Name Description IPipelineWorker worker CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask<T><T>"
  },
  "api/Holoride.ElasticSDK.Graph.IWorkerMapper.html": {
    "href": "api/Holoride.ElasticSDK.Graph.IWorkerMapper.html",
    "title": "Interface IWorkerMapper | ElasticSDK Documentation",
    "keywords": "Interface IWorkerMapper Implementations of this interface will be used for accessing data of nodes in the node graph. In addition to implementing this interface the implementing class needs to be annotated with the DataMappingReturnType specifying the type that this Mapper returns. Directly implement the specialized IWorkerMapper<T> instead of this interface. Otherwise runtime errors will occur when looking up the corresponding mapper for a return type. Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public interface IWorkerMapper Properties SourceNodeType Gets the type of node the mapper gets the data from (displayed as input port). Declaration Type SourceNodeType { get; } Property Value Type Description Type Methods Map(IPipelineWorker, GlobalPosition, CancellationToken) This method maps the data from the connected worker at the position to the type defined by the DataMappingProviderInfoAttribute. Declaration UniTask<object> Map(IPipelineWorker worker, GlobalPosition position, CancellationToken cancellationToken = default) Parameters Type Name Description IPipelineWorker worker GlobalPosition position CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask<T><object> Map(IPipelineWorker, CancellationToken) This method maps the data from the connected worker to the type defined by the DataMappingProviderInfoAttribute. Declaration UniTask<object> Map(IPipelineWorker worker, CancellationToken cancellationToken = default) Parameters Type Name Description IPipelineWorker worker CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask<T><object>"
  },
  "api/Holoride.ElasticSDK.Graph.Maps.BinaryMathNodeBase.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Maps.BinaryMathNodeBase.html",
    "title": "Class BinaryMathNodeBase | ElasticSDK Documentation",
    "keywords": "Class BinaryMathNodeBase Base class for binary math operations, such as addition, multiplication etc. Inheritance object Object ScriptableObject XNode.Node Node Node<MapNode> MapNode BinaryMathNodeBase Implements IPipelineNode Inherited Members Node<MapNode>.Output Node<MapNode>.GetValue(NodePort) Node.Awake() Node.IsPortOptional(NodePort) Node.GetNodeCategoryType() Node.XNodePrettyName(Type) Node.TraverseSubGraph() Node.CallRecursive(Action<Node>, ISet<Node>) Node.ForEachOutput<T>(Action<T>) Node.GetInputSourcePorts(string) Node.GetOutputSinkPorts(string) Namespace: Holoride.ElasticSDK.Graph.Maps Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public abstract class BinaryMathNodeBase : MapNode, IPipelineNode Properties InputNames Gets the names of the node inputs corresponding to the three operation inputs. These should resolve into MapWorkers defined as inputs with the corresponding names. Declaration protected abstract (string InputNameA, string InputNameB) InputNames { get; } Property Value Type Description (string InputNameA, string InputNameB) Methods Apply(ComputeBuffer, ComputeBuffer, ComputeBuffer) Applies the binary operation to the specified inputs and write the result into the specified output. Declaration protected abstract void Apply(ComputeBuffer a, ComputeBuffer b, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a The first input buffer. ComputeBuffer b The second input buffer. ComputeBuffer output The output buffer. GeneratePipelineWorker() Generates a pipeline worker. Declaration public override IPipelineWorker GeneratePipelineWorker() Returns Type Description IPipelineWorker Overrides MapNode.GeneratePipelineWorker() Implements IPipelineNode"
  },
  "api/Holoride.ElasticSDK.Graph.Maps.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Maps.html",
    "title": "Namespace Holoride.ElasticSDK.Graph.Maps | ElasticSDK Documentation",
    "keywords": "Namespace Holoride.ElasticSDK.Graph.Maps Classes BinaryMathNodeBase Base class for binary math operations, such as addition, multiplication etc. MapNode A node that generates a worker that can be added to the pipeline. MapNode.MapWorker<T> The worker with a back reference to the node. Represents the result of the different evaluation of a 2D float buffer, based on the used filter implementation, through accessing the ram/v-ram. Also manages compute shader calls. TernaryMathNodeBase Base class for ternary math operations, such as clamp. UnaryMathNodeBase Base class for unary math operations, such as trigonometric methods."
  },
  "api/Holoride.ElasticSDK.Graph.Maps.MapNode.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Maps.MapNode.html",
    "title": "Class MapNode | ElasticSDK Documentation",
    "keywords": "Class MapNode A node that generates a worker that can be added to the pipeline. Inheritance object Object ScriptableObject XNode.Node Node Node<MapNode> MapNode BinaryMathNodeBase TernaryMathNodeBase UnaryMathNodeBase Implements IPipelineNode Inherited Members Node<MapNode>.Output Node<MapNode>.GetValue(NodePort) Node.Awake() Node.IsPortOptional(NodePort) Node.GetNodeCategoryType() Node.XNodePrettyName(Type) Node.TraverseSubGraph() Node.CallRecursive(Action<Node>, ISet<Node>) Node.ForEachOutput<T>(Action<T>) Node.GetInputSourcePorts(string) Node.GetOutputSinkPorts(string) Namespace: Holoride.ElasticSDK.Graph.Maps Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [Serializable] [DefaultNodeColor(\"#AE63FF\")] [HelpURL(\"http://localhost:8080/articles/Procedural-Generation/Graph-Node-Overview.html#map\")] public abstract class MapNode : Node<MapNode>, IPipelineNode Methods GeneratePipelineWorker() Generates a pipeline worker. Declaration public abstract IPipelineWorker GeneratePipelineWorker() Returns Type Description IPipelineWorker Implements IPipelineNode"
  },
  "api/Holoride.ElasticSDK.Graph.Maps.MapNode.MapWorker-1.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Maps.MapNode.MapWorker-1.html",
    "title": "Class MapNode.MapWorker<T> | ElasticSDK Documentation",
    "keywords": "Class MapNode.MapWorker<T> The worker with a back reference to the node. Represents the result of the different evaluation of a 2D float buffer, based on the used filter implementation, through accessing the ram/v-ram. Also manages compute shader calls. Inheritance object PipelineWorkerBase MapWorker MapNode.MapWorker<T> Implements IPipelineWorker Inherited Members MapWorker.IsCPUBufferFinal MapWorker.IsGPUBufferFinal MapWorker.EnsureCPUBuffer MapWorker.EnsureGPUBuffer MapWorker.PromiseCPUBuffer() MapWorker.PromiseGPUBuffer() MapWorker.CallInit() MapWorker.CallProcessAsync(GenerationContext, IProgress<float>, CancellationToken) MapWorker.Dispose() MapWorker.CurrentCPUWriteBuffer MapWorker.CurrentGPUWriteBuffer MapWorker.CurrentCPUReadBuffer MapWorker.CurrentGPUReadBuffer MapWorker.SetCPUWriteBufferValue(int, int, float) MapWorker.GetCPUWriteBufferValue(int, int) MapWorker.GetCPUReadBufferValue(int, int) MapWorker.GetCPUReadBufferValueInterpolated(GlobalPosition) MapWorker.GetGradientAtPosition(GlobalPosition) MapWorker.RunShader(ComputeShader, int) MapWorker.ForEachCoordinate(Action<int, int>) MapWorker.CopyFromCPUToGPU() MapWorker.CopyFromGPUToCPUAfterProcessAsync(CancellationToken) MapWorker.CopyFromGPUToCPUAsync(CancellationToken) MapWorker.BlendWithPreviousGPUBufferAsync(GenerationContext, CancellationToken) MapWorker.BlendWithPreviousGPUBufferAsync(ComputeShader, int, GenerationContext, CancellationToken) MapWorker.BlendWithPreviousCPUBufferAsync(GenerationContext, CancellationToken) MapWorker.ToShaderArray(float[]) MapWorker.AttachCurveToComputeShader(string, AnimationCurve, int, ComputeShader, float, float) MapWorker.Undefined MapWorker.IsUndefined(float) PipelineWorkerBase.GenerationSettings PipelineWorkerBase.GenerationState PipelineWorkerBase.CurrentGenerationContext PipelineWorkerBase.Pipeline PipelineWorkerBase.IsGatheringResources PipelineWorkerBase.IsProcessing PipelineWorkerBase.Inputs PipelineWorkerBase.MissingMandatoryInputs PipelineWorkerBase.AddMissingMandatoryInput(string) PipelineWorkerBase.HasMissingMandatoryInputInHierarchy PipelineWorkerBase.AddInput(string, IPipelineWorker) PipelineWorkerBase.GetInput(string) PipelineWorkerBase.GetInput<T>(string) PipelineWorkerBase.InitResources() PipelineWorkerBase.CallInitResources() PipelineWorkerBase.Init() PipelineWorkerBase.GatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.CallGatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.ProcessAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.CleanUp() PipelineWorkerBase.CallCleanUp() Namespace: Holoride.ElasticSDK.Graph.Maps Assembly: Holoride.ElasticSDK.Runtime.dll Syntax protected abstract class MapNode.MapWorker<T> : MapWorker, IPipelineWorker where T : MapNode Type Parameters Name Description T The generating node type deriving from MapWorker. Constructors MapWorker(T, bool, bool, bool) Instantiates the worker. Declaration protected MapWorker(T node, bool provideDoubleBuffer, bool provideCPUBuffer, bool provideGPUBuffer) Parameters Type Name Description T node A back reference to the node that created this worker. bool provideDoubleBuffer States whether this worker uses double buffering. If this value is false, read and write buffer will be the same. bool provideCPUBuffer States whether this worker provides a CPU buffer by design. If this value is false, the CPU buffer is copied to on request. bool provideGPUBuffer States whether this worker provides a GPU buffer by design. If this value is false, the GPU buffer is copied to on request. Fields Node A reference to the node that generated this worker in order to access its serialized data. Declaration protected readonly T Node Field Value Type Description T Implements IPipelineWorker"
  },
  "api/Holoride.ElasticSDK.Graph.Maps.TernaryMathNodeBase.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Maps.TernaryMathNodeBase.html",
    "title": "Class TernaryMathNodeBase | ElasticSDK Documentation",
    "keywords": "Class TernaryMathNodeBase Base class for ternary math operations, such as clamp. Inheritance object Object ScriptableObject XNode.Node Node Node<MapNode> MapNode TernaryMathNodeBase Implements IPipelineNode Inherited Members Node<MapNode>.Output Node<MapNode>.GetValue(NodePort) Node.Awake() Node.IsPortOptional(NodePort) Node.GetNodeCategoryType() Node.XNodePrettyName(Type) Node.TraverseSubGraph() Node.CallRecursive(Action<Node>, ISet<Node>) Node.ForEachOutput<T>(Action<T>) Node.GetInputSourcePorts(string) Node.GetOutputSinkPorts(string) Namespace: Holoride.ElasticSDK.Graph.Maps Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public abstract class TernaryMathNodeBase : MapNode, IPipelineNode Properties InputNames Gets the names of the node inputs corresponding to the three operation inputs. These should resolve into MapWorkers defined as inputs with the corresponding names. Declaration protected abstract (string InputNameA, string InputNameB, string InputNameC) InputNames { get; } Property Value Type Description (string InputNameA, string InputNameB, string InputNameC) Methods Apply(ComputeBuffer, ComputeBuffer, ComputeBuffer, ComputeBuffer) Applies the ternary operation to the specified inputs and write the result into the specified output. Declaration protected abstract void Apply(ComputeBuffer a, ComputeBuffer b, ComputeBuffer c, ComputeBuffer output) Parameters Type Name Description ComputeBuffer a The first input buffer. ComputeBuffer b The second input buffer. ComputeBuffer c The third input buffer. ComputeBuffer output The output buffer. GeneratePipelineWorker() Generates a pipeline worker. Declaration public override IPipelineWorker GeneratePipelineWorker() Returns Type Description IPipelineWorker Overrides MapNode.GeneratePipelineWorker() Implements IPipelineNode"
  },
  "api/Holoride.ElasticSDK.Graph.Maps.UnaryMathNodeBase.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Maps.UnaryMathNodeBase.html",
    "title": "Class UnaryMathNodeBase | ElasticSDK Documentation",
    "keywords": "Class UnaryMathNodeBase Base class for unary math operations, such as trigonometric methods. Inheritance object Object ScriptableObject XNode.Node Node Node<MapNode> MapNode UnaryMathNodeBase Implements IPipelineNode Inherited Members Node<MapNode>.Output Node<MapNode>.GetValue(NodePort) Node.Awake() Node.IsPortOptional(NodePort) Node.GetNodeCategoryType() Node.XNodePrettyName(Type) Node.TraverseSubGraph() Node.CallRecursive(Action<Node>, ISet<Node>) Node.ForEachOutput<T>(Action<T>) Node.GetInputSourcePorts(string) Node.GetOutputSinkPorts(string) Namespace: Holoride.ElasticSDK.Graph.Maps Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public abstract class UnaryMathNodeBase : MapNode, IPipelineNode Methods Apply(ComputeBuffer, ComputeBuffer) Applies the unary operation to the specified input and write the result into the specified output. Declaration protected abstract void Apply(ComputeBuffer input, ComputeBuffer output) Parameters Type Name Description ComputeBuffer input The input buffer. ComputeBuffer output The output buffer. GeneratePipelineWorker() Generates a pipeline worker. Declaration public override IPipelineWorker GeneratePipelineWorker() Returns Type Description IPipelineWorker Overrides MapNode.GeneratePipelineWorker() Implements IPipelineNode"
  },
  "api/Holoride.ElasticSDK.Graph.Node-1.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Node-1.html",
    "title": "Class Node<T> | ElasticSDK Documentation",
    "keywords": "Class Node<T> A elastic graph node with a specific primary output. Inheritance object Object ScriptableObject XNode.Node Node Node<T> DataProviderNode<TDataType> MapNode PoseSetNode SpawnerNode Inherited Members Node.Awake() Node.IsPortOptional(NodePort) Node.GetNodeCategoryType() Node.XNodePrettyName(Type) Node.TraverseSubGraph() Node.CallRecursive(Action<Node>, ISet<Node>) Node.ForEachOutput<T>(Action<T>) Node.GetInputSourcePorts(string) Node.GetOutputSinkPorts(string) Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [Serializable] public abstract class Node<T> : Node Type Parameters Name Description T Fields Output Declaration [Node.Output(Node.ShowBackingValue.Never, Node.ConnectionType.Multiple, Node.TypeConstraint.None, false)] public T Output Field Value Type Description T Methods GetValue(NodePort) Gets this node. Declaration public override object GetValue(NodePort port) Parameters Type Name Description XNode.NodePort port The output port. Returns Type Description object This node. Overrides XNode.Node.GetValue(XNode.NodePort)"
  },
  "api/Holoride.ElasticSDK.Graph.Node.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Node.html",
    "title": "Class Node | ElasticSDK Documentation",
    "keywords": "Class Node An elastic graph node using XNode, that defines how sub-graphs are traversed. Inheritance object Object ScriptableObject XNode.Node Node ElasticSceneDefinitionNode Node<T> PortalInputNode<TData> PortalOutputNode<TData, TInputNode> Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [Serializable] public abstract class Node : Node Methods Awake() Declaration protected virtual void Awake() CallRecursive(Action<Node>, ISet<Node>) Calls the given action on all inputs recursive. Declaration public virtual void CallRecursive(Action<Node> action, ISet<Node> visited) Parameters Type Name Description Action<Node> action The action to call on all inputs recursive. ISet<Node> visited An set that keeps track of whether a node was already visited. ForEachOutput<T>(Action<T>) Calls the given action on all outputs. Declaration protected void ForEachOutput<T>(Action<T> action) Parameters Type Name Description Action<T> action The action to call on all outputs. Type Parameters Name Description T GetInputSourcePorts(string) Collects all direct and indirect input source ports of this node (i.e. output ports of the nodes connected to the specified input port of this node). Indirect ports are a result of PortalOutputNode<TData, TInputNode>s. In these cases, even if the local XNode.NodePort.ConnectionCount is one, the result may contain multiple ports. Declaration public IEnumerable<NodePort> GetInputSourcePorts(string fieldName) Parameters Type Name Description string fieldName The name of the input port to collect connected ports for. Returns Type Description IEnumerable<XNode.NodePort> The list of directly and indirectly connected ports. Exceptions Type Condition ArgumentException If there exists no input port for the specified name. GetNodeCategoryType() Get the base type of this node, defining the logical type category the node belongs to, e.g. MapNode or SpawnerNode. Declaration public Type GetNodeCategoryType() Returns Type Description Type The logical node category type this node belongs to. GetOutputSinkPorts(string) Collects all direct and indirect output sink ports of this node (i.e. input ports of nodes connected to the specified output port of this node). Indirect ports are a result of PortalInputNode<TData>s. In these cases, even if the local XNode.NodePort.ConnectionCount is one, the result may contain multiple ports. Declaration public IEnumerable<NodePort> GetOutputSinkPorts(string fieldName) Parameters Type Name Description string fieldName The name of the output port to collect connected ports for. Returns Type Description IEnumerable<XNode.NodePort> The list of directly and indirectly connected ports. Exceptions Type Condition ArgumentException If there exists no output port for the specified name. IsPortOptional(NodePort) Declaration public virtual bool IsPortOptional(NodePort port) Parameters Type Name Description XNode.NodePort port Returns Type Description bool TraverseSubGraph() Traverses the graph and dumps all nodes of a specific type into a list in their traversal order. Declaration public List<Node> TraverseSubGraph() Returns Type Description List<Node> The list of all nodes in the traversal order. XNodePrettyName(Type) Returns a prettyfied type name according to XNode to be compatible with their settings dictionary. Must be cloned, because their function only works in the editor. Declaration public static string XNodePrettyName(Type type) Parameters Type Name Description Type type The type that's name to prettify. Returns Type Description string The prettified name."
  },
  "api/Holoride.ElasticSDK.Graph.Node.InputAttribute.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Node.InputAttribute.html",
    "title": "Class Node.InputAttribute | ElasticSDK Documentation",
    "keywords": "Class Node.InputAttribute Overrides XNode.Node.InputAttribute with custom default values. Inheritance object Attribute XNode.Node.XNode.Node.InputAttribute Node.InputAttribute Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Field)] [MeansImplicitUse] public class Node.InputAttribute : Node.InputAttribute Constructors InputAttribute(ShowBackingValue, ConnectionType, TypeConstraint, bool, bool) Mark a serializable field as an input port. You can access this through XNode.Node.GetInputPort(System.String). Declaration public InputAttribute(Node.ShowBackingValue backingValue = ShowBackingValue.Never, Node.ConnectionType connectionType = ConnectionType.Override, Node.TypeConstraint typeConstraint = TypeConstraint.Strict, bool dynamicPortList = false, bool optional = false) Parameters Type Name Description XNode.Node.XNode.Node.ShowBackingValue backingValue Whether we display the backing value for this port as an editor field. XNode.Node.XNode.Node.ConnectionType connectionType Whether we allow multiple connections. XNode.Node.XNode.Node.TypeConstraint typeConstraint Constrains which input connections can be made to this port. bool dynamicPortList If true, will display a reorderable list of inputs instead of a single port. Will automatically add and display values for lists and arrays. bool optional Defines whether input to this port is optional. Fields Optional Declaration public bool Optional Field Value Type Description bool"
  },
  "api/Holoride.ElasticSDK.Graph.Node.OutputAttribute.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Node.OutputAttribute.html",
    "title": "Class Node.OutputAttribute | ElasticSDK Documentation",
    "keywords": "Class Node.OutputAttribute Overrides XNode.Node.OutputAttribute with custom default values. Inheritance object Attribute XNode.Node.XNode.Node.OutputAttribute Node.OutputAttribute Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Field)] public class Node.OutputAttribute : Node.OutputAttribute Constructors OutputAttribute(ShowBackingValue, ConnectionType, TypeConstraint, bool) Declaration public OutputAttribute(Node.ShowBackingValue backingValue = ShowBackingValue.Never, Node.ConnectionType connectionType = ConnectionType.Multiple, Node.TypeConstraint typeConstraint = TypeConstraint.None, bool dynamicPortList = false) Parameters Type Name Description XNode.Node.XNode.Node.ShowBackingValue backingValue XNode.Node.XNode.Node.ConnectionType connectionType XNode.Node.XNode.Node.TypeConstraint typeConstraint bool dynamicPortList"
  },
  "api/Holoride.ElasticSDK.Graph.NodePath.html": {
    "href": "api/Holoride.ElasticSDK.Graph.NodePath.html",
    "title": "Class NodePath | ElasticSDK Documentation",
    "keywords": "Class NodePath Collection of commonly used node path segments. Inheritance object NodePath Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public static class NodePath Fields AdvancedCategory Declaration public const string AdvancedCategory = \"Advanced\" Field Value Type Description string BasicCategory Declaration public const string BasicCategory = \"Basic\" Field Value Type Description string DataProviderCategory Declaration public const string DataProviderCategory = \"Data Provider\" Field Value Type Description string ExperimentalSubCategory Declaration public const string ExperimentalSubCategory = \"Experimental\" Field Value Type Description string InterpolationCategory Declaration public const string InterpolationCategory = \"Interpolation\" Field Value Type Description string MapsCategory Declaration public const string MapsCategory = \"Maps\" Field Value Type Description string MathCategory Declaration public const string MathCategory = \"Math\" Field Value Type Description string ModifiersCategory Declaration public const string ModifiersCategory = \"Modifiers\" Field Value Type Description string PortalsCategory Declaration public const string PortalsCategory = \"Portals\" Field Value Type Description string PoseSetsCategory Declaration public const string PoseSetsCategory = \"Pose Sets\" Field Value Type Description string RangeCategory Declaration public const string RangeCategory = \"Range\" Field Value Type Description string RoundCategory Declaration public const string RoundCategory = \"Round\" Field Value Type Description string RouteSegmentsCategory Declaration public const string RouteSegmentsCategory = \"Route Segments\" Field Value Type Description string SourcesCategory Declaration public const string SourcesCategory = \"Sources\" Field Value Type Description string SpawnersCategory Declaration public const string SpawnersCategory = \"Spawners\" Field Value Type Description string TextureLayersCategory Declaration public const string TextureLayersCategory = \"Texture Layers\" Field Value Type Description string TrigonometryCategory Declaration public const string TrigonometryCategory = \"Trigonometry\" Field Value Type Description string"
  },
  "api/Holoride.ElasticSDK.Graph.NodePathAttribute.html": {
    "href": "api/Holoride.ElasticSDK.Graph.NodePathAttribute.html",
    "title": "Class NodePathAttribute | ElasticSDK Documentation",
    "keywords": "Class NodePathAttribute Attribute that allows manually specifying the path a node will appear at in the node creation dialog. Individual path segments are to specified as individual constructor parameters. Inheritance object Attribute XNode.Node.XNode.Node.CreateNodeMenuAttribute NodePathAttribute Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [BaseTypeRequired(typeof(IPipelineNode))] public class NodePathAttribute : Node.CreateNodeMenuAttribute Constructors NodePathAttribute(params string[]) Declaration public NodePathAttribute(params string[] path) Parameters Type Name Description string[] path"
  },
  "api/Holoride.ElasticSDK.Graph.Portals.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Portals.html",
    "title": "Namespace Holoride.ElasticSDK.Graph.Portals | ElasticSDK Documentation",
    "keywords": "Namespace Holoride.ElasticSDK.Graph.Portals Classes PortalInputNode<TData> Base class for all portal input nodes, taking care of common logic. Each portal type will need to sub-class a pair of this and PortalOutputNode<TData, TInputNode>. Due to Unity not supporting file-local identifiers for .cs files, implementations have to live in separate source files, so they can be assigned distinct GUIDs for serialization. PortalOutputNode<TData, TInputNode> Base class for all portal output nodes, taking care of common logic. Each portal type will need to sub-class a pair of this and PortalInputNode<TData>. Due to Unity not supporting file-local identifiers for .cs files, implementations have to live in separate source files, so they can be assigned distinct GUIDs for serialization. Interfaces IPortalInputNode Nodes implementing this interface can act as portal inputs and will be handled accordingly by GetOutputSinkPorts(string). IPortalOutputNode Nodes implementing this interface can act as portal outputs and will be handled accordingly by GetInputSourcePorts(string)."
  },
  "api/Holoride.ElasticSDK.Graph.Portals.IPortalInputNode.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Portals.IPortalInputNode.html",
    "title": "Interface IPortalInputNode | ElasticSDK Documentation",
    "keywords": "Interface IPortalInputNode Nodes implementing this interface can act as portal inputs and will be handled accordingly by GetOutputSinkPorts(string). Namespace: Holoride.ElasticSDK.Graph.Portals Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public interface IPortalInputNode Properties PortalName Gets the human readable name of the quantum link established by this portal. Declaration string PortalName { get; } Property Value Type Description string Methods FindOutputNodes() Returns all IPortalOutputNodes connected to this portal input. Declaration IEnumerable<IPortalOutputNode> FindOutputNodes() Returns Type Description IEnumerable<IPortalOutputNode> The outputs connected to this input. GetInputSourcePorts() Returns the resolved input source ports connected to this portal, i.e. the output ports of nodes connected to this portal input. Declaration IEnumerable<NodePort> GetInputSourcePorts() Returns Type Description IEnumerable<XNode.NodePort> The ports connected to this portal input."
  },
  "api/Holoride.ElasticSDK.Graph.Portals.IPortalOutputNode.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Portals.IPortalOutputNode.html",
    "title": "Interface IPortalOutputNode | ElasticSDK Documentation",
    "keywords": "Interface IPortalOutputNode Nodes implementing this interface can act as portal outputs and will be handled accordingly by GetInputSourcePorts(string). Namespace: Holoride.ElasticSDK.Graph.Portals Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public interface IPortalOutputNode Properties ElasticNodeGraph Gets the ElasticNodeGraph the Input node lives in. Declaration ElasticNodeGraph ElasticNodeGraph { get; } Property Value Type Description ElasticNodeGraph Input Gets the IPortalInputNode this output is connected to, if any. Declaration IPortalInputNode Input { get; } Property Value Type Description IPortalInputNode Methods GetOutputSinkPorts() Returns the resolved output sink ports connected to this portal, i.e. the input ports of nodes connected to this portal output. Declaration IEnumerable<NodePort> GetOutputSinkPorts() Returns Type Description IEnumerable<XNode.NodePort> The ports connected to this portal output."
  },
  "api/Holoride.ElasticSDK.Graph.Portals.PortalInputNode-1.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Portals.PortalInputNode-1.html",
    "title": "Class PortalInputNode<TData> | ElasticSDK Documentation",
    "keywords": "Class PortalInputNode<TData> Base class for all portal input nodes, taking care of common logic. Each portal type will need to sub-class a pair of this and PortalOutputNode<TData, TInputNode>. Due to Unity not supporting file-local identifiers for .cs files, implementations have to live in separate source files, so they can be assigned distinct GUIDs for serialization. Inheritance object Object ScriptableObject XNode.Node Node PortalInputNode<TData> Implements IPortalInputNode Inherited Members Node.Awake() Node.IsPortOptional(NodePort) Node.GetNodeCategoryType() Node.XNodePrettyName(Type) Node.TraverseSubGraph() Node.CallRecursive(Action<Node>, ISet<Node>) Node.ForEachOutput<T>(Action<T>) Node.GetInputSourcePorts(string) Node.GetOutputSinkPorts(string) Namespace: Holoride.ElasticSDK.Graph.Portals Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [DefaultNodeName(\"Portal Input\")] [DefaultPreviewVisibility(false)] [HelpURL(\"http://localhost:8080/articles/Procedural-Generation/Graph-Node-Overview.html#portal-input\")] public abstract class PortalInputNode<TData> : Node, IPortalInputNode where TData : Node Type Parameters Name Description TData The type of the data passed through this portal. Fields Input Defines the input port for this portal input. Declaration [SerializeField] [Node.Input(Node.ShowBackingValue.Never, Node.ConnectionType.Override, Node.TypeConstraint.Strict, false, false, Optional = false)] protected TData Input Field Value Type Description TData PortalName Defines the name of this portal. Used in the list displayed in the editor of PortalOutputNode<TData, TInputNode> to allow users to connect portal nodes. Declaration [InspectorName(\"Name\")] [SerializeField] protected string PortalName Field Value Type Description string Methods GetValue(NodePort) Returns a value based on requested port output. Declaration public override object GetValue(NodePort port) Parameters Type Name Description XNode.NodePort port The requested port. Returns Type Description object Overrides XNode.Node.GetValue(XNode.NodePort) Explicit Interface Implementations IPortalInputNode.FindOutputNodes() Returns all IPortalOutputNodes connected to this portal input. Declaration IEnumerable<IPortalOutputNode> IPortalInputNode.FindOutputNodes() Returns Type Description IEnumerable<IPortalOutputNode> The outputs connected to this input. IPortalInputNode.GetInputSourcePorts() Returns the resolved input source ports connected to this portal, i.e. the output ports of nodes connected to this portal input. Declaration IEnumerable<NodePort> IPortalInputNode.GetInputSourcePorts() Returns Type Description IEnumerable<XNode.NodePort> The ports connected to this portal input. IPortalInputNode.PortalName Gets the human readable name of the quantum link established by this portal. Declaration string IPortalInputNode.PortalName { get; } Returns Type Description string Implements IPortalInputNode"
  },
  "api/Holoride.ElasticSDK.Graph.Portals.PortalOutputNode-2.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Portals.PortalOutputNode-2.html",
    "title": "Class PortalOutputNode<TData, TInputNode> | ElasticSDK Documentation",
    "keywords": "Class PortalOutputNode<TData, TInputNode> Base class for all portal output nodes, taking care of common logic. Each portal type will need to sub-class a pair of this and PortalInputNode<TData>. Due to Unity not supporting file-local identifiers for .cs files, implementations have to live in separate source files, so they can be assigned distinct GUIDs for serialization. Inheritance object Object ScriptableObject XNode.Node Node PortalOutputNode<TData, TInputNode> Implements IPortalOutputNode Inherited Members Node.Awake() Node.IsPortOptional(NodePort) Node.GetNodeCategoryType() Node.XNodePrettyName(Type) Node.TraverseSubGraph() Node.ForEachOutput<T>(Action<T>) Node.GetInputSourcePorts(string) Node.GetOutputSinkPorts(string) Namespace: Holoride.ElasticSDK.Graph.Portals Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [DefaultNodeName(\"Portal Output\")] [HelpURL(\"http://localhost:8080/articles/Procedural-Generation/Graph-Node-Overview.html#portal-output\")] public abstract class PortalOutputNode<TData, TInputNode> : Node, IPortalOutputNode where TData : Node where TInputNode : PortalInputNode<TData> Type Parameters Name Description TData The type of the data passed through this portal. TInputNode The type of the input node this output connects to. Fields ElasticNodeGraph The graph to gather for portals. Declaration [FormerlySerializedAs(\"SourceGraph\")] [SerializeField] protected ElasticNodeGraph ElasticNodeGraph Field Value Type Description ElasticNodeGraph Methods CallRecursive(Action<Node>, ISet<Node>) Calls the given action on all inputs recursive. Declaration public override void CallRecursive(Action<Node> action, ISet<Node> visited) Parameters Type Name Description Action<Node> action The action to call on all inputs recursive. ISet<Node> visited An set that keeps track of whether a node was already visited. Overrides Node.CallRecursive(Action<Node>, ISet<Node>) GetValue(NodePort) Returns a value based on requested port output. Declaration public override object GetValue(NodePort port) Parameters Type Name Description XNode.NodePort port The requested port. Returns Type Description object Overrides XNode.Node.GetValue(XNode.NodePort) Explicit Interface Implementations IPortalOutputNode.ElasticNodeGraph Gets the ElasticNodeGraph the Input node lives in. Declaration ElasticNodeGraph IPortalOutputNode.ElasticNodeGraph { get; } Returns Type Description ElasticNodeGraph IPortalOutputNode.GetOutputSinkPorts() Returns the resolved output sink ports connected to this portal, i.e. the input ports of nodes connected to this portal output. Declaration IEnumerable<NodePort> IPortalOutputNode.GetOutputSinkPorts() Returns Type Description IEnumerable<XNode.NodePort> The ports connected to this portal output. IPortalOutputNode.Input Gets the IPortalInputNode this output is connected to, if any. Declaration IPortalInputNode IPortalOutputNode.Input { get; } Returns Type Description IPortalInputNode Implements IPortalOutputNode"
  },
  "api/Holoride.ElasticSDK.Graph.PoseSetProvider.html": {
    "href": "api/Holoride.ElasticSDK.Graph.PoseSetProvider.html",
    "title": "Class PoseSetProvider | ElasticSDK Documentation",
    "keywords": "Class PoseSetProvider Inheritance object PoseSetProvider Implements IWorkerMapper<IReadOnlyList<GlobalPose>> IWorkerMapper Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public class PoseSetProvider : IWorkerMapper<IReadOnlyList<GlobalPose>>, IWorkerMapper Properties SourceNodeType Declaration public Type SourceNodeType { get; } Property Value Type Description Type Methods Map(IPipelineWorker, GlobalPosition, CancellationToken) Declaration public UniTask<IReadOnlyList<GlobalPose>> Map(IPipelineWorker worker, GlobalPosition position, CancellationToken cancellationToken = default) Parameters Type Name Description IPipelineWorker worker GlobalPosition position CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask<T><IReadOnlyList<GlobalPose>> Map(IPipelineWorker, CancellationToken) Declaration public UniTask<IReadOnlyList<GlobalPose>> Map(IPipelineWorker worker, CancellationToken cancellationToken = default) Parameters Type Name Description IPipelineWorker worker CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask<T><IReadOnlyList<GlobalPose>> Explicit Interface Implementations IWorkerMapper.Map(IPipelineWorker, GlobalPosition, CancellationToken) Declaration UniTask<object> IWorkerMapper.Map(IPipelineWorker worker, GlobalPosition position, CancellationToken cancellationToken) Parameters Type Name Description IPipelineWorker worker GlobalPosition position CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask<T><object> IWorkerMapper.Map(IPipelineWorker, CancellationToken) Declaration UniTask<object> IWorkerMapper.Map(IPipelineWorker worker, CancellationToken cancellationToken) Parameters Type Name Description IPipelineWorker worker CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask<T><object> Implements IWorkerMapper<T> IWorkerMapper"
  },
  "api/Holoride.ElasticSDK.Graph.PoseSets.html": {
    "href": "api/Holoride.ElasticSDK.Graph.PoseSets.html",
    "title": "Namespace Holoride.ElasticSDK.Graph.PoseSets | ElasticSDK Documentation",
    "keywords": "Namespace Holoride.ElasticSDK.Graph.PoseSets Classes PoseSetNode A node that generates a PoseSetWorker that can be added to the Pipeline. PoseSetNode.PoseSetWorker<T> A worker that can be added to a Pipeline in order to generate a list of GlobalPoses during the ProcessAllAsync(GenerationContext, IProgress<float>, CancellationToken) phase."
  },
  "api/Holoride.ElasticSDK.Graph.PoseSets.PoseSetNode.html": {
    "href": "api/Holoride.ElasticSDK.Graph.PoseSets.PoseSetNode.html",
    "title": "Class PoseSetNode | ElasticSDK Documentation",
    "keywords": "Class PoseSetNode A node that generates a PoseSetWorker that can be added to the Pipeline. Inheritance object Object ScriptableObject XNode.Node Node Node<PoseSetNode> PoseSetNode Implements IPipelineNode Inherited Members Node<PoseSetNode>.Output Node<PoseSetNode>.GetValue(NodePort) Node.Awake() Node.IsPortOptional(NodePort) Node.GetNodeCategoryType() Node.XNodePrettyName(Type) Node.TraverseSubGraph() Node.CallRecursive(Action<Node>, ISet<Node>) Node.ForEachOutput<T>(Action<T>) Node.GetInputSourcePorts(string) Node.GetOutputSinkPorts(string) Namespace: Holoride.ElasticSDK.Graph.PoseSets Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [Serializable] [DefaultNodeColor(\"#329B0E\")] [HelpURL(\"http://localhost:8080/articles/Procedural-Generation/Graph-Node-Overview.html#pose-set\")] public abstract class PoseSetNode : Node<PoseSetNode>, IPipelineNode Methods GeneratePipelineWorker() Generates a pipeline worker. Declaration public abstract IPipelineWorker GeneratePipelineWorker() Returns Type Description IPipelineWorker Implements IPipelineNode"
  },
  "api/Holoride.ElasticSDK.Graph.PoseSets.PoseSetNode.PoseSetWorker-1.html": {
    "href": "api/Holoride.ElasticSDK.Graph.PoseSets.PoseSetNode.PoseSetWorker-1.html",
    "title": "Class PoseSetNode.PoseSetWorker<T> | ElasticSDK Documentation",
    "keywords": "Class PoseSetNode.PoseSetWorker<T> A worker that can be added to a Pipeline in order to generate a list of GlobalPoses during the ProcessAllAsync(GenerationContext, IProgress<float>, CancellationToken) phase. Inheritance object PipelineWorkerBase PoseSetWorker PoseSetNode.PoseSetWorker<T> Implements IPipelineWorker Inherited Members PoseSetWorker.WritePoses PoseSetWorker.ReadPoses PoseSetWorker.CallInit() PoseSetWorker.CallProcessAsync(GenerationContext, IProgress<float>, CancellationToken) PoseSetWorker.AddPose(GlobalPosition) PoseSetWorker.AddPose(GlobalPosition, Quaternion) PoseSetWorker.AddPose(GlobalPose) PoseSetWorker.AddPosesFromGeoCoordinates(IList<GeoCoordinate>, GeoCoordinate, GlobalBounds) PipelineWorkerBase.GenerationSettings PipelineWorkerBase.GenerationState PipelineWorkerBase.CurrentGenerationContext PipelineWorkerBase.Pipeline PipelineWorkerBase.IsGatheringResources PipelineWorkerBase.IsProcessing PipelineWorkerBase.Inputs PipelineWorkerBase.MissingMandatoryInputs PipelineWorkerBase.AddMissingMandatoryInput(string) PipelineWorkerBase.HasMissingMandatoryInputInHierarchy PipelineWorkerBase.AddInput(string, IPipelineWorker) PipelineWorkerBase.GetInput(string) PipelineWorkerBase.GetInput<T>(string) PipelineWorkerBase.InitResources() PipelineWorkerBase.CallInitResources() PipelineWorkerBase.Init() PipelineWorkerBase.GatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.CallGatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.ProcessAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.Dispose() PipelineWorkerBase.CleanUp() PipelineWorkerBase.CallCleanUp() Namespace: Holoride.ElasticSDK.Graph.PoseSets Assembly: Holoride.ElasticSDK.Runtime.dll Syntax protected abstract class PoseSetNode.PoseSetWorker<T> : PoseSetWorker, IPipelineWorker where T : PoseSetNode Type Parameters Name Description T The generating PoseSetNode typed Node. Constructors PoseSetWorker(T) Instantiates a PoseSetWorker. Declaration protected PoseSetWorker(T node) Parameters Type Name Description T node A back-reference to the Node that generated this worker. Fields Node A back-reference to the Node that generated this worker in order to access its serialized data. Declaration protected readonly T Node Field Value Type Description T Implements IPipelineWorker"
  },
  "api/Holoride.ElasticSDK.Graph.Spawners.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Spawners.html",
    "title": "Namespace Holoride.ElasticSDK.Graph.Spawners | ElasticSDK Documentation",
    "keywords": "Namespace Holoride.ElasticSDK.Graph.Spawners Classes PermittedAreaSpawnerNode The base class to create objects, based on some conditions. PermittedAreaSpawnerNode.PermittedAreaSpawnerWorker<T> SpawnerNode A node that creates a SpawnerWorker in order to generate objects depending on the geo location. SpawnerNode.SpawnerWorker<T> The base class to spawn objects. Interfaces ICollisionSolverSpawnerWorker Used by the CollisionSolver component when an object spawned by this worker resolves collisions with other objects spawned by this worker."
  },
  "api/Holoride.ElasticSDK.Graph.Spawners.ICollisionSolverSpawnerWorker.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Spawners.ICollisionSolverSpawnerWorker.html",
    "title": "Interface ICollisionSolverSpawnerWorker | ElasticSDK Documentation",
    "keywords": "Interface ICollisionSolverSpawnerWorker Used by the CollisionSolver component when an object spawned by this worker resolves collisions with other objects spawned by this worker. Namespace: Holoride.ElasticSDK.Graph.Spawners Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public interface ICollisionSolverSpawnerWorker Methods GetHeightAtPosition(GlobalPosition) Returns the height value ar a certain position. Declaration float GetHeightAtPosition(GlobalPosition position) Parameters Type Name Description GlobalPosition position The position to check. Returns Type Description float The height value. IsInPermittedArea(GlobalPosition) States whether the given position is within the permitted area. Declaration bool IsInPermittedArea(GlobalPosition position) Parameters Type Name Description GlobalPosition position The position to check. Returns Type Description bool Whether the the given position is within the permitted area."
  },
  "api/Holoride.ElasticSDK.Graph.Spawners.PermittedAreaSpawnerNode.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Spawners.PermittedAreaSpawnerNode.html",
    "title": "Class PermittedAreaSpawnerNode | ElasticSDK Documentation",
    "keywords": "Class PermittedAreaSpawnerNode The base class to create objects, based on some conditions. Inheritance object Object ScriptableObject XNode.Node Node Node<SpawnerNode> SpawnerNode PermittedAreaSpawnerNode Implements IPipelineNode Inherited Members SpawnerNode.Extents SpawnerNode.GeneratePipelineWorker() SpawnerNode.IsUnconstrained SpawnerNode.CellSize Node<SpawnerNode>.Output Node<SpawnerNode>.GetValue(NodePort) Node.Awake() Node.IsPortOptional(NodePort) Node.GetNodeCategoryType() Node.XNodePrettyName(Type) Node.TraverseSubGraph() Node.CallRecursive(Action<Node>, ISet<Node>) Node.ForEachOutput<T>(Action<T>) Node.GetInputSourcePorts(string) Node.GetOutputSinkPorts(string) Namespace: Holoride.ElasticSDK.Graph.Spawners Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [NodePath(new string[] { \"Spawners\", \"PermittedAreaSpawnerNode\" })] public abstract class PermittedAreaSpawnerNode : SpawnerNode, IPipelineNode Fields Heightmap The map that defines the height of the spawned object. Declaration [Tooltip(\"The map that defines the height of the spawned object.\")] [SerializeField] [FormerlySerializedAs(\"heightMap\")] [Node.Input(Node.ShowBackingValue.Never, Node.ConnectionType.Override, Node.TypeConstraint.Strict, false, false, Optional = true)] protected MapNode Heightmap Field Value Type Description MapNode PermittedAreaThreshold Spawn candidates at PermittedArea values below this threshold are discarded and will not get spawned. Declaration [Tooltip(\"Spawn candidates at PermittedArea values below this threshold are discarded and will not get spawned.\")] [SerializeField] protected float PermittedAreaThreshold Field Value Type Description float Implements IPipelineNode"
  },
  "api/Holoride.ElasticSDK.Graph.Spawners.PermittedAreaSpawnerNode.PermittedAreaSpawnerWorker-1.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Spawners.PermittedAreaSpawnerNode.PermittedAreaSpawnerWorker-1.html",
    "title": "Class PermittedAreaSpawnerNode.PermittedAreaSpawnerWorker<T> | ElasticSDK Documentation",
    "keywords": "Class PermittedAreaSpawnerNode.PermittedAreaSpawnerWorker<T> Inheritance object PipelineWorkerBase SpawnerWorker SpawnerNode.SpawnerWorker<T> PermittedAreaSpawnerNode.PermittedAreaSpawnerWorker<T> Implements IPipelineWorker IShiftParent ICollisionSolverSpawnerWorker Inherited Members SpawnerNode.SpawnerWorker<T>.Node SpawnerNode.SpawnerWorker<T>.ShiftParent SpawnerNode.SpawnerWorker<T>.InstantiateAndInject(GameObject, Vector3, Quaternion, SpawnCandidate, float, CancellationToken) SpawnerNode.SpawnerWorker<T>.InitializeInstance(GameObject, SpawnCandidate, CancellationToken) SpawnerNode.SpawnerWorker<T>.DestroyCell(IEnumerable<GameObject>) SpawnerWorker.CellSize SpawnerWorker.Extents SpawnerWorker.IsUnconstrained SpawnerWorker.OnGameObjectsCreated SpawnerWorker.QuantityInitEstimation SpawnerWorker.CallInit() SpawnerWorker.Dispose() SpawnerWorker.DiscreteRadius SpawnerWorker.Bounds SpawnerWorker.CellKeyToBounds(Vector2Int) SpawnerWorker.SpawnCell(Vector2Int, IList<GameObject>, CancellationToken) SpawnerWorker.MoveSpawnPosition(GlobalPosition, CancellationToken) SpawnerWorker.EvaluateSpawnCandidate(int, GlobalPosition, CancellationToken) SpawnerWorker.ComputeCellKeyFromPosition(GlobalPosition) SpawnerWorker.DestroyAllCells() PipelineWorkerBase.GenerationSettings PipelineWorkerBase.GenerationState PipelineWorkerBase.CurrentGenerationContext PipelineWorkerBase.Pipeline PipelineWorkerBase.IsGatheringResources PipelineWorkerBase.IsProcessing PipelineWorkerBase.Inputs PipelineWorkerBase.MissingMandatoryInputs PipelineWorkerBase.AddMissingMandatoryInput(string) PipelineWorkerBase.HasMissingMandatoryInputInHierarchy PipelineWorkerBase.AddInput(string, IPipelineWorker) PipelineWorkerBase.GetInput(string) PipelineWorkerBase.GetInput<T>(string) PipelineWorkerBase.InitResources() PipelineWorkerBase.CallInitResources() PipelineWorkerBase.GatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.CallGatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.ProcessAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.CallProcessAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.CleanUp() PipelineWorkerBase.CallCleanUp() Namespace: Holoride.ElasticSDK.Graph.Spawners Assembly: Holoride.ElasticSDK.Runtime.dll Syntax protected abstract class PermittedAreaSpawnerNode.PermittedAreaSpawnerWorker<T> : SpawnerNode.SpawnerWorker<T>, IPipelineWorker, IShiftParent, ICollisionSolverSpawnerWorker where T : PermittedAreaSpawnerNode Type Parameters Name Description T Constructors PermittedAreaSpawnerWorker(T) Declaration protected PermittedAreaSpawnerWorker(T node) Parameters Type Name Description T node Fields HeightMapWorker The worker the heightmap input node attached to the pipeline. Declaration protected MapWorker HeightMapWorker Field Value Type Description MapWorker PermittedAreaWorker The worker the permitted area input node attached to the pipeline. Declaration protected MapWorker PermittedAreaWorker Field Value Type Description MapWorker Properties MayUpdateMovingGrid Declaration protected override bool MayUpdateMovingGrid { get; } Property Value Type Description bool Overrides SpawnerWorker.MayUpdateMovingGrid Methods GetHeightAtPosition(GlobalPosition) Returns the height value ar a certain position. Declaration public float GetHeightAtPosition(GlobalPosition position) Parameters Type Name Description GlobalPosition position The position to check. Returns Type Description float The height value. Init() Initializes this worker when generation starts. Declaration public override void Init() Overrides PipelineWorkerBase.Init() IsInPermittedArea(GlobalPosition) States whether the given position is within the permitted area. Declaration public bool IsInPermittedArea(GlobalPosition position) Parameters Type Name Description GlobalPosition position The position to check. Returns Type Description bool Whether the the given position is within the permitted area. SolveCollision(GameObject) Solves the collision depending on the MovingGridOfGameObjects CollisionSolver component. Declaration protected void SolveCollision(GameObject gameObject) Parameters Type Name Description GameObject gameObject The GameObject whose collision to solve. Implements IPipelineWorker IShiftParent ICollisionSolverSpawnerWorker"
  },
  "api/Holoride.ElasticSDK.Graph.Spawners.SpawnerNode.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Spawners.SpawnerNode.html",
    "title": "Class SpawnerNode | ElasticSDK Documentation",
    "keywords": "Class SpawnerNode A node that creates a SpawnerWorker in order to generate objects depending on the geo location. Inheritance object Object ScriptableObject XNode.Node Node Node<SpawnerNode> SpawnerNode PermittedAreaSpawnerNode Implements IPipelineNode Inherited Members Node<SpawnerNode>.Output Node<SpawnerNode>.GetValue(NodePort) Node.Awake() Node.IsPortOptional(NodePort) Node.GetNodeCategoryType() Node.XNodePrettyName(Type) Node.TraverseSubGraph() Node.CallRecursive(Action<Node>, ISet<Node>) Node.ForEachOutput<T>(Action<T>) Node.GetInputSourcePorts(string) Node.GetOutputSinkPorts(string) Namespace: Holoride.ElasticSDK.Graph.Spawners Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [Serializable] [DefaultNodeColor(\"#FF00DD\")] [HelpURL(\"http://localhost:8080/articles/Procedural-Generation/Graph-Node-Overview.html#spawner\")] public abstract class SpawnerNode : Node<SpawnerNode>, IPipelineNode Fields Extents The edge length of the square region around the player's position where objects get spawned. Declaration [Tooltip(\"The edge length of the square region around the player's position where objects get spawned.\")] [FormerlySerializedAs(\"extents\")] [SerializeField] protected float Extents Field Value Type Description float Properties CellSize Gets the edge length of each squared cell. Declaration protected virtual double CellSize { get; } Property Value Type Description double IsUnconstrained Gets a value indicating whether the extents of this spawner are always unclamped. Declaration public virtual bool IsUnconstrained { get; } Property Value Type Description bool Methods GeneratePipelineWorker() Generates a pipeline worker. Declaration public abstract IPipelineWorker GeneratePipelineWorker() Returns Type Description IPipelineWorker Implements IPipelineNode"
  },
  "api/Holoride.ElasticSDK.Graph.Spawners.SpawnerNode.SpawnerWorker-1.html": {
    "href": "api/Holoride.ElasticSDK.Graph.Spawners.SpawnerNode.SpawnerWorker-1.html",
    "title": "Class SpawnerNode.SpawnerWorker<T> | ElasticSDK Documentation",
    "keywords": "Class SpawnerNode.SpawnerWorker<T> The base class to spawn objects. Inheritance object PipelineWorkerBase SpawnerWorker SpawnerNode.SpawnerWorker<T> PermittedAreaSpawnerNode.PermittedAreaSpawnerWorker<T> Implements IPipelineWorker IShiftParent Inherited Members SpawnerWorker.CellSize SpawnerWorker.Extents SpawnerWorker.IsUnconstrained SpawnerWorker.OnGameObjectsCreated SpawnerWorker.QuantityInitEstimation SpawnerWorker.MayUpdateMovingGrid SpawnerWorker.CallInit() SpawnerWorker.Dispose() SpawnerWorker.DiscreteRadius SpawnerWorker.Bounds SpawnerWorker.CellKeyToBounds(Vector2Int) SpawnerWorker.SpawnCell(Vector2Int, IList<GameObject>, CancellationToken) SpawnerWorker.MoveSpawnPosition(GlobalPosition, CancellationToken) SpawnerWorker.EvaluateSpawnCandidate(int, GlobalPosition, CancellationToken) SpawnerWorker.ComputeCellKeyFromPosition(GlobalPosition) SpawnerWorker.DestroyAllCells() PipelineWorkerBase.GenerationSettings PipelineWorkerBase.GenerationState PipelineWorkerBase.CurrentGenerationContext PipelineWorkerBase.Pipeline PipelineWorkerBase.IsGatheringResources PipelineWorkerBase.IsProcessing PipelineWorkerBase.Inputs PipelineWorkerBase.MissingMandatoryInputs PipelineWorkerBase.AddMissingMandatoryInput(string) PipelineWorkerBase.HasMissingMandatoryInputInHierarchy PipelineWorkerBase.AddInput(string, IPipelineWorker) PipelineWorkerBase.GetInput(string) PipelineWorkerBase.GetInput<T>(string) PipelineWorkerBase.InitResources() PipelineWorkerBase.CallInitResources() PipelineWorkerBase.Init() PipelineWorkerBase.GatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.CallGatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.ProcessAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.CallProcessAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.CleanUp() PipelineWorkerBase.CallCleanUp() Namespace: Holoride.ElasticSDK.Graph.Spawners Assembly: Holoride.ElasticSDK.Runtime.dll Syntax protected abstract class SpawnerNode.SpawnerWorker<T> : SpawnerWorker, IPipelineWorker, IShiftParent where T : SpawnerNode Type Parameters Name Description T The generating node type deriving from Spawner. Constructors SpawnerWorker(T, bool) Instantiates the worker. Declaration protected SpawnerWorker(T node, bool isUnconstrained) Parameters Type Name Description T node A back reference to the node that created this worker. bool isUnconstrained Whether this spawner uses unconstrained extents. SpawnerWorker(T) Instantiates the worker. Declaration protected SpawnerWorker(T node) Parameters Type Name Description T node A back reference to the node that created this worker. Fields Node A reference to the node that generated this worker in order to access its serialized data. Declaration protected readonly T Node Field Value Type Description T Properties ShiftParent Gets or sets the GameObject that's parent to spawned GameObjects. Declaration public GameObject ShiftParent { get; set; } Property Value Type Description GameObject Methods DestroyCell(IEnumerable<GameObject>) Destroys all objects within a cell by destroying them. Override this function to treat disappearing objects differently, e.g. to return them to an object pool. Declaration public override void DestroyCell(IEnumerable<GameObject> gameObjects) Parameters Type Name Description IEnumerable<GameObject> gameObjects The game objects to destroy. Overrides SpawnerWorker.DestroyCell(IEnumerable<GameObject>) InitializeInstance(GameObject, SpawnCandidate, CancellationToken) Perform early initialization of a spawned instance. This allows configuration before the instances Awake/OnEnable/RetrievedFromPool is called. Declaration protected virtual UniTask InitializeInstance(GameObject instance, SpawnCandidate candidate, CancellationToken cancellationToken) Parameters Type Name Description GameObject instance The instance to initialize. SpawnCandidate candidate The spawn candidate the instance was created for. CancellationToken cancellationToken Token to cancel the async UniTask operation. Returns Type Description Cysharp.Threading.Tasks.UniTask InstantiateAndInject(GameObject, Vector3, Quaternion, SpawnCandidate, float, CancellationToken) Utility method to create an instance from a prefab that gets filled with the dynamic port data from the node graph (if it requested any). Declaration protected UniTask<GameObject> InstantiateAndInject(GameObject prefab, Vector3 position, Quaternion rotation, SpawnCandidate candidate, float scale = 1, CancellationToken cancellationToken = default) Parameters Type Name Description GameObject prefab The prefab to be instantiated. Vector3 position The position of the instantiated prefab. Quaternion rotation The rotation of the instantiated prefab. SpawnCandidate candidate The spawn candidate the instance was created for. float scale The optional scale of the prefab. CancellationToken cancellationToken Token to cancel the async UniTask operation. Returns Type Description Cysharp.Threading.Tasks.UniTask<T><GameObject> The created instance. Implements IPipelineWorker IShiftParent"
  },
  "api/Holoride.ElasticSDK.Graph.XNodePipelineAssembler.html": {
    "href": "api/Holoride.ElasticSDK.Graph.XNodePipelineAssembler.html",
    "title": "Class XNodePipelineAssembler | ElasticSDK Documentation",
    "keywords": "Class XNodePipelineAssembler Assembles a pipeline from a XNode sub-graph consisting of interconnected IPipelineWorkers. Inheritance object XNodePipelineAssembler Implements IPipelineAssembler Namespace: Holoride.ElasticSDK.Graph Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public class XNodePipelineAssembler : IPipelineAssembler Constructors XNodePipelineAssembler(IEnumerable<Node>) Declaration public XNodePipelineAssembler(IEnumerable<Node> nodes) Parameters Type Name Description IEnumerable<Node> nodes The nodes to assemble the pipeline from. Will traverse the graph starting from these nodes, following their inputs. Properties GeneratedNodeWorkers Gets a mapping of nodes to the workers that were generated for them. Declaration public Dictionary<IPipelineNode, IPipelineWorker> GeneratedNodeWorkers { get; } Property Value Type Description Dictionary<IPipelineNode, IPipelineWorker> Methods AssemblePipeline(GenerationSettings, GenerationState) Gathers all pipeline nodes. Declaration public Pipeline AssemblePipeline(GenerationSettings generationSettings, GenerationState generationState) Parameters Type Name Description GenerationSettings generationSettings The GenerationSettings that contains immutable data that cannot be changed during the whole generation loop. GenerationState generationState The GenerationState that contains the current state of the generation process and will be updated over time. Returns Type Description Pipeline Implements IPipelineAssembler"
  },
  "api/Holoride.ElasticSDK.Holofile.html": {
    "href": "api/Holoride.ElasticSDK.Holofile.html",
    "title": "Class Holofile | ElasticSDK Documentation",
    "keywords": "Class Holofile Asset representation of a .holo file. Inheritance object Object ScriptableObject Holofile Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [HelpURL(\"http://localhost:8080/api/Holoride.ElasticSDK.Holofile.html\")] public class Holofile : ScriptableObject Fields Records List of all records in the .holo file, in sequential order. Declaration public Holofile.Record[] Records Field Value Type Description Record[]"
  },
  "api/Holoride.ElasticSDK.Holofile.Record.html": {
    "href": "api/Holoride.ElasticSDK.Holofile.Record.html",
    "title": "Struct Holofile.Record | ElasticSDK Documentation",
    "keywords": "Struct Holofile.Record Single record of a .holo file. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [Serializable] public struct Holofile.Record Fields Data Key-value data from the .holo file, flattened for asset serialization. Declaration public VehicleSensorState Data Field Value Type Description VehicleSensorState Microseconds Duration of this record. In other words, the duration for which the data in this record remains valid before the data of the next record should be loaded. Declaration public long Microseconds Field Value Type Description long"
  },
  "api/Holoride.ElasticSDK.html": {
    "href": "api/Holoride.ElasticSDK.html",
    "title": "Namespace Holoride.ElasticSDK | ElasticSDK Documentation",
    "keywords": "Namespace Holoride.ElasticSDK Classes BaseRotation BufferPair<T> A pair of equally sized CPU and GPU buffers. BufferPairExtensions CacheAnnotatedMethodsAttribute CacheSubTypesAttribute CameraRigParentRotation CollectionExtensions Utility extensions for collections. ContextProviderAttribute Declares that the annotated IContextProvider provides the context type specified in this attribute. This is used to automatically attach instances of this provider to systems that execute a Pipeline consuming the context provided by this provider. DataProviderWorker<TDataType> The worker with a back reference to the node. Represents the result of the different evaluations of structs. DefaultRequestAttribute The class implementing this interface is the default subtype. A random subtype is returned in the undefined case of multiple IDefault implementations of the same base type. ElasticObjectPoolDefaultSettings ElasticObjectPoolManager Default object pooling implementation using the PooledObject component to mark prefabs for object pooling. ElasticObjectPoolSettings ElasticSceneGenerator This class produces a realized scene from a Graph.ElasticSceneDefinitionNode for the current center location (specified via GenerationOrigin). In addition to running any spawners in the defined scene definition, this entails generation of a Terrain if a height map has been specified. During movement of the player, the generator takes care that the generated terrain and any spawned objects get refreshed. For the terrain, this means re-creating the current terrain area when the player moves past a threshold. For spawned objects, this means updating their spawners, so they may discard instances that have gone out of range and instantiate new spawn candidates that have come in range. The TerrainGenerator maintains all the basic information about the terrain like the different resolutions of the heightmap, the alphamaps, the base map and the spawn areas. Also the general extents of the resulting terrain are defined here. ExtensibleObject<TBase> Derived objects can be extended by fields and functions. Extending classes need to be derivations from Supertype. FileUtils FixedPositionStateReceiverBackend FloatingPlatform FrameBudgetTask Provides frame budget observing tasks. GenerationContext Contains the immutable meta-information of a single update iteration. Will be discarded when the update is done but can be kept by functions that need information about former iterations - such as async operations that may last longer than an update period. GenerationSettings Contains immutable data that cannot be changed during the whole generation loop. GenerationState Contains the current state of the generation process and will be updated over time. GlobalSettings Contains globally accessible values. Holofile Asset representation of a .holo file. InitializeAfterSingletonsMethodAttribute IntervalAttribute Controls the property drawer for Interval fields. KeyValuePairExtensions LocalizationEvents Maneuver Representation of possible maneuvers. MapUtils A collection of useful map functions. MapWorker Represents the result of the different evaluation of a 2D float buffer, based on the used filter implementation, through accessing the ram/v-ram. Also manages compute shader calls. MeshUtils MovingGrid<T> A data structure that provides a two-dimensional local grid of cells with reference to a global position. The grid position is intended to move and therefore free all cells that don't overlap with the target area. NewtonsoftJsonVulnFix NullStateReceiverBackend A backend that does nothing. Useful as an override to disable automatic backend behavior, e.g. when running tests. PatternDescriptorProperties<T> This class defines additional PatternDescriptorProperties. Pipeline A Pipeline consists of a list of IPipelineWorker that consecutively process the data in each generation update phase. Pipeline.CyclicGraphException Pipeline.MissingInputException PipelineWorkerBase Player The data obtained by the vehicle sensors. Player.VehicleLocalizationStatusUnityEvent PooledObject Component used to mark GameObjects as poolable by the ElasticObjectPoolManager, and with which settings to pool them. The settings are grabbed from the original prefab. On instances of the prefab, this component is used to track the pool the instance originated from, so that it can be returned to it on release. PoseSetWorker A worker that can be added to a Pipeline in order to generate a list of GlobalPoses during the phase. PrefabInstantiationContext Context common to all prefab instantiation implementations, exposing them to IPipelineWorkers. RasterizationUtils A collection of useful rasterization helpers. RecenterOffsetManager Access to current recenter offset, i.e. the delta between headset forward direction and vehicle forward direction. This is relevant for headsets using 3-DoF tracking, since their tracking frame of reference is not local to the vehicle (as opposed to 6-dof), but in the same global space as the vehicle itself. We manage this offset manually to ensure consistent compatibility across different headsets. For some there is no event to be notified when the user caused a system-driven recenter, for others there is no API to trigger a system-driven recenter. This manages the application local recenter offset, which may be different to the global recenter offset shared across multiple applications. This is due to the fact that the application of the recenter offset depends on localization data, specifically the vehicle heading. While the vehicle heading is not available, we must operate in an application local state, to still allow users to recenter. As such, we must be able to operate in the two states \"heading available\" and \"heading unavailable\". For the former, behavior is trivial, since we can apply new global recenter offset directly (sent from either drift mitigation, system driven user recenter logic, user recenter in other applications) and directly apply new global offset values. The \"heading unavailable\" state is more complex, as it introduces the need for temporary, local recenter offset values, while still: keeping the last received global recenter offset so it can be applied as soon as global vehicle heading is available. keeping the local vehicle heading when applying a local recenter offset so we can compute the delta to the global recenter offset as soon as global vehicle heading is available. Once global vehicle heading becomes available, we can transform the pending global or local recenter offset, depending on which one is more recent: local to global: add delta of local vehicle heading at time of setting local recenter offset to global vehicle heading. global to local: instantly apply pending global recenter offset. The intuition here is that the global vehicle heading will be used once available, so the local heading \"snaps\" to the the global one, and as such any values computed in relation to it have to be adjusted as well. Whereas the global recenter offset is already in relation to the global vehicle heading. Replay A replay is a generic representation of some recorded data that may be used to simulate a ride. ReplayStateReceiverBackend Receives .holo file state. ReplayStream Base implementation for IReplayStream taking care of some boilerplate. RequireGenerationContextAttribute Used to annotate workers which require some implementation of IGenerationContext. This is used to only generate and compute these context implementations when any node in the graph actually uses them. RingBufferFilter<T> Uses a queue to Shift: For every enqueued value, dequeue is called until the maxSampleCount is reached. RouteGeometryBender Bends the given renderer and collision mesh along the route spline, after it got spawned by a RouteIntervalSpawner. RouteSegments A route segment defining spawn intervals. RouteTraveller Controls the movement of the GameObject along the route. RuntimeInitializeAfterSingletonsMethodAttribute SensorDataInterpolator Utility class used to interpolate sensor data e.g. when data frequency is too low for the current frame rate, which may result in stutters otherwise. ServiceStateReceiverBackend Connector for receiving localization data the holoride service. SharedGeoCoordinate A SharedGeoCoordinate that can be used to synchronize pivot depending objects. Singleton<T> SingletonBase SparseCellDataStructure<TSourceKey, TDataValue> An hierarchical dataValue structure to store dataValues. SpawnCandidate A spawn candidate is asynchronously created on every terrain update covering the full extents of the TerrainCanvas. As the player gets closer to the candidate than the extents of the spawner, the actual GameObject is instantiated. By deriving from this class, information can be passed from the DefinePoses to the CreateObject method of the Spawner. SpawnCandidateStructure<TSource> An hierarchical data structure to store spawn candidates. SpawnerWorker The base class to spawn objects. Spline A spline class to provide infinitesimal pose information on a path defined by discrete positions. StateReceiver This is the central data source for localization data and any other data provided by StateReceiverBackends. StateReceiverBackend Backend implementation for the StateReceiver. Implementations of this class represent connections to actual underlying data sources for vehicle localization etc. These may either we be annotated with StateReceiverBackendAttribute to be automatically added to the StateReceiver, or can be added via the inspector. StateReceiverBackendAttribute Implementations of StateReceiverBackend annotated with this attribute will be made available in the StateReceiver. Alternatively, providers can be manually assigned in the StateReceiver. StateReceiverBackendSelector Manages the StateReceiverBackend assigned to CurrentBackend. StateReceiverEventListenerAdapter StateRecorder Utility component that can be used to record state received by StateReceiverBackends into a file that may later be used for playing the state back using the ReplayStateReceiverBackend. Recording is automatically stopped when the component is disabled. StationaryModeEvents StringUnityEvent StylizedVehicleRotation TerrainCanvas Once it is created by the ElasticSceneGenerator the TerrainCanvas takes care of all the different steps, that need to be done to create the terrain. Traversing over all filter trees to evaluate and generate the height-, texture- and spawnArea maps and creating the actual Terrain out of precomputed terrainData. TerrainGenerationSettings Contains immutable data that cannot be changed during the whole generation loop regarding terrain specific features. TerrainGenerationState The GenerationContext extension for terrain-related generation. TickBasedMeshPool This class provides a pool of meshes that assumes most meshes are requested when needed and all are returned after being used. TileAreaDescription Manages the distribution of tiles of a certain zoom level within the given bounds. TileDataCache Utilities for interacting with the application's tiled data cache. TileDataCacheFormatVersionAttribute TileDataManager<T> Manages the loading and unloading of data tiles. TileDataService TileDataService<T> Downloads and caches tiles to the hard drive. TileDataServiceConfiguration Groups configuration values passed to TileDataService<T> instances used when running a Pipeline. Different configuration values may be used in a regular pipeline run versus tests, editor tooling and so on. TileDataServiceConfigurationUtils TileImageServiceRoadMask Downloads RoadMask tiles and deserializes them into textures. TileTextureManager The base class of a TileTextureManager holds all important information about the tiles that should get downloaded. Resulting from the zoom level and the tile position it creates the correct key to download the correct tile. TypeCacheSingleton TypeExtensions UniTaskUtils Utility calls to workaround some UniTask inconveniences. Utils A collection of useful functions without a specific object context. Vector3Extensions Various extension methods for the Vector3 type. VehiclePosition VehicleRotation WorkerGroupAttribute Allows grouping workers into named groups. This is used to limit the maximum count of some particular node type in graphs, for example. WorldShiftManager This class moves all transforms generated by the ElasticSceneGenerator, under any listed Holoride.ElasticSDK.WorldShiftManager.ShiftParents as well as the game object itself towards the center of the coordinate system. This shift is mandatory to prevent floating point inaccuracies when moving along real world localization data that is mapped to engine units. WorldShiftManager.OriginShiftEvent Implements a special case of a UnityEvent as a OriginShiftEvent. The first template argument is the shift vector all objects are moved along. Structs GeoCoordinate Stores latitude, longitude and altitude of a geo coordinate and performs conversion to cartesian. GlobalBounds Creates min and max latitude and longitude to define an area. Mind that this area is not a square or a rectangle on the earth surface. However, smaller areas which are closer to the equator approximate a rectangular shape. GlobalPose Stores a position with double precision and a look rotation. GlobalPosition A vector3 representation that supports double precision. Holofile.Record Single record of a .holo file. Interval Defines an interval. SpeedSegment Segments along the route defined by the distance and speed category. TravelInformationState The TravelInformation state contains information based on the current location and route driven such as the estimated time to arrival. VehicleSensorState The data obtained by the vehicle sensors. Interfaces IContextProvider Contract of MonoBehaviours that act as context providers. Context providers offer a means of flexibly registering additional context types with systems that execute Pipelines, such as the Elastic Scene Generator. Workers may indicate that they require a specific context using the RequireGenerationContextAttribute. If a context provider is using the ContextProviderAttribute, it will may be automatically added to systems that execute Pipelines requiring the context they provide. IElasticObjectPoolSettings IExecutionPriority IGenerationContext The interface to extend the GenerationContext from other modules. IGenerationState The interface to extend the GenerationState from other modules. IPatternDescriptor<T> The interface to define a PatternDescriptor for pattern recognition. IPipelineAssembler Assembles a pipeline and connects depending input workers. IPipelineContainer Can be implemented by MonoBehaviors to provide a Pipeline for external use, e.g. to show respective node previews. IPipelineNode A node that generates a PipelineWorker. IPipelineWorker An interface to define an element of a pipeline with its lifecycle methods and Inputs. IPrefabInstantiationProvider Contract for a prefab instantiation strategy. Implementations of this interface must be MonoBehaviours attached to the ElasticSceneGenerator and provide a PrefabInstantiationContext to the pipeline to be used by IPipelineWorkers that need to instantiate prefabs. IPreprocessingGenerationContext Specialization of IGenerationContext with callbacks for (asynchronous) initialization prior to a Pipeline run. IRecenterOffsetManagerBackend Platform specific implementation details of the RecenterOffsetManager. IReplayStream A IReplayStream allows iterating over an underlying Replay implementation in a well-defined manner. IRoute ISettingsProvider Contract of MonoBehaviours that act as settings providers. Settings providers offer a means of flexibly registering additional setting extensions with the GenerationSettings used in a Pipeline. ISharedGeoCoordinate A shared GeoCoordinate that can be used to synchronize pivot depending objects. IShiftParent IStateReceiverListener IStateReceiverLocalizationEventListener ITileDataProvider<T> Defines an interface to request tile data. ITileDataService<T> Downloads and caches tiles to the hard drive. Enums BaseRotation.RotationAxes DataRegion GlobalSettings.TrackingReference LoadResourceResult The type of a resource load operation. LocalizationMode Maneuver.ActionType Defines the different actions of a maneuver. Maneuver.DirectionType Defines the different directions of a maneuver. RasterizationUtils.DrawStyle SpeedCategory Major speed categories. StateReceiverBackendAttribute.Platform StateReceiverInitializationError Error states that may occur during StateReceiver initialization, typically while connecting to a required service. StateReceiverState The possible global states of the StateReceiver. VehicleLocalizationStatus Different types of vehicle localization state. Delegates SparseCellDataStructure<TSourceKey, TDataValue>.DataValueToCellKeyDelegate The function delegate to convert a dataValue into a cell key. SpawnCandidateStructure<TSource>.PositionToCellKeyDelegate The function delegate to convert a position into a cell key. StateReceiver.BackendChangedHandler Event handler for the OnBackendChanged event. Takes a StateReceiverBackend argument."
  },
  "api/Holoride.ElasticSDK.IContextProvider.html": {
    "href": "api/Holoride.ElasticSDK.IContextProvider.html",
    "title": "Interface IContextProvider | ElasticSDK Documentation",
    "keywords": "Interface IContextProvider Contract of MonoBehaviours that act as context providers. Context providers offer a means of flexibly registering additional context types with systems that execute Pipelines, such as the Elastic Scene Generator. Workers may indicate that they require a specific context using the RequireGenerationContextAttribute. If a context provider is using the ContextProviderAttribute, it will may be automatically added to systems that execute Pipelines requiring the context they provide. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public interface IContextProvider Properties IsDirty Gets a value indicating whether data provided by this context has changed and requires the Pipeline using this context needs to run again. Declaration bool IsDirty { get; } Property Value Type Description bool Methods ProvideContextAsync(GenerationSettings, GenerationContext, ISet<Type>, CancellationToken) Adds the IGenerationContext instances provided by this provider to the specified GenerationContext as an extension. To add IGenerationSettings instances to the passed GenerationSettings instance, use an ISettingsProvider. Declaration UniTask ProvideContextAsync(GenerationSettings settings, GenerationContext context, ISet<Type> requiredContextTypes, CancellationToken cancellationToken = default) Parameters Type Name Description GenerationSettings settings The global generation settings used. GenerationContext context The context to add the provided extension contexts to. ISet<Type> requiredContextTypes The set of context types that workers in the pipeline the context is being built for require. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask Optional enumerator in case context initialization must run asynchronously."
  },
  "api/Holoride.ElasticSDK.IElasticObjectPoolSettings.html": {
    "href": "api/Holoride.ElasticSDK.IElasticObjectPoolSettings.html",
    "title": "Interface IElasticObjectPoolSettings | ElasticSDK Documentation",
    "keywords": "Interface IElasticObjectPoolSettings Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public interface IElasticObjectPoolSettings Properties InitPoolSize Gets or sets the initial amount of instances the spawning pool is going to be instantiated with. Declaration int InitPoolSize { get; set; } Property Value Type Description int MaxInitFrames Gets or sets the maximum amount of frames taken to instantiate initial spawning pool. Declaration int MaxInitFrames { get; set; } Property Value Type Description int MaxPoolSize Gets or sets the maximum amount of instances the spawning pool is going to create. Supports runtime change. Declaration int MaxPoolSize { get; set; } Property Value Type Description int"
  },
  "api/Holoride.ElasticSDK.IExecutionPriority.html": {
    "href": "api/Holoride.ElasticSDK.IExecutionPriority.html",
    "title": "Interface IExecutionPriority | ElasticSDK Documentation",
    "keywords": "Interface IExecutionPriority Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public interface IExecutionPriority Properties ExecutionPriority Declaration int ExecutionPriority { get; set; } Property Value Type Description int"
  },
  "api/Holoride.ElasticSDK.IGenerationContext.html": {
    "href": "api/Holoride.ElasticSDK.IGenerationContext.html",
    "title": "Interface IGenerationContext | ElasticSDK Documentation",
    "keywords": "Interface IGenerationContext The interface to extend the GenerationContext from other modules. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public interface IGenerationContext"
  },
  "api/Holoride.ElasticSDK.IGenerationState.html": {
    "href": "api/Holoride.ElasticSDK.IGenerationState.html",
    "title": "Interface IGenerationState | ElasticSDK Documentation",
    "keywords": "Interface IGenerationState The interface to extend the GenerationState from other modules. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public interface IGenerationState"
  },
  "api/Holoride.ElasticSDK.InitializeAfterSingletonsMethodAttribute.html": {
    "href": "api/Holoride.ElasticSDK.InitializeAfterSingletonsMethodAttribute.html",
    "title": "Class InitializeAfterSingletonsMethodAttribute | ElasticSDK Documentation",
    "keywords": "Class InitializeAfterSingletonsMethodAttribute Inheritance object Attribute InitializeAfterSingletonsMethodAttribute Implements IExecutionPriority Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Method)] [MeansImplicitUse] public sealed class InitializeAfterSingletonsMethodAttribute : Attribute, IExecutionPriority Properties ExecutionPriority Declaration public int ExecutionPriority { get; set; } Property Value Type Description int Implements IExecutionPriority"
  },
  "api/Holoride.ElasticSDK.Interval.html": {
    "href": "api/Holoride.ElasticSDK.Interval.html",
    "title": "Struct Interval | ElasticSDK Documentation",
    "keywords": "Struct Interval Defines an interval. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [Serializable] public struct Interval Constructors Interval(double, double) Initializes a new instance of the Interval class. If max smaller than min, it is set to the value of min instead. Declaration public Interval(double min, double max) Parameters Type Name Description double min The start of the interval. double max The end of the interval. Fields Max The maximum value of the interval. This value is greater than or equal to Min when this struct was initialized using its constructor. Declaration [FormerlySerializedAs(\"max\")] public double Max Field Value Type Description double Min The minimum value of the interval. This value is smaller than or equal to Max when this struct was initialized using its constructor. Declaration [FormerlySerializedAs(\"min\")] public double Min Field Value Type Description double Methods Contains(Interval) Checks whether this interval completely contains the specified interval. Declaration public bool Contains(Interval other) Parameters Type Name Description Interval other The other interval. Returns Type Description bool Whether this interval completely contains the specified interval. Contains(double) Tests whether this interval contains the specified value. Declaration public bool Contains(double value) Parameters Type Name Description double value The value to check for. Returns Type Description bool Whether this interval contains the specified value. CreateClamped01(double, double) Creates a new interval that is clamped to the range of [0, 1]. Declaration public static Interval CreateClamped01(double min, double max) Parameters Type Name Description double min The start of the interval. double max The end of the interval. Returns Type Description Interval The interval for the specified range. Deconstruct(out double, out double) Declaration public void Deconstruct(out double min, out double max) Parameters Type Name Description double min double max Equals(Interval) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(Interval other) Parameters Type Name Description Interval other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Determines whether the specified object is equal to the current object. Declaration public override bool Equals(object obj) Parameters Type Name Description object obj The object to compare with the current object. Returns Type Description bool true if the specified object is equal to the current object; otherwise, false. Overrides ValueType.Equals(Object) GetBounds(Interval, Interval) Creates a new intervals, consisting of the boundaries of two given intervals. Declaration public static Interval GetBounds(Interval a, Interval b) Parameters Type Name Description Interval a The first interval. Interval b The second interval. Returns Type Description Interval New interval, consisting of the boundaries of the two given intervals. GetHashCode() Declaration public override int GetHashCode() Returns Type Description int Overrides ValueType.GetHashCode() GetRandomValue(Random) Generates a random value within this interval. Declaration public float GetRandomValue(Random random) Parameters Type Name Description Random random Returns Type Description float Lerp(double) Linearly interpolates between Min and Max by t with no limit to t. Declaration public double Lerp(double t) Parameters Type Name Description double t The interpolation between the two points defining this interval. Returns Type Description double The double value as a result from the linear interpolation. Lerp(float) Linearly interpolates between Min and Max by t with no limit to t. Declaration public float Lerp(float t) Parameters Type Name Description float t The interpolation between the two points defining this interval. Returns Type Description float The float value as a result from the linear interpolation. Overlaps(Interval) Checks whether this interval and the specified interval overlap. Declaration public bool Overlaps(Interval other) Parameters Type Name Description Interval other The other interval. Returns Type Description bool Whether this interval and the specified interval overlap. ToString() Returns a string that represents the current object. Declaration public override string ToString() Returns Type Description string A string that represents the current object. Overrides ValueType.ToString() TryIntersect(Interval, Interval, out Interval) Computes the interval representing the intersect of the specified intervals. Declaration public static bool TryIntersect(Interval intervalA, Interval intervalB, out Interval intersection) Parameters Type Name Description Interval intervalA The first interval. Interval intervalB The second interval. Interval intersection The intersection of the specified intervals. Returns Type Description bool True if the intervals intersect, false otherwise. Operators operator ==(Interval, Interval) Declaration public static bool operator ==(Interval left, Interval right) Parameters Type Name Description Interval left Interval right Returns Type Description bool implicit operator (double Min, double Max)(Interval) Declaration public static implicit operator (double Min, double Max)(Interval interval) Parameters Type Name Description Interval interval Returns Type Description (double Min, double Max) implicit operator Interval((double Min, double Max)) Declaration public static implicit operator Interval((double Min, double Max) interval) Parameters Type Name Description (double Min, double Max) interval Returns Type Description Interval operator !=(Interval, Interval) Declaration public static bool operator !=(Interval left, Interval right) Parameters Type Name Description Interval left Interval right Returns Type Description bool"
  },
  "api/Holoride.ElasticSDK.IntervalAttribute.html": {
    "href": "api/Holoride.ElasticSDK.IntervalAttribute.html",
    "title": "Class IntervalAttribute | ElasticSDK Documentation",
    "keywords": "Class IntervalAttribute Controls the property drawer for Interval fields. Inheritance object Attribute IntervalAttribute Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public sealed class IntervalAttribute : Attribute Properties ClampTo01 Gets or sets a value indicating whether to clamp the range of the interval to [0, 1]. Declaration public bool ClampTo01 { get; set; } Property Value Type Description bool"
  },
  "api/Holoride.ElasticSDK.IPatternDescriptor-1.html": {
    "href": "api/Holoride.ElasticSDK.IPatternDescriptor-1.html",
    "title": "Interface IPatternDescriptor<T> | ElasticSDK Documentation",
    "keywords": "Interface IPatternDescriptor<T> The interface to define a PatternDescriptor for pattern recognition. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public interface IPatternDescriptor<T> Type Parameters Name Description T Properties Properties Gets or sets additional properties. These properties can differ generically for each descriptor pattern. Declaration PatternDescriptorProperties<T> Properties { get; set; } Property Value Type Description PatternDescriptorProperties<T> Methods ComputeEnergy(T) Defines how the energy between two samples is computed. Declaration float ComputeEnergy(T sampleDescriptor) Parameters Type Name Description T sampleDescriptor The descriptor the energy is computed with. Returns Type Description float The resulting energy value. SampleFirstLevel(Spline, double, double) Defines how the first pattern is sampled from the data. Declaration void SampleFirstLevel(Spline spline, double distance, double resolution) Parameters Type Name Description Spline spline The spline to sample. double distance The spline distance where to sample at. double resolution The resolution the spline is sampled. SampleNextLevel(int, Func<int, List<T>>) Defines how subsequent levels are created from the former level. Declaration void SampleNextLevel(int level, Func<int, List<T>> getNeighborhood) Parameters Type Name Description int level The level to sample from. Func<int, List<T>> getNeighborhood Value lookup."
  },
  "api/Holoride.ElasticSDK.IPipelineAssembler.html": {
    "href": "api/Holoride.ElasticSDK.IPipelineAssembler.html",
    "title": "Interface IPipelineAssembler | ElasticSDK Documentation",
    "keywords": "Interface IPipelineAssembler Assembles a pipeline and connects depending input workers. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public interface IPipelineAssembler Properties GeneratedNodeWorkers Gets a mapping of nodes to their workers. Declaration Dictionary<IPipelineNode, IPipelineWorker> GeneratedNodeWorkers { get; } Property Value Type Description Dictionary<IPipelineNode, IPipelineWorker> Methods AssemblePipeline(GenerationSettings, GenerationState) Assembles a pipeline and connects depending input workers. Declaration Pipeline AssemblePipeline(GenerationSettings generationSettings, GenerationState generationState) Parameters Type Name Description GenerationSettings generationSettings The GenerationSettings that contains immutable data that cannot be changed during the whole generation loop. GenerationState generationState The GenerationState that contains the current state of the generation process and will be updated over time. Returns Type Description Pipeline The assembled pipeline."
  },
  "api/Holoride.ElasticSDK.IPipelineContainer.html": {
    "href": "api/Holoride.ElasticSDK.IPipelineContainer.html",
    "title": "Interface IPipelineContainer | ElasticSDK Documentation",
    "keywords": "Interface IPipelineContainer Can be implemented by MonoBehaviors to provide a Pipeline for external use, e.g. to show respective node previews. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public interface IPipelineContainer Properties Pipeline Gets a contained Pipeline. Declaration Pipeline Pipeline { get; } Property Value Type Description Pipeline"
  },
  "api/Holoride.ElasticSDK.IPipelineNode.html": {
    "href": "api/Holoride.ElasticSDK.IPipelineNode.html",
    "title": "Interface IPipelineNode | ElasticSDK Documentation",
    "keywords": "Interface IPipelineNode A node that generates a PipelineWorker. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public interface IPipelineNode Methods GeneratePipelineWorker() Generates a pipeline worker. Declaration IPipelineWorker GeneratePipelineWorker() Returns Type Description IPipelineWorker"
  },
  "api/Holoride.ElasticSDK.IPipelineWorker.html": {
    "href": "api/Holoride.ElasticSDK.IPipelineWorker.html",
    "title": "Interface IPipelineWorker | ElasticSDK Documentation",
    "keywords": "Interface IPipelineWorker An interface to define an element of a pipeline with its lifecycle methods and Inputs. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] public interface IPipelineWorker Properties CurrentGenerationContext Gets or sets the current generation context. Declaration GenerationContext CurrentGenerationContext { get; set; } Property Value Type Description GenerationContext GenerationSettings Gets the immutable data that cannot be changed during the whole generation loop. Declaration GenerationSettings GenerationSettings { get; } Property Value Type Description GenerationSettings GenerationState Gets the current state of the generation process and will be updated over time. Declaration GenerationState GenerationState { get; } Property Value Type Description GenerationState HasMissingMandatoryInputInHierarchy Gets a value indicating whether this worker has any missing mandatory input in hierarchy. Declaration bool HasMissingMandatoryInputInHierarchy { get; } Property Value Type Description bool Inputs Gets the input IPipelineWorkers to be processed before this worker. Declaration IEnumerable<IPipelineWorker> Inputs { get; } Property Value Type Description IEnumerable<IPipelineWorker> IsGatheringResources Gets or sets a value indicating whether this node is gathering resources. Declaration bool IsGatheringResources { get; set; } Property Value Type Description bool IsProcessing Gets or sets a value indicating whether this node is processing. Declaration bool IsProcessing { get; set; } Property Value Type Description bool MissingMandatoryInputs Gets all missing mandatory inputs. Declaration IReadOnlyCollection<string> MissingMandatoryInputs { get; } Property Value Type Description IReadOnlyCollection<string> Pipeline Gets or sets the pipeline this worker currently belongs to. A worker can always only belong to a single pipeline. Declaration Pipeline Pipeline { get; set; } Property Value Type Description Pipeline Methods AddInput(string, IPipelineWorker) Adds an input PipelineWorker. Declaration void AddInput(string id, IPipelineWorker pipelineWorker) Parameters Type Name Description string id The id of the input. IPipelineWorker pipelineWorker The PipelineWorker to set as an input. AddMissingMandatoryInput(string) Adds a missing input. Declaration void AddMissingMandatoryInput(string id) Parameters Type Name Description string id The id of the missing input. CallCleanUp() Cleans up this node. Declaration [Obsolete(\"Use Dispose() instead.\")] void CallCleanUp() CallGatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) Gathers the resources required for this node in order to be processed. Declaration UniTask<LoadResourceResult> CallGatherResourcesAsync(GenerationContext context, IProgress<float> onProgressUpdate = null, CancellationToken cancellationToken = default) Parameters Type Name Description GenerationContext context Contains the immutable meta-information of a single update iteration. IProgress<float> onProgressUpdate The feedback function passing the (down)loading progress [0, 1]. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask<T><LoadResourceResult> CallInit() Initializes this node. Declaration void CallInit() CallInitResources() Initializes the resources required for this node in order to be processed. Declaration void CallInitResources() CallProcessAsync(GenerationContext, IProgress<float>, CancellationToken) The default process function that is called for every CompositingNode. Declaration UniTask CallProcessAsync(GenerationContext context, IProgress<float> onProgressUpdate = null, CancellationToken cancellationToken = default) Parameters Type Name Description GenerationContext context Contains the immutable meta-information of a single update iteration. IProgress<float> onProgressUpdate Called with relative progress in [0, 1]. May be called from another thread. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask GetInput(string) Gets an input PipelineWorker. Declaration IPipelineWorker GetInput(string id) Parameters Type Name Description string id The id of the input. Returns Type Description IPipelineWorker The corresponding input PipelineWorker."
  },
  "api/Holoride.ElasticSDK.IPrefabInstantiationProvider.html": {
    "href": "api/Holoride.ElasticSDK.IPrefabInstantiationProvider.html",
    "title": "Interface IPrefabInstantiationProvider | ElasticSDK Documentation",
    "keywords": "Interface IPrefabInstantiationProvider Contract for a prefab instantiation strategy. Implementations of this interface must be MonoBehaviours attached to the ElasticSceneGenerator and provide a PrefabInstantiationContext to the pipeline to be used by IPipelineWorkers that need to instantiate prefabs. Inherited Members IContextProvider.ProvideContextAsync(GenerationSettings, GenerationContext, ISet<Type>, CancellationToken) IContextProvider.IsDirty Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public interface IPrefabInstantiationProvider : IContextProvider Methods Despawn(GameObject) Releases an instance previously obtained via Spawn(GameObject, Vector3, Quaternion, Vector3, Func<GameObject, UniTask>, CancellationToken). Declaration bool Despawn(GameObject instance) Parameters Type Name Description GameObject instance The instance to release. Returns Type Description bool Whether the implementation handled the specified instance. When this returns false, it is the responsibility of the caller to decide whether the instance should be destroyed or treated otherwise. InitAsync(GameObject, Action<GameObject>, CancellationToken) Creates initial instances of the specified prefab. Declaration UniTask InitAsync(GameObject prefab, Action<GameObject> initAction = null, CancellationToken cancellationToken = default) Parameters Type Name Description GameObject prefab The prefab to instantiate. Action<GameObject> initAction Optional initial action to invoke specific initialization behavior. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask Spawn(GameObject, Vector3, Quaternion, Vector3, Func<GameObject, UniTask>, CancellationToken) Creates an instance of the specified prefab. Declaration UniTask<(bool Success, GameObject Result)> Spawn(GameObject prefab, Vector3 position, Quaternion rotation, Vector3 scale, Func<GameObject, UniTask> preSpawnAction = null, CancellationToken cancellationToken = default) Parameters Type Name Description GameObject prefab The prefab to spawn. Vector3 position The global position to place the instance at. Quaternion rotation The global rotation to set on the instance. Vector3 scale The scale to set on the instance. Func<GameObject, Cysharp.Threading.Tasks.UniTask> preSpawnAction Func delegate to be invoked before the GameObject is activated. Currently used for graph data injection. CancellationToken cancellationToken Token to cancel the async UniTask operation. Returns Type Description Cysharp.Threading.Tasks.UniTask<T><(bool Success, GameObject Result)> Indicates whether an instance was created. When this returns false, this indicates the instantiation should not be performed."
  },
  "api/Holoride.ElasticSDK.IPreprocessingGenerationContext.html": {
    "href": "api/Holoride.ElasticSDK.IPreprocessingGenerationContext.html",
    "title": "Interface IPreprocessingGenerationContext | ElasticSDK Documentation",
    "keywords": "Interface IPreprocessingGenerationContext Specialization of IGenerationContext with callbacks for (asynchronous) initialization prior to a Pipeline run. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public interface IPreprocessingGenerationContext : IGenerationContext Methods GatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) Gathers the resources required for this context in order to be processed/used. Declaration UniTask<LoadResourceResult> GatherResourcesAsync(GenerationContext context, IProgress<float> onProgressUpdate = null, CancellationToken cancellationToken = default) Parameters Type Name Description GenerationContext context Contains the immutable meta-information of a single update iteration. IProgress<float> onProgressUpdate The feedback function passing the (down)loading progress [0, 1]. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask<T><LoadResourceResult> ProcessAsync(GenerationContext, IProgress<float>, CancellationToken) Preprocesses the context for the next update iteration. Declaration UniTask ProcessAsync(GenerationContext context, IProgress<float> onProgressUpdate = null, CancellationToken cancellationToken = default) Parameters Type Name Description GenerationContext context Contains the immutable meta-information of a single update iteration. IProgress<float> onProgressUpdate Called with relative progress in [0, 1]. May be called from another thread. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask"
  },
  "api/Holoride.ElasticSDK.IRecenterOffsetManagerBackend.html": {
    "href": "api/Holoride.ElasticSDK.IRecenterOffsetManagerBackend.html",
    "title": "Interface IRecenterOffsetManagerBackend | ElasticSDK Documentation",
    "keywords": "Interface IRecenterOffsetManagerBackend Platform specific implementation details of the RecenterOffsetManager. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public interface IRecenterOffsetManagerBackend Properties IsGlobalRecenterOffsetAvailable Gets a value indicating whether global recenter offset is currently available through this backend, i.e. the current localization data provided via the StateReceiver is live localization data providing the actual global vehicle heading (and is not a replay or similar). Declaration bool IsGlobalRecenterOffsetAvailable { get; } Property Value Type Description bool Methods RequestCurrentValues() Request current values for recenter offset and apply rate. This may be implemented as an asynchronous operation, the result is returned via the RecenterOffsetApplyRateChanged and GlobalRecenterOffsetChanged events. Declaration void RequestCurrentValues() SetGlobalRecenterOffset(float) Stores a new global recenter offset value through this backend. This may be implemented as an asynchronous operations, will fire UserRecentered once applied. Declaration void SetGlobalRecenterOffset(float value) Parameters Type Name Description float value The new global recenter offset. Events GlobalRecenterOffsetChanged Fired when the global recenter offset changed. This is fired both when an external recentering operation was triggered, in which case it will be followed by the UserRecentered event, or when the backend performed a gradual correction to the current recenter offset, to mitigate headset drift. In the latter case, the new value will be slowly applied over time, based on the last received recenter offset apply rate via RecenterOffsetApplyRateChanged. Declaration event Action<float> GlobalRecenterOffsetChanged Event Type Type Description Action<float> RecenterOffsetApplyRateChanged Fired when the recenter apply rate has changed. Declaration event Action<float> RecenterOffsetApplyRateChanged Event Type Type Description Action<float> UserRecentered Fired when a user actively caused a recenter operation. This may happen either due to an externally detected action (e.g. system recenter), or as a response to the application calling SetGlobalRecenterOffset(float), which is always expected to be caused by a user triggered recenter. Declaration event Action UserRecentered Event Type Type Description Action"
  },
  "api/Holoride.ElasticSDK.IReplayStream.html": {
    "href": "api/Holoride.ElasticSDK.IReplayStream.html",
    "title": "Interface IReplayStream | ElasticSDK Documentation",
    "keywords": "Interface IReplayStream A IReplayStream allows iterating over an underlying Replay implementation in a well-defined manner. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public interface IReplayStream Properties CurrentDistance Gets the total traveled distance in the replay stream. Note that this value does not necessarily start at zero, if the TimeInterval is configured to start at a non-zero time. Declaration double CurrentDistance { get; } Property Value Type Description double CurrentMicroseconds Gets the total elapsed microseconds in the replay stream. Note that this value does not necessarily start at zero, if the TimeInterval is configured to start at a non-zero time. Declaration long CurrentMicroseconds { get; } Property Value Type Description long Methods Seek(TimeSpan) Seeks along the replay stream by the specified amount of time. Declaration TimeSpan Seek(TimeSpan delta) Parameters Type Name Description TimeSpan delta The amount of time to seek forwards or backwards in the stream. Returns Type Description TimeSpan The actual time delta in the stream to the previous time."
  },
  "api/Holoride.ElasticSDK.IRoute.html": {
    "href": "api/Holoride.ElasticSDK.IRoute.html",
    "title": "Interface IRoute | ElasticSDK Documentation",
    "keywords": "Interface IRoute Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public interface IRoute Properties GeoCoordinates Gets the geo coordinates of the route geometry obtained by the navigation API. Declaration IReadOnlyList<GeoCoordinate> GeoCoordinates { get; } Property Value Type Description IReadOnlyList<GeoCoordinate> Maneuvers Gets the maneuver data along the route obtained by the navigation API. Declaration IReadOnlyList<Maneuver> Maneuvers { get; } Property Value Type Description IReadOnlyList<Maneuver> Speeds Gets the speed data along the route obtained by the navigation API. Declaration IReadOnlyList<float> Speeds { get; } Property Value Type Description IReadOnlyList<float> SpeedSegments Gets the route speed intervals. Declaration IReadOnlyList<SpeedSegment> SpeedSegments { get; } Property Value Type Description IReadOnlyList<SpeedSegment> TravelDistance Gets the list of travel distances in meters for the current route. Declaration IReadOnlyList<double> TravelDistance { get; } Property Value Type Description IReadOnlyList<double> TravelTimes Gets the list of travel times in seconds for the current route. Declaration IReadOnlyList<double> TravelTimes { get; } Property Value Type Description IReadOnlyList<double> Methods GetSplineWithDefaultPivot() Computes the spline with the pivot set to the first GeoCoordinate of this route. Declaration Spline GetSplineWithDefaultPivot() Returns Type Description Spline The spline of the route with the pivot set to the first location. GetSplineWithPivot(GeoCoordinate) Computes the spline of this route given a custom pivot. To obtain the spline of the route for its own pivot, use Spline. Declaration Spline GetSplineWithPivot(GeoCoordinate pivot) Parameters Type Name Description GeoCoordinate pivot The pivot relative to which to get the spline. Returns Type Description Spline The route's spline, or null if the route is empty. TryChange(IReadOnlyList<GeoCoordinate>, IReadOnlyList<float>, IReadOnlyList<Maneuver>, IReadOnlyList<double>, IReadOnlyList<double>, bool) Changes the current route. Declaration bool TryChange(IReadOnlyList<GeoCoordinate> geoCoordinates, IReadOnlyList<float> speeds, IReadOnlyList<Maneuver> maneuvers, IReadOnlyList<double> distancesToDestination, IReadOnlyList<double> timesToDestination, bool zeroAltitude) Parameters Type Name Description IReadOnlyList<GeoCoordinate> geoCoordinates The GeoCoordinates the route is defined by. IReadOnlyList<float> speeds A list of speed values with the same length as geoCoordinates. IReadOnlyList<Maneuver> maneuvers A arbitrarily long list of maneuvers. IReadOnlyList<double> distancesToDestination An optional list with the route distance to the destination for each GeoCoordinate. IReadOnlyList<double> timesToDestination A list with estimated time to destination for each GeoCoordinate. bool zeroAltitude States whether all altitude values should be set to zero. Returns Type Description bool Events OnRouteChanged The event that gets fired when a route update has finished. Declaration event Action OnRouteChanged Event Type Type Description Action"
  },
  "api/Holoride.ElasticSDK.ISettingsProvider.html": {
    "href": "api/Holoride.ElasticSDK.ISettingsProvider.html",
    "title": "Interface ISettingsProvider | ElasticSDK Documentation",
    "keywords": "Interface ISettingsProvider Contract of MonoBehaviours that act as settings providers. Settings providers offer a means of flexibly registering additional setting extensions with the GenerationSettings used in a Pipeline. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public interface ISettingsProvider Methods ProvideSettings(GenerationSettings) Allows injecting custom IGenerationSettings extensions. Declaration void ProvideSettings(GenerationSettings settings) Parameters Type Name Description GenerationSettings settings The settings."
  },
  "api/Holoride.ElasticSDK.ISharedGeoCoordinate.html": {
    "href": "api/Holoride.ElasticSDK.ISharedGeoCoordinate.html",
    "title": "Interface ISharedGeoCoordinate | ElasticSDK Documentation",
    "keywords": "Interface ISharedGeoCoordinate A shared GeoCoordinate that can be used to synchronize pivot depending objects. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public interface ISharedGeoCoordinate Properties GeoCoordinate Gets the current value of the shared geo coordinate. Declaration GeoCoordinate GeoCoordinate { get; } Property Value Type Description GeoCoordinate IsInitialized Gets a value indicating whether the shared coordinate has been initialized and can be used by its consumers. This typically means it has been set to a non-default value at least once by a localization source that is in known to be in a valid state. Declaration bool IsInitialized { get; } Property Value Type Description bool OnGeoCoordinateChanged Gets the event fired when the value of GeoCoordinate changes. Declaration [Obsolete(\"Use GeoCoordinateChanged instead.\")] UnityEvent OnGeoCoordinateChanged { get; } Property Value Type Description UnityEvent Events GeoCoordinateChanged Fired when the value of GeoCoordinate changes. Declaration event Action GeoCoordinateChanged Event Type Type Description Action"
  },
  "api/Holoride.ElasticSDK.IShiftParent.html": {
    "href": "api/Holoride.ElasticSDK.IShiftParent.html",
    "title": "Interface IShiftParent | ElasticSDK Documentation",
    "keywords": "Interface IShiftParent Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public interface IShiftParent Properties ShiftParent Declaration GameObject ShiftParent { get; set; } Property Value Type Description GameObject"
  },
  "api/Holoride.ElasticSDK.IStateReceiverListener.html": {
    "href": "api/Holoride.ElasticSDK.IStateReceiverListener.html",
    "title": "Interface IStateReceiverListener | ElasticSDK Documentation",
    "keywords": "Interface IStateReceiverListener Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public interface IStateReceiverListener"
  },
  "api/Holoride.ElasticSDK.IStateReceiverLocalizationEventListener.html": {
    "href": "api/Holoride.ElasticSDK.IStateReceiverLocalizationEventListener.html",
    "title": "Interface IStateReceiverLocalizationEventListener | ElasticSDK Documentation",
    "keywords": "Interface IStateReceiverLocalizationEventListener Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public interface IStateReceiverLocalizationEventListener : IStateReceiverListener Methods OnConnect() Declaration void OnConnect() OnConnectError(StateReceiverInitializationError) Declaration void OnConnectError(StateReceiverInitializationError error) Parameters Type Name Description StateReceiverInitializationError error OnDisconnect() Declaration void OnDisconnect() OnRouteChanged() Declaration void OnRouteChanged() OnVehicleLocalizationReceivedAsync(VehicleSensorState) Declaration void OnVehicleLocalizationReceivedAsync(VehicleSensorState state) Parameters Type Name Description VehicleSensorState state OnVehicleLocalizationReset() Declaration void OnVehicleLocalizationReset() OnVehicleLocalizationStart() Declaration void OnVehicleLocalizationStart() OnVehicleLocalizationStatusChanged(VehicleLocalizationStatus) Declaration void OnVehicleLocalizationStatusChanged(VehicleLocalizationStatus status) Parameters Type Name Description VehicleLocalizationStatus status"
  },
  "api/Holoride.ElasticSDK.ITileDataProvider-1.html": {
    "href": "api/Holoride.ElasticSDK.ITileDataProvider-1.html",
    "title": "Interface ITileDataProvider<T> | ElasticSDK Documentation",
    "keywords": "Interface ITileDataProvider<T> Defines an interface to request tile data. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public interface ITileDataProvider<T> Type Parameters Name Description T Methods RequestMapTileDataAsync(int, Vector2Int, Action<T>, CancellationToken) Requests a tile data. Declaration UniTask RequestMapTileDataAsync(int zoomLevel, Vector2Int tilePos, Action<T> onTileLoaded, CancellationToken cancellationToken = default) Parameters Type Name Description int zoomLevel The zoom level the tile position refers to. Vector2Int tilePos The global position index with respect to the chosen zoom level. Action<T> onTileLoaded A callback providing the object that has been loaded. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask"
  },
  "api/Holoride.ElasticSDK.ITileDataService-1.html": {
    "href": "api/Holoride.ElasticSDK.ITileDataService-1.html",
    "title": "Interface ITileDataService<T> | ElasticSDK Documentation",
    "keywords": "Interface ITileDataService<T> Downloads and caches tiles to the hard drive. Inherited Members ITileDataProvider<T>.RequestMapTileDataAsync(int, Vector2Int, Action<T>, CancellationToken) Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public interface ITileDataService<T> : ITileDataProvider<T> Type Parameters Name Description T Methods CacheMapTileDataAsync(TileAreaDescription, IProgress<float>, CancellationToken) Caches all map tiles of a given tile array. Declaration UniTask<LoadResourceResult> CacheMapTileDataAsync(TileAreaDescription tileAreaDescription, IProgress<float> onProgressUpdate = null, CancellationToken cancellationToken = default) Parameters Type Name Description TileAreaDescription tileAreaDescription A tile array. IProgress<float> onProgressUpdate A callback providing the current caching progress as a value between 0 and 1. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask<T><LoadResourceResult> CacheMapTileDataAsync(int, Vector2Int, IProgress<float>, CancellationToken) Caches a single map tile. Declaration UniTask<LoadResourceResult> CacheMapTileDataAsync(int zoomLevel, Vector2Int tilePos, IProgress<float> onProgressUpdate = null, CancellationToken cancellationToken = default) Parameters Type Name Description int zoomLevel The zoom level the tile position refers to. Vector2Int tilePos The global position index with respect to the chosen zoom level. IProgress<float> onProgressUpdate A callback providing the current caching progress as a value between 0 and 1. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask<T><LoadResourceResult>"
  },
  "api/Holoride.ElasticSDK.KeyValuePairExtensions.html": {
    "href": "api/Holoride.ElasticSDK.KeyValuePairExtensions.html",
    "title": "Class KeyValuePairExtensions | ElasticSDK Documentation",
    "keywords": "Class KeyValuePairExtensions Inheritance object KeyValuePairExtensions Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public static class KeyValuePairExtensions Methods Deconstruct<TKey, TValue>(KeyValuePair<TKey, TValue>, out TKey, out TValue) Declaration public static void Deconstruct<TKey, TValue>(this KeyValuePair<TKey, TValue> kvp, out TKey key, out TValue value) Parameters Type Name Description KeyValuePair<TKey, TValue> kvp TKey key TValue value Type Parameters Name Description TKey TValue"
  },
  "api/Holoride.ElasticSDK.LoadResourceResult.html": {
    "href": "api/Holoride.ElasticSDK.LoadResourceResult.html",
    "title": "Enum LoadResourceResult | ElasticSDK Documentation",
    "keywords": "Enum LoadResourceResult The type of a resource load operation. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public enum LoadResourceResult Fields Name Description Failure Resource failed to load. Success Resource was loaded successfully. Timeout Resource load timed out."
  },
  "api/Holoride.ElasticSDK.LocalizationEvents.html": {
    "href": "api/Holoride.ElasticSDK.LocalizationEvents.html",
    "title": "Class LocalizationEvents | ElasticSDK Documentation",
    "keywords": "Class LocalizationEvents Inheritance object Object Component Behaviour MonoBehaviour LocalizationEvents Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public class LocalizationEvents : MonoBehaviour Fields DistanceToStreetUntilOffRoad The distance in meters from the street until the player is considered to be too far away from the road and the OnOffRoadMode event is triggered. Declaration [Tooltip(\"The distance in meters from the street until the player is considered to be too far away from the road and the OnOffRoadMode event is triggered.\")] public float DistanceToStreetUntilOffRoad Field Value Type Description float OnLocalizationInitialized This event is fired when the localization becomes available and the pivot is set. Declaration [Tooltip(\"This is fired when the localization becomes available and the pivot is set.\")] public UnityEvent OnLocalizationInitialized Field Value Type Description UnityEvent OnLocalizationNormalMode This event is fired when the localization is available and we are on the street (up to the configured DistanceToStreetUntilOffRoad). Declaration [Tooltip(\"This event is fired when the localization is available and we are on the street (up to the road distance threshold).\")] public UnityEvent OnLocalizationNormalMode Field Value Type Description UnityEvent OnLocalizationUnavailableMode This event is fired when the localization is unavailable and thus the player won't move even though the vehicle in the real world might. Declaration [Tooltip(\"This event is fired when the localization is unavailable and thus the player won't move even though the vehicle in the real world might.\")] public UnityEvent OnLocalizationUnavailableMode Field Value Type Description UnityEvent OnOffRoadMode This event is fired when the localization is available but we are not on the road and the distance to the road is larger than the threshold configured in DistanceToStreetUntilOffRoad. Declaration [Tooltip(\"This event is fired when the localization is available but we are not on the road and the distance to the road is larger than the threshold configured in <c>DistanceToStreetUntilOffRoad</c>.\")] public UnityEvent OnOffRoadMode Field Value Type Description UnityEvent Properties CurrentMode Gets the current LocalizationMode. Note that this is initialized correctly after Unity's Start method was called. Declaration public LocalizationMode CurrentMode { get; } Property Value Type Description LocalizationMode"
  },
  "api/Holoride.ElasticSDK.LocalizationMode.html": {
    "href": "api/Holoride.ElasticSDK.LocalizationMode.html",
    "title": "Enum LocalizationMode | ElasticSDK Documentation",
    "keywords": "Enum LocalizationMode Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public enum LocalizationMode Fields Name Description Normal OffRoad Unavailable"
  },
  "api/Holoride.ElasticSDK.LocalizationModes.html": {
    "href": "api/Holoride.ElasticSDK.LocalizationModes.html",
    "title": "Namespace Holoride.ElasticSDK.LocalizationModes | ElasticSDK Documentation",
    "keywords": "Namespace Holoride.ElasticSDK.LocalizationModes Classes StationaryModeManager Access to current stationary mode state. When in stationary mode, no vehicle localization data is available and it is assumed the user is stationary, e.g. when using the system at home. When not in stationary mode, which is usually the default mode, the user is expected to be in a moving vehicle, with localization data being provided by the underlying system. Enums StationaryModeManager.State The current stationary mode state."
  },
  "api/Holoride.ElasticSDK.LocalizationModes.StationaryModeManager.html": {
    "href": "api/Holoride.ElasticSDK.LocalizationModes.StationaryModeManager.html",
    "title": "Class StationaryModeManager | ElasticSDK Documentation",
    "keywords": "Class StationaryModeManager Access to current stationary mode state. When in stationary mode, no vehicle localization data is available and it is assumed the user is stationary, e.g. when using the system at home. When not in stationary mode, which is usually the default mode, the user is expected to be in a moving vehicle, with localization data being provided by the underlying system. Inheritance object StationaryModeManager Namespace: Holoride.ElasticSDK.LocalizationModes Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public static class StationaryModeManager Properties IsStationaryModeAvailable Gets a value indicating whether stationary mode may be used by the current application. Declaration public static bool IsStationaryModeAvailable { get; } Property Value Type Description bool IsStationaryModeEnabled Gets a value indicating whether stationary mode is enabled. Declaration [Obsolete(\"Use StationaryModeState instead.\")] public static bool IsStationaryModeEnabled { get; } Property Value Type Description bool StationaryModeState Gets whether the value of IsStationaryModeEnabled has been fully initialized. Declaration public static StationaryModeManager.State StationaryModeState { get; } Property Value Type Description StationaryModeManager.State Events StationaryModeChanged Fired when the value of IsStationaryModeEnabled has changed. Declaration [Obsolete(\"Use StationaryModeStateChanged instead.\")] public static event Action<bool> StationaryModeChanged Event Type Type Description Action<bool> StationaryModeStateChanged Fired when the value of IsStationaryModeEnabled has changed. Declaration public static event Action StationaryModeStateChanged Event Type Type Description Action"
  },
  "api/Holoride.ElasticSDK.LocalizationModes.StationaryModeManager.State.html": {
    "href": "api/Holoride.ElasticSDK.LocalizationModes.StationaryModeManager.State.html",
    "title": "Enum StationaryModeManager.State | ElasticSDK Documentation",
    "keywords": "Enum StationaryModeManager.State The current stationary mode state. Namespace: Holoride.ElasticSDK.LocalizationModes Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public enum StationaryModeManager.State Fields Name Description Disabled Stationary mode is disabled. Enabled Stationary mode is enabled. Unknown State currently unknown, manager not fully initialized yet."
  },
  "api/Holoride.ElasticSDK.Maneuver.ActionType.html": {
    "href": "api/Holoride.ElasticSDK.Maneuver.ActionType.html",
    "title": "Enum Maneuver.ActionType | ElasticSDK Documentation",
    "keywords": "Enum Maneuver.ActionType Defines the different actions of a maneuver. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public enum Maneuver.ActionType Fields Name Description Arrive Maneuver's action for arrival. ArriveAirport Maneuver's action for arrival at the airport. ArriveLeft Maneuver's action for arrival on the left side. ArriveRight Maneuver's action for arrival on the right side. Continue Maneuver's action for a Continue. Depart Maneuver's action for departure. DepartAirport Maneuver's action for a departure from an airport. \"Start toward the airport exit\". Ferry Maneuver's action for a Ferry. LeftExit Maneuver's action for a LeftExit. LeftFork Maneuver's action for a LeftFork. LeftLoop Maneuver's action for a left loop. LeftMerge Maneuver's action for a LeftMerge. LeftRamp Maneuver's action for a LeftRamp. LeftRoundaboutExit01 Maneuver's action for a LeftRoundaboutExit01. LeftRoundaboutExit02 Maneuver's action for a LeftRoundaboutExit02. LeftRoundaboutExit03 Maneuver's action for a LeftRoundaboutExit03. LeftRoundaboutExit04 Maneuver's action for a LeftRoundaboutExit04. LeftRoundaboutExit05 Maneuver's action for a LeftRoundaboutExit05. LeftRoundaboutExit06 Maneuver's action for a LeftRoundaboutExit06. LeftRoundaboutExit07 Maneuver's action for a LeftRoundaboutExit07. LeftRoundaboutExit08 Maneuver's action for a LeftRoundaboutExit08. LeftRoundaboutExit09 Maneuver's action for a LeftRoundaboutExit09. LeftRoundaboutExit10 Maneuver's action for a LeftRoundaboutExit10. LeftRoundaboutExit11 Maneuver's action for a LeftRoundaboutExit11. LeftRoundaboutExit12 Maneuver's action for a LeftRoundaboutExit12. LeftTurn Maneuver's action for a LeftTurn. LeftUTurn Maneuver's action for a left uTurn. MiddleFork Maneuver's action for a MiddleFork. NameChange Maneuver's action for a NameChange. OffRamp Maneuver's action for leaving a highway. OnRamp Maneuver's action for entering a highway. RightExit Maneuver's action for a RightExit. RightFork Maneuver's action for a RightFork. RightLoop Maneuver's action for a RightLoop. RightMerge Maneuver's action for a RightMerge. RightRamp Maneuver's action for a RightRamp. RightRoundaboutExit01 Maneuver's action for a RightRoundaboutExit01. RightRoundaboutExit02 Maneuver's action for a RightRoundaboutExit02. RightRoundaboutExit03 Maneuver's action for a RightRoundaboutExit03. RightRoundaboutExit04 Maneuver's action for a RightRoundaboutExit04. RightRoundaboutExit05 Maneuver's action for a RightRoundaboutExit05. RightRoundaboutExit06 Maneuver's action for a RightRoundaboutExit06. RightRoundaboutExit07 Maneuver's action for a RightRoundaboutExit07. RightRoundaboutExit08 Maneuver's action for a RightRoundaboutExit08. RightRoundaboutExit09 Maneuver's action for a RightRoundaboutExit09. RightRoundaboutExit10 Maneuver's action for a RightRoundaboutExit10. RightRoundaboutExit11 Maneuver's action for a RightRoundaboutExit11. RightRoundaboutExit12 Maneuver's action for a RightRoundaboutExit12. RightTurn Maneuver's action for a RightTurn. RightUTurn Maneuver's action for a RightUTurn. Roundabout Maneuver's action for traversing a roundabout. SharpLeftTurn Maneuver's action for a SharpLeftTurn. SharpRightTurn Maneuver's action for a SharpRightTurn. SlightLeftTurn Maneuver's action for a SlightLeftTurn. SlightRightTurn Maneuver's action for a SlightRightTurn. TrafficCircle Maneuver's action for a TrafficCircle. Turn Maneuver's action for a basic turn into the direction based on the modifier. Unknown Maneuver's action for each maneuver that could not be matched."
  },
  "api/Holoride.ElasticSDK.Maneuver.DirectionType.html": {
    "href": "api/Holoride.ElasticSDK.Maneuver.DirectionType.html",
    "title": "Enum Maneuver.DirectionType | ElasticSDK Documentation",
    "keywords": "Enum Maneuver.DirectionType Defines the different directions of a maneuver. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public enum Maneuver.DirectionType Fields Name Description BearLeft Indicates to keep on the left lane. BearRight Indicates to keep on the right lane. Forward Indicates no relevant change in direction. HardLeft Indicates a hard turn to the left. HardRight Indicates a hard right turn. Left Indicates a normal turn to the left. LightLeft Indicates a light turn to the left. LightRight Indicates a light turn to the right. Right Indicates a normal turn to the right. Unknown No matching modifier was found. UTurn Indicates reversal of direction. UTurnLeft Indicates reversal of direction to the left. UTurnRight Indicates reversal of direction to the right."
  },
  "api/Holoride.ElasticSDK.Maneuver.html": {
    "href": "api/Holoride.ElasticSDK.Maneuver.html",
    "title": "Class Maneuver | ElasticSDK Documentation",
    "keywords": "Class Maneuver Representation of possible maneuvers. Inheritance object Maneuver Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [Serializable] public class Maneuver Properties Action Gets or sets the list of actions of a maneuver. Declaration public List<Maneuver.ActionType> Action { get; set; } Property Value Type Description List<Maneuver.ActionType> Direction Gets or sets the direction of a maneuver. Declaration public List<Maneuver.DirectionType> Direction { get; set; } Property Value Type Description List<Maneuver.DirectionType> GeoCoordinate Gets or sets the geo coordinate of a maneuver. Declaration public GeoCoordinate GeoCoordinate { get; set; } Property Value Type Description GeoCoordinate"
  },
  "api/Holoride.ElasticSDK.MapUtils.html": {
    "href": "api/Holoride.ElasticSDK.MapUtils.html",
    "title": "Class MapUtils | ElasticSDK Documentation",
    "keywords": "Class MapUtils A collection of useful map functions. Inheritance object MapUtils Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public static class MapUtils Methods DistanceTransform(IReadOnlyList<float>, float[], float, float, bool, bool) Performs a distance transform on an image for pixels greater than the threshold. Declaration public static void DistanceTransform(IReadOnlyList<float> inputImage, float[] outputImage, float pixelDistance, float threshold, bool invert = false, bool borderDistance = false) Parameters Type Name Description IReadOnlyList<float> inputImage The input image with a square resolution. float[] outputImage The output image of the same size as the input image. float pixelDistance The pixel distance to scale the output. float threshold Values are set to the euclidean distance to the closest point falling below this threshold. bool invert States whether to compute distances to pixels above the threshold instead. bool borderDistance States whether to include distances to the image boarder. Index2D(int, int, int, int) Converts the 2d index of a rectangular image to a single integer index. Declaration public static int Index2D(int x, int y, int resolutionX, int resolutionY) Parameters Type Name Description int x The x coordinate. int y The y coordinate. int resolutionX The resolution in x dimension. int resolutionY The resolution in y dimension. Returns Type Description int The linear index. Index2D(int, int, int) Converts the 2d index of a squared image to a single integer index. Declaration public static int Index2D(int x, int y, int resolution) Parameters Type Name Description int x The x coordinate. int y The y coordinate. int resolution The resolution in each dimension. Returns Type Description int The linear index."
  },
  "api/Holoride.ElasticSDK.MapWorker.html": {
    "href": "api/Holoride.ElasticSDK.MapWorker.html",
    "title": "Class MapWorker | ElasticSDK Documentation",
    "keywords": "Class MapWorker Represents the result of the different evaluation of a 2D float buffer, based on the used filter implementation, through accessing the ram/v-ram. Also manages compute shader calls. Inheritance object PipelineWorkerBase MapWorker MapNode.MapWorker<T> Implements IPipelineWorker Inherited Members PipelineWorkerBase.GenerationSettings PipelineWorkerBase.GenerationState PipelineWorkerBase.CurrentGenerationContext PipelineWorkerBase.Pipeline PipelineWorkerBase.IsGatheringResources PipelineWorkerBase.IsProcessing PipelineWorkerBase.Inputs PipelineWorkerBase.MissingMandatoryInputs PipelineWorkerBase.AddMissingMandatoryInput(string) PipelineWorkerBase.HasMissingMandatoryInputInHierarchy PipelineWorkerBase.AddInput(string, IPipelineWorker) PipelineWorkerBase.GetInput(string) PipelineWorkerBase.GetInput<T>(string) PipelineWorkerBase.InitResources() PipelineWorkerBase.CallInitResources() PipelineWorkerBase.Init() PipelineWorkerBase.GatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.CallGatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.ProcessAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.CleanUp() PipelineWorkerBase.CallCleanUp() Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] public class MapWorker : PipelineWorkerBase, IPipelineWorker Constructors MapWorker(bool, bool, bool) Instantiates a MapWorker. Declaration public MapWorker(bool provideDoubleBuffer, bool provideCPUBuffer, bool provideGPUBuffer) Parameters Type Name Description bool provideDoubleBuffer bool provideCPUBuffer bool provideGPUBuffer Fields IsCPUBufferFinal States whether the map data is final and hence available. Declaration public bool IsCPUBufferFinal Field Value Type Description bool IsGPUBufferFinal States whether the compute buffer is final and hence available. Declaration public bool IsGPUBufferFinal Field Value Type Description bool Undefined A value that states the value undefined but can also be used in the shader. Declaration public static float Undefined Field Value Type Description float Properties CurrentCPUReadBuffer Gets the CPUReadBuffer. Synchronously initializes it if necessary. Declaration public IReadOnlyList<float> CurrentCPUReadBuffer { get; } Property Value Type Description IReadOnlyList<float> CurrentCPUWriteBuffer Gets the CPUWriteBuffer that can only be accessed to in the processing phase. Declaration public float[] CurrentCPUWriteBuffer { get; } Property Value Type Description float[] CurrentGPUReadBuffer Gets the GPUReadBuffer. Synchronously initializes it if necessary. Declaration public ComputeBuffer CurrentGPUReadBuffer { get; } Property Value Type Description ComputeBuffer CurrentGPUWriteBuffer Gets the GPUWriteBuffer that can only be accessed to in the processing phase. Declaration public ComputeBuffer CurrentGPUWriteBuffer { get; } Property Value Type Description ComputeBuffer EnsureCPUBuffer Gets a value indicating whether a CPUBuffer should be ensured. Declaration public bool EnsureCPUBuffer { get; } Property Value Type Description bool EnsureGPUBuffer Gets a value indicating whether a GPUBuffer should be ensured. Declaration public bool EnsureGPUBuffer { get; } Property Value Type Description bool Methods AttachCurveToComputeShader(string, AnimationCurve, int, ComputeShader, float, float) Attaches a curve to a compute shader. Declaration public void AttachCurveToComputeShader(string shaderVariableName, AnimationCurve curve, int sampleResolution, ComputeShader shader, float supportMin = 0, float supportMax = 1) Parameters Type Name Description string shaderVariableName The name of the variable that should get evaluated. AnimationCurve curve The curve. int sampleResolution The resolution of the curve. ComputeShader shader The compute shader. float supportMin The minimum value of the expected curve value range. float supportMax The maximum value of the expected curve value range. BlendWithPreviousCPUBufferAsync(GenerationContext, CancellationToken) Blends two CPU buffers and linear interpolates within the BlendMargin. Declaration public UniTask BlendWithPreviousCPUBufferAsync(GenerationContext targetGenerationContext, CancellationToken cancellationToken = default) Parameters Type Name Description GenerationContext targetGenerationContext The generation context of the resulting buffer. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask BlendWithPreviousGPUBufferAsync(GenerationContext, CancellationToken) Uses a compute shader to blend two GPU buffers. Declaration public UniTask BlendWithPreviousGPUBufferAsync(GenerationContext targetGenerationContext, CancellationToken cancellationToken = default) Parameters Type Name Description GenerationContext targetGenerationContext The generation context of the resulting buffer. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask BlendWithPreviousGPUBufferAsync(ComputeShader, int, GenerationContext, CancellationToken) Uses a compute shader to blend two GPU buffers. Declaration public UniTask BlendWithPreviousGPUBufferAsync(ComputeShader shader, int kernelHandle, GenerationContext targetGenerationContext, CancellationToken cancellationToken = default) Parameters Type Name Description ComputeShader shader The shader that implements the blending function. int kernelHandle The shader kernel that implements the blending function. GenerationContext targetGenerationContext The generation context of the resulting buffer. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask CallInit() Initializes this node. Declaration public override void CallInit() Overrides PipelineWorkerBase.CallInit() CallProcessAsync(GenerationContext, IProgress<float>, CancellationToken) The default process function that is called for every CompositingNode. Declaration public override sealed UniTask CallProcessAsync(GenerationContext context, IProgress<float> onProgressUpdate = null, CancellationToken cancellationToken = default) Parameters Type Name Description GenerationContext context Contains the immutable meta-information of a single update iteration. IProgress<float> onProgressUpdate Called with relative progress in [0, 1]. May be called from another thread. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask Overrides PipelineWorkerBase.CallProcessAsync(GenerationContext, IProgress<float>, CancellationToken) CopyFromCPUToGPU() Uploads the map data to the compute buffer. Declaration public void CopyFromCPUToGPU() CopyFromGPUToCPUAfterProcessAsync(CancellationToken) Allows asynchronously populating the CPU buffer from the GPU buffer after node processing has completed, e.g. when a consuming node needs CPU data but the node only generated GPU data. Declaration public UniTask CopyFromGPUToCPUAfterProcessAsync(CancellationToken cancellationToken) Parameters Type Name Description CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask CopyFromGPUToCPUAsync(CancellationToken) Uploads the map data to the compute buffer. Declaration protected UniTask CopyFromGPUToCPUAsync(CancellationToken cancellationToken) Parameters Type Name Description CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask Dispose() Declaration public override void Dispose() Overrides PipelineWorkerBase.Dispose() ForEachCoordinate(Action<int, int>) Processes the modifyFunction for each coordinate of a filters MapData. Declaration [Obsolete(\"Will be removed in a future release.\")] public IEnumerator ForEachCoordinate(Action<int, int> modifyFunction) Parameters Type Name Description Action<int, int> modifyFunction The action to modify the values. The parameters are the array indices. Returns Type Description IEnumerator GetCPUReadBufferValue(int, int) Gets a single value from the CPUReadBuffer. Declaration public float GetCPUReadBufferValue(int x, int y) Parameters Type Name Description int x The x coordinate. int y The y coordinate. Returns Type Description float The CPUReadBuffer value at x and y. GetCPUReadBufferValueInterpolated(GlobalPosition) Samples the CPUReadBuffer. If a position is queried that is outside the generation bounds, clamped boundary value will be returned. Declaration public float GetCPUReadBufferValueInterpolated(GlobalPosition position) Parameters Type Name Description GlobalPosition position The position to sample. Returns Type Description float The interpolated value. GetCPUWriteBufferValue(int, int) Gets a single value from the CPUWriteBuffer. This can only be done in a processing phase. Declaration public float GetCPUWriteBufferValue(int x, int y) Parameters Type Name Description int x The x coordinate. int y The y coordinate. Returns Type Description float The CPUWriteBuffer value at x and y. GetGradientAtPosition(GlobalPosition) Computes the gradient at a position. Declaration public Vector2 GetGradientAtPosition(GlobalPosition position) Parameters Type Name Description GlobalPosition position The position to compute the gradient at. Returns Type Description Vector2 The gradient. IsUndefined(float) States whether a given value is undefined. Declaration public bool IsUndefined(float value) Parameters Type Name Description float value The value to check if undefined. Returns Type Description bool Whether the given value is undefined. PromiseCPUBuffer() Call after initialization to ensure a CPU buffer is created for eager evaluation. Declaration public void PromiseCPUBuffer() PromiseGPUBuffer() Call after initialization to ensure a GPU buffer is created for eager evaluation. Declaration public void PromiseGPUBuffer() RunShader(ComputeShader, int) Runs a computeShader. Declaration public void RunShader(ComputeShader shader, int kernelHandle) Parameters Type Name Description ComputeShader shader The computeShader. int kernelHandle The kernelHandle. SetCPUWriteBufferValue(int, int, float) Sets a single value to the CPUWriteBuffer. This can only be done in a processing phase. Declaration public void SetCPUWriteBufferValue(int x, int y, float value) Parameters Type Name Description int x The x coordinate. int y The y coordinate. float value The value to write. ToShaderArray(float[]) Converts a float array into a shader readable format. Declaration public static float[] ToShaderArray(float[] array) Parameters Type Name Description float[] array The float array to convert. Returns Type Description float[] The float array in a shader readable format. Implements IPipelineWorker"
  },
  "api/Holoride.ElasticSDK.MeshUtils.html": {
    "href": "api/Holoride.ElasticSDK.MeshUtils.html",
    "title": "Class MeshUtils | ElasticSDK Documentation",
    "keywords": "Class MeshUtils Inheritance object MeshUtils Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public static class MeshUtils Properties QuadMesh Declaration public static Mesh QuadMesh { get; } Property Value Type Description Mesh Methods AppendLineTopologyData(IList<Vector3>, IList<int>, List<Vector3>) Appends a new line to an existing index and vertex buffer (doesn't connect to the existing line). Declaration public static void AppendLineTopologyData(IList<Vector3> points, IList<int> indices, List<Vector3> vertices) Parameters Type Name Description IList<Vector3> points The points representing a new line to append to the passed buffers. IList<int> indices Resulting list of line indices of previous and new lines. List<Vector3> vertices Resulting list of vertices of previous and new lines. BendCollisionMeshAsync(MeshCollider, List<Matrix4x4>, (List<Matrix4x4> Matrices, AnimationCurve Curve)?, CancellationToken) Bends a collision mesh. Declaration public static UniTask BendCollisionMeshAsync(MeshCollider meshCollider, List<Matrix4x4> bendingMatrices, (List<Matrix4x4> Matrices, AnimationCurve Curve)? innerInfo = null, CancellationToken cancellationToken = default) Parameters Type Name Description MeshCollider meshCollider The collider providing the mesh to bend. List<Matrix4x4> bendingMatrices The bending matrices. (List<Matrix4x4> Matrices, AnimationCurve Curve)? innerInfo The inner bending matrices and interpolation curve for inner bending. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask The bent mesh. BendMeshAsync(Mesh, List<Matrix4x4>, (List<Matrix4x4> Matrices, AnimationCurve Curve)?, CancellationToken) Bends an arbitrary mesh. Declaration public static UniTask BendMeshAsync(Mesh mesh, List<Matrix4x4> bendingMatrices, (List<Matrix4x4> Matrices, AnimationCurve Curve)? innerInfo = null, CancellationToken cancellationToken = default) Parameters Type Name Description Mesh mesh The mesh to bend. List<Matrix4x4> bendingMatrices The bending matrices. (List<Matrix4x4> Matrices, AnimationCurve Curve)? innerInfo The inner bending matrices and interpolation curve for inner bending. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask The bent mesh. BendMeshAsync(MeshFilter, List<Matrix4x4>, (List<Matrix4x4> Matrices, AnimationCurve Curve)?, CancellationToken) Bends an arbitrary mesh. Declaration public static UniTask BendMeshAsync(MeshFilter meshFilter, List<Matrix4x4> bendingMatrices, (List<Matrix4x4> Matrices, AnimationCurve Curve)? innerInfo = null, CancellationToken cancellationToken = default) Parameters Type Name Description MeshFilter meshFilter The mesh filter providing the mesh to bend. List<Matrix4x4> bendingMatrices The bending matrices. (List<Matrix4x4> Matrices, AnimationCurve Curve)? innerInfo The inner bending matrices and interpolation curve for inner bending. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask The bent mesh. BevelY(List<Vector3>, float) Declaration public static List<Vector3> BevelY(List<Vector3> points, float radius) Parameters Type Name Description List<Vector3> points float radius Returns Type Description List<Vector3> BuildLineTopologyData(List<Vector3>, List<int>, List<Vector3>) Uses the passed points to build a vertex and index buffer based on the Line MeshTopology. Declaration public static void BuildLineTopologyData(List<Vector3> points, List<int> indices, List<Vector3> vertices) Parameters Type Name Description List<Vector3> points The points to create lines from. List<int> indices Resulting list of line indices {(0,1),(1,2),...}. List<Vector3> vertices Resulting list of vertices (same as input). ComputeBendingMatricesOnSpline(Mesh, Spline, double, int, Transform) Computes the bending matrices from a spline. Declaration public static List<Matrix4x4> ComputeBendingMatricesOnSpline(Mesh mesh, Spline spline, double distanceOnSpline, int bendingResolution, Transform worldTransform) Parameters Type Name Description Mesh mesh The mesh to bend. Spline spline The spline to bend the mesh on. double distanceOnSpline The distance on the spline. int bendingResolution The number of bending matrices. Transform worldTransform The world transform to apply to the mesh. Returns Type Description List<Matrix4x4> A list of bending matrices. ExtrudeY(List<Vector3>, List<int>, List<Vector3>, List<Vector3>, List<Vector2>, List<Vector2>, float, float, bool, bool, bool) Declaration public static void ExtrudeY(List<Vector3> points, List<int> indices, List<Vector3> vertices, List<Vector3> normals, List<Vector2> stretchedUVs, List<Vector2> repeatingUVs, float height, float yOffset = 0, bool frontFace = true, bool backFace = true, bool smoothBevelNormals = false) Parameters Type Name Description List<Vector3> points List<int> indices List<Vector3> vertices List<Vector3> normals List<Vector2> stretchedUVs List<Vector2> repeatingUVs float height float yOffset bool frontFace bool backFace bool smoothBevelNormals TriangulateXZ(IList<Vector3>, IList<int>, IList<Vector3>, float) Uses the 'ear clipping triangulation' approach to triangulate a list of points. Declaration public static void TriangulateXZ(IList<Vector3> points, IList<int> indices, IList<Vector3> vertices, float yOffset = 0) Parameters Type Name Description IList<Vector3> points The points to triangulate. IList<int> indices Resulting list of triangle indices. IList<Vector3> vertices Resulting list of vertices. float yOffset the added offset from the xz plane. TriangulateXZ(List<Vector3>, List<int>, List<Vector3>, List<Vector3>, List<Vector2>, List<Vector2>, float, bool, bool, float) Uses the 'ear clipping triangulation' approach to triangulate a list of points. Declaration public static void TriangulateXZ(List<Vector3> points, List<int> indices, List<Vector3> vertices, List<Vector3> normals, List<Vector2> stretchedUVs, List<Vector2> repeatingUVs, float yOffset = 0, bool faceUp = true, bool faceDown = false, float repeatingUVsScale = 1) Parameters Type Name Description List<Vector3> points The points to triangulate. List<int> indices Resulting list of triangle indices. List<Vector3> vertices Resulting list of vertices. List<Vector3> normals Resulting list of normals. List<Vector2> stretchedUVs Resulting list of stretchedUVs. List<Vector2> repeatingUVs Resulting list of repeatingUVs. float yOffset the added offset from the xz plane. bool faceUp Add normal for faces pointing up. bool faceDown Add normal for faces pointing down. float repeatingUVsScale The scale for repeating UVs."
  },
  "api/Holoride.ElasticSDK.MovingGrid-1.html": {
    "href": "api/Holoride.ElasticSDK.MovingGrid-1.html",
    "title": "Class MovingGrid<T> | ElasticSDK Documentation",
    "keywords": "Class MovingGrid<T> A data structure that provides a two-dimensional local grid of cells with reference to a global position. The grid position is intended to move and therefore free all cells that don't overlap with the target area. Inheritance object MovingGrid<T> Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class MovingGrid<T> Type Parameters Name Description T Constructors MovingGrid(int) Creates the empty data structure. Declaration public MovingGrid(int gridRadius) Parameters Type Name Description int gridRadius The distance from the center of the square grid area to any one of its four edges. This intentionally results in an uneven square extent. Properties GridCenterPosition Gets the current grid center position within the global support range. Declaration public Vector2Int GridCenterPosition { get; } Property Value Type Description Vector2Int this[int, int] Provides access to a grid cell by addressing the global 2d-position. Will return default value or null if outside the grid. Declaration public T this[int x, int y] { get; set; } Parameters Type Name Description int x int y Property Value Type Description T this[Vector2Int] Provides access to a grid cell by addressing the global 2d-position. Declaration public T this[Vector2Int position] { get; set; } Parameters Type Name Description Vector2Int position Property Value Type Description T Methods Clear(Action<T>) Clears the contents of this grid, resetting every cell to its default value. Declaration public void Clear(Action<T> forEachCell = null) Parameters Type Name Description Action<T> forEachCell A callback invoked for each non-default cell to allow extra disposal steps that may be needed for the contents of this grid. Move(Vector2Int, Func<Vector2Int, T, CancellationToken, UniTask>, CancellationToken) Moves the grid. Declaration public UniTask Move(Vector2Int targetCenterPosition, Func<Vector2Int, T, CancellationToken, UniTask> forAllCellsToOverwrite = null, CancellationToken cancellationToken = default) Parameters Type Name Description Vector2Int targetCenterPosition The target position where to move the center of the grid to. Func<Vector2Int, T, CancellationToken, Cysharp.Threading.Tasks.UniTask> forAllCellsToOverwrite The callback on every cell that gets overridden. The parameters are the new global cell position and the dropped cell value. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask Supports(int, int) States whether the current grid supports the given position. Declaration public bool Supports(int x, int y) Parameters Type Name Description int x The x coordinate. int y The y coordinate. Returns Type Description bool Whether the position is in bounds. Supports(Vector2Int) States whether the current grid supports the given position. Declaration public bool Supports(Vector2Int position) Parameters Type Name Description Vector2Int position The position. Returns Type Description bool Whether the position is in bounds."
  },
  "api/Holoride.ElasticSDK.NewtonsoftJsonVulnFix.html": {
    "href": "api/Holoride.ElasticSDK.NewtonsoftJsonVulnFix.html",
    "title": "Class NewtonsoftJsonVulnFix | ElasticSDK Documentation",
    "keywords": "Class NewtonsoftJsonVulnFix Inheritance object NewtonsoftJsonVulnFix Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public static class NewtonsoftJsonVulnFix"
  },
  "api/Holoride.ElasticSDK.NullStateReceiverBackend.html": {
    "href": "api/Holoride.ElasticSDK.NullStateReceiverBackend.html",
    "title": "Class NullStateReceiverBackend | ElasticSDK Documentation",
    "keywords": "Class NullStateReceiverBackend A backend that does nothing. Useful as an override to disable automatic backend behavior, e.g. when running tests. Inheritance object Object ScriptableObject StateReceiverBackend NullStateReceiverBackend Inherited Members StateReceiverBackend.State StateReceiverBackend.VehicleSensorState StateReceiverBackend.TravelInformationState StateReceiverBackend.Route StateReceiverBackend.AllListeners StateReceiverBackend.LocalizationListeners StateReceiverBackend.AddListener(IStateReceiverListener) StateReceiverBackend.RemoveListener(IStateReceiverListener) StateReceiverBackend.NotifyListenerConfigurationChanged() StateReceiverBackend.Pivot StateReceiverBackend.IsEnabled StateReceiverBackend.Enable() StateReceiverBackend.Disable() StateReceiverBackend.Update() StateReceiverBackend.OnApplicationResume() StateReceiverBackend.OnListenerAdded(IStateReceiverListener) StateReceiverBackend.OnListenerRemoved(IStateReceiverListener) StateReceiverBackend.OnDestroy() StateReceiverBackend.OnStateUpdated() StateReceiverBackend.OnStateReceivedAsync(VehicleSensorState) StateReceiverBackend.OnRouteChanged() StateReceiverBackend.OnMapAccessTokenReceived(string) StateReceiverBackend.UpdatePivot(GeoCoordinate) Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.StateReceivers.dll Syntax public sealed class NullStateReceiverBackend : StateReceiverBackend"
  },
  "api/Holoride.ElasticSDK.PatternDescriptorProperties-1.html": {
    "href": "api/Holoride.ElasticSDK.PatternDescriptorProperties-1.html",
    "title": "Class PatternDescriptorProperties<T> | ElasticSDK Documentation",
    "keywords": "Class PatternDescriptorProperties<T> This class defines additional PatternDescriptorProperties. Inheritance object PatternDescriptorProperties<T> Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class PatternDescriptorProperties<T> Type Parameters Name Description T"
  },
  "api/Holoride.ElasticSDK.Pipeline.CyclicGraphException.html": {
    "href": "api/Holoride.ElasticSDK.Pipeline.CyclicGraphException.html",
    "title": "Class Pipeline.CyclicGraphException | ElasticSDK Documentation",
    "keywords": "Class Pipeline.CyclicGraphException Inheritance object Exception Pipeline.CyclicGraphException Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class Pipeline.CyclicGraphException : Exception Constructors CyclicGraphException() Declaration public CyclicGraphException() CyclicGraphException(string) Declaration public CyclicGraphException(string message) Parameters Type Name Description string message"
  },
  "api/Holoride.ElasticSDK.Pipeline.html": {
    "href": "api/Holoride.ElasticSDK.Pipeline.html",
    "title": "Class Pipeline | ElasticSDK Documentation",
    "keywords": "Class Pipeline A Pipeline consists of a list of IPipelineWorker that consecutively process the data in each generation update phase. Inheritance object Pipeline Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] public sealed class Pipeline Constructors Pipeline(GenerationSettings, GenerationState) Instantiates a Pipeline. Declaration public Pipeline(GenerationSettings generationSettings, GenerationState generationState) Parameters Type Name Description GenerationSettings generationSettings Contains immutable data that cannot be changed during the whole generation loop. GenerationState generationState Contains the current state of the generation process and will be updated over time. Properties FrameBudget Gets or sets the amount of time the pipeline may spend gathering resources/processing each frame before it must yield. By default the pipeline will yield frequently to avoid causing frame time spikes. This setting may be used to attempt to keep going until the specified budget has been depleted. Note that there are some operations where the pipeline may yield before the budget has been depleted, for example for download operations during resource gathering. Note that the pipeline will always exceed this limit slightly, since it is unknown how long any particular task will take before executing it. As such, the actual frame time used by the pipeline will be FrameBudget + TimeTakenBySlowestWorker. Declaration public TimeSpan FrameBudget { get; set; } Property Value Type Description TimeSpan GenerationSettings Gets the immutable state that cannot be changed during the generation loop. Declaration public GenerationSettings GenerationSettings { get; } Property Value Type Description GenerationSettings GenerationState Gets the current state of the generation process that will be updated over time. Declaration public GenerationState GenerationState { get; } Property Value Type Description GenerationState GroupCounts Gets a mapping of group name to number of workers for that group, based on the WorkerGroupAttribute on the workers in this pipeline. Declaration public Dictionary<string, int> GroupCounts { get; } Property Value Type Description Dictionary<string, int> Methods AddSubgraph(IPipelineWorker) Adds a pipeline worker and, recursively, its inputs to the list in a sorted manner. Declaration public void AddSubgraph(IPipelineWorker rootWorker) Parameters Type Name Description IPipelineWorker rootWorker The IPipelineWorker to start adding at to add. AddWorkers(IEnumerable<IPipelineWorker>) Adds a list of pipeline workers and, recursively, their inputs to the list in a sorted manner. Declaration public void AddWorkers(IEnumerable<IPipelineWorker> workers) Parameters Type Name Description IEnumerable<IPipelineWorker> workers The IPipelineWorker to add. CleanUpAll() Cleans up the all Workers. Declaration [Obsolete(\"Use Dispose() instead.\")] public void CleanUpAll() Clear(IPipelineWorker) Removes all worker from the list. Declaration public void Clear(IPipelineWorker pipelineWorker) Parameters Type Name Description IPipelineWorker pipelineWorker The IPipelineWorker to be cleared. Contains(IPipelineWorker) Tests whether the specified worker is part of this pipeline. Declaration public bool Contains(IPipelineWorker worker) Parameters Type Name Description IPipelineWorker worker The IPipelineWorker to test for. Returns Type Description bool true if the worker is part of this pipeline; false otherwise. Dispose() Declaration public void Dispose() GatherAllResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) Gathers the resources of the all Workers. Declaration public UniTask GatherAllResourcesAsync(GenerationContext context, IProgress<float> onProgressUpdate = null, CancellationToken cancellationToken = default) Parameters Type Name Description GenerationContext context Contains the immutable meta-information of a single update iteration. IProgress<float> onProgressUpdate The feedback function passing the (down)loading progress [0, 1]. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask GetAllWorkersOfType<T>() Returns all workers of a specific type in their occuring order within the pipeline. Declaration public IEnumerable<T> GetAllWorkersOfType<T>() Returns Type Description IEnumerable<T> Type Parameters Name Description T GetRequiredContextTypes() Gets the set of IGenerationContext types used by the workers in this pipeline. This can be used to determine which types of context need to be initialized for this pipeline, to avoid the extra work initializing unused contexts would involve. Declaration public ISet<Type> GetRequiredContextTypes() Returns Type Description ISet<Type> The set of context types required by this pipeline. InitAll() Initializes the all attached IPipelineWorkers. Declaration public void InitAll() InitAllResources() Initializes the resources of all attached IPipelineWorkers. Declaration public void InitAllResources() ProcessAllAsync(GenerationContext, IProgress<float>, CancellationToken) Processes the all Workers. Declaration public UniTask ProcessAllAsync(GenerationContext context, IProgress<float> onProgressUpdate = null, CancellationToken cancellationToken = default) Parameters Type Name Description GenerationContext context Contains the immutable meta-information of a single update iteration. IProgress<float> onProgressUpdate Called with relative progress in [0, 1]. May be called from another thread. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask Remove(IPipelineWorker) Remove a IPipelineWorker from the list. Declaration public void Remove(IPipelineWorker worker) Parameters Type Name Description IPipelineWorker worker The IPipelineWorker to be removed. SetWorkersAsProcessing() Flags all workers as being processed. Used in editor to flag workers as processing while still performing pre-processing to visually indicate the graph is being processed. Declaration public void SetWorkersAsProcessing()"
  },
  "api/Holoride.ElasticSDK.Pipeline.MissingInputException.html": {
    "href": "api/Holoride.ElasticSDK.Pipeline.MissingInputException.html",
    "title": "Class Pipeline.MissingInputException | ElasticSDK Documentation",
    "keywords": "Class Pipeline.MissingInputException Inheritance object Exception Pipeline.MissingInputException Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class Pipeline.MissingInputException : Exception Constructors MissingInputException() Declaration public MissingInputException() MissingInputException(string) Declaration public MissingInputException(string message) Parameters Type Name Description string message"
  },
  "api/Holoride.ElasticSDK.PipelineWorkerBase.html": {
    "href": "api/Holoride.ElasticSDK.PipelineWorkerBase.html",
    "title": "Class PipelineWorkerBase | ElasticSDK Documentation",
    "keywords": "Class PipelineWorkerBase Inheritance object PipelineWorkerBase DataProviderWorker<TDataType> MapWorker PoseSetWorker SpawnerWorker Implements IPipelineWorker Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public abstract class PipelineWorkerBase : IPipelineWorker Properties CurrentGenerationContext Gets or sets the current generation context. Declaration public GenerationContext CurrentGenerationContext { get; set; } Property Value Type Description GenerationContext GenerationSettings Gets the immutable data that cannot be changed during the whole generation loop. Declaration public GenerationSettings GenerationSettings { get; } Property Value Type Description GenerationSettings GenerationState Gets the current state of the generation process and will be updated over time. Declaration public GenerationState GenerationState { get; } Property Value Type Description GenerationState HasMissingMandatoryInputInHierarchy Gets a value indicating whether this worker has any missing mandatory input in hierarchy. Declaration public bool HasMissingMandatoryInputInHierarchy { get; } Property Value Type Description bool Inputs Gets the input IPipelineWorkers to be processed before this worker. Declaration public IEnumerable<IPipelineWorker> Inputs { get; } Property Value Type Description IEnumerable<IPipelineWorker> IsGatheringResources Gets or sets a value indicating whether this node is gathering resources. Declaration public bool IsGatheringResources { get; set; } Property Value Type Description bool IsProcessing Gets or sets a value indicating whether this node is processing. Declaration public bool IsProcessing { get; set; } Property Value Type Description bool MissingMandatoryInputs Gets all missing mandatory inputs. Declaration public IReadOnlyCollection<string> MissingMandatoryInputs { get; } Property Value Type Description IReadOnlyCollection<string> Pipeline Gets or sets the pipeline this worker currently belongs to. A worker can always only belong to a single pipeline. Declaration public Pipeline Pipeline { get; set; } Property Value Type Description Pipeline Methods AddInput(string, IPipelineWorker) Adds an input PipelineWorker. Declaration public void AddInput(string id, IPipelineWorker pipelineWorker) Parameters Type Name Description string id The id of the input. IPipelineWorker pipelineWorker The PipelineWorker to set as an input. AddMissingMandatoryInput(string) Adds a missing input. Declaration public void AddMissingMandatoryInput(string id) Parameters Type Name Description string id The id of the missing input. CallCleanUp() Cleans up this node. Declaration [Obsolete(\"Use Dispose() instead.\")] public virtual void CallCleanUp() CallGatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) Gathers the resources required for this node in order to be processed. Declaration public virtual UniTask<LoadResourceResult> CallGatherResourcesAsync(GenerationContext context, IProgress<float> onProgressUpdate = null, CancellationToken cancellationToken = default) Parameters Type Name Description GenerationContext context Contains the immutable meta-information of a single update iteration. IProgress<float> onProgressUpdate The feedback function passing the (down)loading progress [0, 1]. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask<T><LoadResourceResult> CallInit() Initializes this node. Declaration public virtual void CallInit() CallInitResources() Initializes the resources required for this node in order to be processed. Declaration public virtual void CallInitResources() CallProcessAsync(GenerationContext, IProgress<float>, CancellationToken) The default process function that is called for every CompositingNode. Declaration public virtual UniTask CallProcessAsync(GenerationContext context, IProgress<float> onProgressUpdate = null, CancellationToken cancellationToken = default) Parameters Type Name Description GenerationContext context Contains the immutable meta-information of a single update iteration. IProgress<float> onProgressUpdate Called with relative progress in [0, 1]. May be called from another thread. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask CleanUp() Declaration [Obsolete(\"Use Dispose() instead.\")] public virtual void CleanUp() Dispose() Declaration public virtual void Dispose() GatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) Gathers resources for this node. Declaration protected virtual UniTask<LoadResourceResult> GatherResourcesAsync(GenerationContext context, IProgress<float> onProgressUpdate, CancellationToken cancellationToken) Parameters Type Name Description GenerationContext context Contains the immutable meta-information of a single update iteration. IProgress<float> onProgressUpdate Called with current relative processing progress in [0, 1]. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask<T><LoadResourceResult> GetInput(string) Gets an input PipelineWorker. Declaration public IPipelineWorker GetInput(string id) Parameters Type Name Description string id The id of the input. Returns Type Description IPipelineWorker The corresponding input PipelineWorker. GetInput<T>(string) Declaration public T GetInput<T>(string id) where T : class, IPipelineWorker Parameters Type Name Description string id Returns Type Description T Type Parameters Name Description T Init() Initializes this worker when generation starts. Declaration public virtual void Init() InitResources() Initializes the resources required for this node in order to be processed. Declaration public virtual void InitResources() ProcessAsync(GenerationContext, IProgress<float>, CancellationToken) Processes this node. Declaration protected virtual UniTask ProcessAsync(GenerationContext context, IProgress<float> onProgressUpdate, CancellationToken cancellationToken) Parameters Type Name Description GenerationContext context Contains the immutable meta-information of a single update iteration. IProgress<float> onProgressUpdate Called with current relative processing progress in [0, 1]. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask Implements IPipelineWorker"
  },
  "api/Holoride.ElasticSDK.Player.html": {
    "href": "api/Holoride.ElasticSDK.Player.html",
    "title": "Class Player | ElasticSDK Documentation",
    "keywords": "Class Player The data obtained by the vehicle sensors. Inheritance object Object Component Behaviour MonoBehaviour Player Implements IStateReceiverLocalizationEventListener IStateReceiverListener Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [DefaultExecutionOrder(-5000)] [DisallowMultipleComponent] [Obsolete(\"Player is obsolete. Instead, use the VehiclePosition and VehicleRotation components for moving a game object as seen in the Vehicle prefab. Use the LocalizationEvents component to react to state changes. Use StateReceiver.VehicleSensorState for sensor data access or subscribe to the events exposed by RecenterOffsetManager and StateReceiver.\")] [HelpURL(\"http://localhost:8080/api/Holoride.ElasticSDK.Player.html\")] public class Player : MonoBehaviour, IStateReceiverLocalizationEventListener, IStateReceiverListener Fields OnConnect Declaration [Tooltip(\"Fired when connection to the underlying vehicle localization service has been successfully established.\")] public UnityEvent OnConnect Field Value Type Description UnityEvent OnConnectError Declaration [Tooltip(\"Fired when connection to the underlying vehicle localization service failed.\")] public StringUnityEvent OnConnectError Field Value Type Description StringUnityEvent OnDisconnect Declaration [Tooltip(\"Fired when connection to the underlying vehicle localization service has been lost or was closed successfully.\")] public UnityEvent OnDisconnect Field Value Type Description UnityEvent OnRouteChanged Declaration [Tooltip(\"Fired when the route has changed.\")] public UnityEvent OnRouteChanged Field Value Type Description UnityEvent OnUserRecenter Declaration [Tooltip(\"Fired when the user triggered a successful manual recenter via button press.\")] public UnityEvent OnUserRecenter Field Value Type Description UnityEvent OnVehicleLocalizationAvailable Declaration [Tooltip(\"Fired when vehicle localization becomes available.\")] public Player.VehicleLocalizationStatusUnityEvent OnVehicleLocalizationAvailable Field Value Type Description Player.VehicleLocalizationStatusUnityEvent OnVehicleLocalizationReset Declaration [Tooltip(\"Fired when the service reports that localization has been reset.\")] public UnityEvent OnVehicleLocalizationReset Field Value Type Description UnityEvent OnVehicleLocalizationStart Declaration [Tooltip(\"Called as soon as the first geo coordinate is set.\")] public UnityEvent OnVehicleLocalizationStart Field Value Type Description UnityEvent OnVehicleLocalizationUnavailable Declaration [Tooltip(\"Fired when vehicle localization becomes unavailable.\")] public Player.VehicleLocalizationStatusUnityEvent OnVehicleLocalizationUnavailable Field Value Type Description Player.VehicleLocalizationStatusUnityEvent Methods OnMapAccessTokenReceived(string) Declaration public void OnMapAccessTokenReceived(string token) Parameters Type Name Description string token Recenter() Sends broadcast to service to trigger a recenter process for the vehicle. Declaration public void Recenter() Remarks Delayed by 3 frames to avoid race conditions. Events OnVehicleLocalizationReceivedAsync Declaration public event Action<VehicleSensorState> OnVehicleLocalizationReceivedAsync Event Type Type Description Action<VehicleSensorState> Explicit Interface Implementations IStateReceiverLocalizationEventListener.OnConnect() Declaration void IStateReceiverLocalizationEventListener.OnConnect() IStateReceiverLocalizationEventListener.OnConnectError(StateReceiverInitializationError) Declaration void IStateReceiverLocalizationEventListener.OnConnectError(StateReceiverInitializationError error) Parameters Type Name Description StateReceiverInitializationError error IStateReceiverLocalizationEventListener.OnDisconnect() Declaration void IStateReceiverLocalizationEventListener.OnDisconnect() IStateReceiverLocalizationEventListener.OnRouteChanged() Declaration void IStateReceiverLocalizationEventListener.OnRouteChanged() IStateReceiverLocalizationEventListener.OnVehicleLocalizationReceivedAsync(VehicleSensorState) Declaration void IStateReceiverLocalizationEventListener.OnVehicleLocalizationReceivedAsync(VehicleSensorState state) Parameters Type Name Description VehicleSensorState state IStateReceiverLocalizationEventListener.OnVehicleLocalizationReset() Declaration void IStateReceiverLocalizationEventListener.OnVehicleLocalizationReset() IStateReceiverLocalizationEventListener.OnVehicleLocalizationStart() Declaration void IStateReceiverLocalizationEventListener.OnVehicleLocalizationStart() IStateReceiverLocalizationEventListener.OnVehicleLocalizationStatusChanged(VehicleLocalizationStatus) Declaration void IStateReceiverLocalizationEventListener.OnVehicleLocalizationStatusChanged(VehicleLocalizationStatus status) Parameters Type Name Description VehicleLocalizationStatus status Implements IStateReceiverLocalizationEventListener IStateReceiverListener"
  },
  "api/Holoride.ElasticSDK.Player.VehicleLocalizationStatusUnityEvent.html": {
    "href": "api/Holoride.ElasticSDK.Player.VehicleLocalizationStatusUnityEvent.html",
    "title": "Class Player.VehicleLocalizationStatusUnityEvent | ElasticSDK Documentation",
    "keywords": "Class Player.VehicleLocalizationStatusUnityEvent Inheritance object UnityEventBase UnityEvent<VehicleLocalizationStatus> Player.VehicleLocalizationStatusUnityEvent Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [Serializable] public class Player.VehicleLocalizationStatusUnityEvent : UnityEvent<VehicleLocalizationStatus>"
  },
  "api/Holoride.ElasticSDK.PooledObject.html": {
    "href": "api/Holoride.ElasticSDK.PooledObject.html",
    "title": "Class PooledObject | ElasticSDK Documentation",
    "keywords": "Class PooledObject Component used to mark GameObjects as poolable by the ElasticObjectPoolManager, and with which settings to pool them. The settings are grabbed from the original prefab. On instances of the prefab, this component is used to track the pool the instance originated from, so that it can be returned to it on release. Inheritance object Object Component Behaviour MonoBehaviour PooledObject Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [HelpURL(\"http://localhost:8080/api/Holoride.ElasticSDK.PooledObject.html\")] public class PooledObject : MonoBehaviour Fields BeforeReturnToPool UnityEvent invoked right before game object returns to pool. This event can be used to execute de-spawning behavior like animations or in general behavior that should happen outside of Unity's life cycle calls. Declaration [FormerlySerializedAs(\"ReturnedToPool\")] public UnityEvent BeforeReturnToPool Field Value Type Description UnityEvent Init UnityEvent invoked when object has been instantiated and initially added to the pool. This event can be used to invoke behavior that should exclusively happen when an instance of the poolable object is created. Declaration public UnityEvent Init Field Value Type Description UnityEvent RetrievedFromPool UnityEvent invoked when object has been taken from pool. This event can be used to execute spawning behavior before the game object instance is set to its prefab's active state. Declaration public UnityEvent RetrievedFromPool Field Value Type Description UnityEvent Properties AutoReturnToPool Gets or sets a value indicating whether game objects automatically return to the pool when they fall outside the Spawners Moving Grid. If this is set to false, one must call ReturnToPool() to manually return the game object. This can be useful to play exit animations before an object returns. Declaration public bool AutoReturnToPool { get; set; } Property Value Type Description bool Methods ReturnToPool() Used to manually return a poolable game object back to its pool, when AutoReturnToPool is set to false. Declaration public bool ReturnToPool() Returns Type Description bool Returns false if the pool, the poolable object was associated with, is null. Otherwise returns true."
  },
  "api/Holoride.ElasticSDK.PoseSetWorker.html": {
    "href": "api/Holoride.ElasticSDK.PoseSetWorker.html",
    "title": "Class PoseSetWorker | ElasticSDK Documentation",
    "keywords": "Class PoseSetWorker A worker that can be added to a Pipeline in order to generate a list of GlobalPoses during the phase. Inheritance object PipelineWorkerBase PoseSetWorker PoseSetNode.PoseSetWorker<T> Implements IPipelineWorker Inherited Members PipelineWorkerBase.GenerationSettings PipelineWorkerBase.GenerationState PipelineWorkerBase.CurrentGenerationContext PipelineWorkerBase.Pipeline PipelineWorkerBase.IsGatheringResources PipelineWorkerBase.IsProcessing PipelineWorkerBase.Inputs PipelineWorkerBase.MissingMandatoryInputs PipelineWorkerBase.AddMissingMandatoryInput(string) PipelineWorkerBase.HasMissingMandatoryInputInHierarchy PipelineWorkerBase.AddInput(string, IPipelineWorker) PipelineWorkerBase.GetInput(string) PipelineWorkerBase.GetInput<T>(string) PipelineWorkerBase.InitResources() PipelineWorkerBase.CallInitResources() PipelineWorkerBase.Init() PipelineWorkerBase.GatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.CallGatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.ProcessAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.Dispose() PipelineWorkerBase.CleanUp() PipelineWorkerBase.CallCleanUp() Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] public class PoseSetWorker : PipelineWorkerBase, IPipelineWorker Properties ReadPoses Gets the list of poses to read from. Declaration public IReadOnlyList<GlobalPose> ReadPoses { get; } Property Value Type Description IReadOnlyList<GlobalPose> WritePoses Gets the list of poses to write to. Declaration protected IList<GlobalPose> WritePoses { get; } Property Value Type Description IList<GlobalPose> Methods AddPose(GlobalPose) Adds a pose to the WritePoses. Declaration public void AddPose(GlobalPose pose) Parameters Type Name Description GlobalPose pose The pose pose to add. AddPose(GlobalPosition, Quaternion) Creates a new pose and adds it to the WritePoses. Declaration public void AddPose(GlobalPosition position, Quaternion rotation) Parameters Type Name Description GlobalPosition position The position of the pose to be created. Quaternion rotation The rotation of the pose to be created. AddPose(GlobalPosition) Creates a new pose and adds it to the WritePoses. Declaration public void AddPose(GlobalPosition position) Parameters Type Name Description GlobalPosition position The position of the pose to be created. AddPosesFromGeoCoordinates(IList<GeoCoordinate>, GeoCoordinate, GlobalBounds) Converts a list of GeoCoordinates into poses and adds those within the bounds to the WritePoses. Declaration public void AddPosesFromGeoCoordinates(IList<GeoCoordinate> geoCoordinates, GeoCoordinate pivot, GlobalBounds bounds) Parameters Type Name Description IList<GeoCoordinate> geoCoordinates A list of GeoCoordinates to be converted and added. GeoCoordinate pivot The projection pivot to convert a GeoCoordinate into a GlobalPosition in cartesian space. GlobalBounds bounds The permitted area to add coordinates. CallInit() Initializes this node. Declaration public override sealed void CallInit() Overrides PipelineWorkerBase.CallInit() CallProcessAsync(GenerationContext, IProgress<float>, CancellationToken) The default process function that is called for every CompositingNode. Declaration public override sealed UniTask CallProcessAsync(GenerationContext context, IProgress<float> onProgressUpdate, CancellationToken cancellationToken = default) Parameters Type Name Description GenerationContext context Contains the immutable meta-information of a single update iteration. IProgress<float> onProgressUpdate Called with relative progress in [0, 1]. May be called from another thread. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask Overrides PipelineWorkerBase.CallProcessAsync(GenerationContext, IProgress<float>, CancellationToken) Implements IPipelineWorker"
  },
  "api/Holoride.ElasticSDK.PrefabInstantiationContext.html": {
    "href": "api/Holoride.ElasticSDK.PrefabInstantiationContext.html",
    "title": "Class PrefabInstantiationContext | ElasticSDK Documentation",
    "keywords": "Class PrefabInstantiationContext Context common to all prefab instantiation implementations, exposing them to IPipelineWorkers. Inheritance object PrefabInstantiationContext Implements IGenerationContext Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public class PrefabInstantiationContext : IGenerationContext Constructors PrefabInstantiationContext(IPrefabInstantiationProvider) Declaration public PrefabInstantiationContext(IPrefabInstantiationProvider provider) Parameters Type Name Description IPrefabInstantiationProvider provider Methods Despawn(GameObject) Declaration public bool Despawn(GameObject instance) Parameters Type Name Description GameObject instance Returns Type Description bool Init(GameObject, Action<GameObject>) Declaration [Obsolete(\"Use the async overload instead.\")] public IEnumerator Init(GameObject prefab, Action<GameObject> initAction = null) Parameters Type Name Description GameObject prefab Action<GameObject> initAction Returns Type Description IEnumerator InitAsync(GameObject, Action<GameObject>, CancellationToken) Declaration public UniTask InitAsync(GameObject prefab, Action<GameObject> initAction = null, CancellationToken cancellationToken = default) Parameters Type Name Description GameObject prefab Action<GameObject> initAction CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask Spawn(GameObject, Vector3, Quaternion, Vector3, Func<GameObject, UniTask>, CancellationToken) Declaration public UniTask<(bool Success, GameObject Result)> Spawn(GameObject prefab, Vector3 position, Quaternion rotation, Vector3 scale, Func<GameObject, UniTask> preSpawnAction = null, CancellationToken cancellationToken = default) Parameters Type Name Description GameObject prefab Vector3 position Quaternion rotation Vector3 scale Func<GameObject, Cysharp.Threading.Tasks.UniTask> preSpawnAction CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask<T><(bool Success, GameObject Result)> Implements IGenerationContext"
  },
  "api/Holoride.ElasticSDK.RasterizationUtils.DrawStyle.html": {
    "href": "api/Holoride.ElasticSDK.RasterizationUtils.DrawStyle.html",
    "title": "Enum RasterizationUtils.DrawStyle | ElasticSDK Documentation",
    "keywords": "Enum RasterizationUtils.DrawStyle Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public enum RasterizationUtils.DrawStyle Fields Name Description Fill Outline"
  },
  "api/Holoride.ElasticSDK.RasterizationUtils.html": {
    "href": "api/Holoride.ElasticSDK.RasterizationUtils.html",
    "title": "Class RasterizationUtils | ElasticSDK Documentation",
    "keywords": "Class RasterizationUtils A collection of useful rasterization helpers. Inheritance object RasterizationUtils Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public static class RasterizationUtils Methods SetMapRenderMatrix(CommandBuffer, Vector2, float, float) Declaration public static void SetMapRenderMatrix(CommandBuffer commandBuffer, Vector2 extents, float near = -100, float far = 100) Parameters Type Name Description CommandBuffer commandBuffer Vector2 extents float near float far"
  },
  "api/Holoride.ElasticSDK.RecenterOffsetManager.html": {
    "href": "api/Holoride.ElasticSDK.RecenterOffsetManager.html",
    "title": "Class RecenterOffsetManager | ElasticSDK Documentation",
    "keywords": "Class RecenterOffsetManager Access to current recenter offset, i.e. the delta between headset forward direction and vehicle forward direction. This is relevant for headsets using 3-DoF tracking, since their tracking frame of reference is not local to the vehicle (as opposed to 6-dof), but in the same global space as the vehicle itself. We manage this offset manually to ensure consistent compatibility across different headsets. For some there is no event to be notified when the user caused a system-driven recenter, for others there is no API to trigger a system-driven recenter. This manages the application local recenter offset, which may be different to the global recenter offset shared across multiple applications. This is due to the fact that the application of the recenter offset depends on localization data, specifically the vehicle heading. While the vehicle heading is not available, we must operate in an application local state, to still allow users to recenter. As such, we must be able to operate in the two states \"heading available\" and \"heading unavailable\". For the former, behavior is trivial, since we can apply new global recenter offset directly (sent from either drift mitigation, system driven user recenter logic, user recenter in other applications) and directly apply new global offset values. The \"heading unavailable\" state is more complex, as it introduces the need for temporary, local recenter offset values, while still: keeping the last received global recenter offset so it can be applied as soon as global vehicle heading is available. keeping the local vehicle heading when applying a local recenter offset so we can compute the delta to the global recenter offset as soon as global vehicle heading is available. Once global vehicle heading becomes available, we can transform the pending global or local recenter offset, depending on which one is more recent: local to global: add delta of local vehicle heading at time of setting local recenter offset to global vehicle heading. global to local: instantly apply pending global recenter offset. The intuition here is that the global vehicle heading will be used once available, so the local heading \"snaps\" to the the global one, and as such any values computed in relation to it have to be adjusted as well. Whereas the global recenter offset is already in relation to the global vehicle heading. Inheritance object RecenterOffsetManager Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public static class RecenterOffsetManager Properties CurrentRecenterOffset Gets the current applicable recenter offset. This value may change slowly over time when applying small changes to account for headset sensor drift. Depending on the current platform, such changes are detected automatically and applied to the global recenter offset to ensure the user continues to perceive forward as the vehicle forward direction. This value abstracts the \"heading available\" and \"heading unavailable\" states: it returns the local recenter offset while global vehicle heading is unavailable and the global recenter offset while global vehicle heading is available. Declaration public static float CurrentRecenterOffset { get; } Property Value Type Description float Methods ComputeAndUpdateRecenterOffset(float) Computes and updates the current recenter offset based on the current headset rotation. Declaration public static void ComputeAndUpdateRecenterOffset(float headsetHeadingAngle) Parameters Type Name Description float headsetHeadingAngle The headset heading angle relative to the headset's internal coordinate system. In an XR rig, this value usually corresponds to Camera.main.transform.localEulerAngles.y. RequestUserRecenter() This delegates recenter operation to listeners, to avoid magic lookups of e.g. the main camera here. Typically this will result in the Player component to perform a Vehicle.Recenter(). Declaration public static void RequestUserRecenter() UpdateRecenterOffset(float) Updates the current recenter offset based on the current headset rotation. Declaration [Obsolete(\"Use ComputeAndUpdateRecenterOffset which takes the headset heading angle (i.e. the local camera angle) rather than the angle between camera and vehicle as a parameter.\", false)] public static void UpdateRecenterOffset(float headsetToVehicle) Parameters Type Name Description float headsetToVehicle The current signed delta angle between headset forward direction and vehicle forward direction. Events UserRecenterPerformed Fired when a recenter operation by a user was performed. This can either be triggered locally via ComputeAndUpdateRecenterOffset(float) or via a backend / platform specific service where user recenter input is handled externally. Declaration public static event Action UserRecenterPerformed Event Type Type Description Action UserRecenterRequested Fired when a recenter operation should be performed, resulting in a call to ComputeAndUpdateRecenterOffset(float). This is triggered by calls to RequestUserRecenter() and when external user recenter notifications are received but no global vehicle heading offset is available. The latter is primarily relevant when in stationary mode or when no localization data is available, yet. Declaration public static event Action UserRecenterRequested Event Type Type Description Action"
  },
  "api/Holoride.ElasticSDK.Replay.html": {
    "href": "api/Holoride.ElasticSDK.Replay.html",
    "title": "Class Replay | ElasticSDK Documentation",
    "keywords": "Class Replay A replay is a generic representation of some recorded data that may be used to simulate a ride. Inheritance object Object ScriptableObject Replay Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public abstract class Replay : ScriptableObject Fields timeInterval Declaration [Tooltip(\"The time interval of the selected recording file to play, in seconds.\")] [SerializeField] protected Interval timeInterval Field Value Type Description Interval Properties Route Gets the route representing the data returned by the GetStream() method but not limited to the selected interval. This is used for route related information but can be null. Declaration public abstract IRoute Route { get; } Property Value Type Description IRoute TimeInterval Gets or sets the time interval of the selected recording file to play, in seconds. Declaration public Interval TimeInterval { get; set; } Property Value Type Description Interval Methods GetStream() Returns a IReplayStream that may be used to iterate over the data in this replay. Declaration public abstract IReplayStream GetStream() Returns Type Description IReplayStream The stream used for playing back this replay. OnValidate() Declaration protected virtual void OnValidate() UnclampedSecondsToMicroseconds(double) Declaration protected static long UnclampedSecondsToMicroseconds(double value) Parameters Type Name Description double value Returns Type Description long"
  },
  "api/Holoride.ElasticSDK.ReplayStateReceiverBackend.html": {
    "href": "api/Holoride.ElasticSDK.ReplayStateReceiverBackend.html",
    "title": "Class ReplayStateReceiverBackend | ElasticSDK Documentation",
    "keywords": "Class ReplayStateReceiverBackend Receives .holo file state. Inheritance object Object ScriptableObject StateReceiverBackend ReplayStateReceiverBackend Inherited Members StateReceiverBackend.State StateReceiverBackend.AllListeners StateReceiverBackend.LocalizationListeners StateReceiverBackend.AddListener(IStateReceiverListener) StateReceiverBackend.RemoveListener(IStateReceiverListener) StateReceiverBackend.NotifyListenerConfigurationChanged() StateReceiverBackend.Pivot StateReceiverBackend.IsEnabled StateReceiverBackend.OnListenerAdded(IStateReceiverListener) StateReceiverBackend.OnListenerRemoved(IStateReceiverListener) StateReceiverBackend.OnStateUpdated() StateReceiverBackend.OnStateReceivedAsync(VehicleSensorState) StateReceiverBackend.OnRouteChanged() StateReceiverBackend.OnMapAccessTokenReceived(string) StateReceiverBackend.UpdatePivot(GeoCoordinate) Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.StateReceivers.dll Syntax [PublicAPI] public sealed class ReplayStateReceiverBackend : StateReceiverBackend Properties InterpolationFrameSize Gets or sets the interpolation frame size controls the delay data is presented at, where this delay window is used to interpolate underlying data, to ensure it is played back at the same rate the underlying records represent. Disabling interpolation by setting it to zero may result in rubber-banding. The window size is specified in seconds. Declaration public float InterpolationFrameSize { get; set; } Property Value Type Description float IsPaused Gets or sets a value indicating whether playback of the underlying data is paused. This differs from disabling and re-enabling this component in that it will not reset the playback state, but resume playback where it was previously paused. Declaration public bool IsPaused { get; set; } Property Value Type Description bool Loop Gets or sets a value indicating whether the playback of the underlying recording should loop. Note that playback is stopped by disabling this component. Setting this to true will not automatically enable this component. Declaration public bool Loop { get; set; } Property Value Type Description bool Replay Gets or sets the underlying replay that is currently used for playback. Setting this to a new value will cause playback to be re-started. Declaration public Replay Replay { get; set; } Property Value Type Description Replay Exceptions Type Condition ArgumentNullException Thrown if the specified value is null. Route Gets or sets the current route set in the replay. Declaration public override IRoute Route { get; protected set; } Property Value Type Description IRoute Overrides StateReceiverBackend.Route Exceptions Type Condition NotSupportedException Thrown when trying to set the route. TravelInformationState Gets the travel information based on the current position along the Route. Declaration public override TravelInformationState TravelInformationState { get; } Property Value Type Description TravelInformationState Overrides StateReceiverBackend.TravelInformationState VehicleSensorState Gets or sets the most recently received state. This may be updated from worker threads, so when using the value in conditionals it is recommended to store the value in a local variable. Declaration public override VehicleSensorState VehicleSensorState { get; protected set; } Property Value Type Description VehicleSensorState Overrides StateReceiverBackend.VehicleSensorState Methods Disable() Declaration public override void Disable() Overrides StateReceiverBackend.Disable() Enable() Declaration public override void Enable() Overrides StateReceiverBackend.Enable() OnApplicationResume() Declaration public override void OnApplicationResume() Overrides StateReceiverBackend.OnApplicationResume() OnDestroy() Declaration protected override void OnDestroy() Overrides StateReceiverBackend.OnDestroy() Seek(float) Declaration public void Seek(float deltaInSeconds) Parameters Type Name Description float deltaInSeconds Seek(TimeSpan) Tries to seek by the specified amount of seconds. Advances playback by the specified amount of time if the specified number is positive, rewinds playback for negative values. This will fire OnVehicleLocalizationReset(). Note that this will cause the player position to interpolate towards the position after the seek. Also note that this does not cause generation state to be re-evaluated. For content generation, a seek is originally just a potentially large jump in player position. In particular when rewinding it is strongly suggested to manually stop and restart generation to avoid unexpected results. Declaration public void Seek(TimeSpan delta) Parameters Type Name Description TimeSpan delta The time delta to apply, in seconds. Update() Declaration public override void Update() Overrides StateReceiverBackend.Update()"
  },
  "api/Holoride.ElasticSDK.ReplayStream.html": {
    "href": "api/Holoride.ElasticSDK.ReplayStream.html",
    "title": "Class ReplayStream | ElasticSDK Documentation",
    "keywords": "Class ReplayStream Base implementation for IReplayStream taking care of some boilerplate. Inheritance object ReplayStream Implements IReplayStream Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public abstract class ReplayStream : IReplayStream Properties Current Declaration public abstract VehicleSensorState Current { get; } Property Value Type Description VehicleSensorState CurrentDistance Gets the total traveled distance in the replay stream. Note that this value does not necessarily start at zero, if the TimeInterval is configured to start at a non-zero time. Declaration public abstract double CurrentDistance { get; } Property Value Type Description double CurrentMicroseconds Gets the total elapsed microseconds in the replay stream. Note that this value does not necessarily start at zero, if the TimeInterval is configured to start at a non-zero time. Declaration public abstract long CurrentMicroseconds { get; } Property Value Type Description long Methods Dispose() Declaration public virtual void Dispose() MoveNext() Declaration public abstract bool MoveNext() Returns Type Description bool Reset() Declaration public abstract void Reset() Seek(TimeSpan) Seeks along the replay stream by the specified amount of time. Declaration public abstract TimeSpan Seek(TimeSpan delta) Parameters Type Name Description TimeSpan delta The amount of time to seek forwards or backwards in the stream. Returns Type Description TimeSpan The actual time delta in the stream to the previous time. Implements IReplayStream"
  },
  "api/Holoride.ElasticSDK.RequireGenerationContextAttribute.html": {
    "href": "api/Holoride.ElasticSDK.RequireGenerationContextAttribute.html",
    "title": "Class RequireGenerationContextAttribute | ElasticSDK Documentation",
    "keywords": "Class RequireGenerationContextAttribute Used to annotate workers which require some implementation of IGenerationContext. This is used to only generate and compute these context implementations when any node in the graph actually uses them. Inheritance object Attribute RequireGenerationContextAttribute Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Class)] [BaseTypeRequired(typeof(IPipelineWorker))] public class RequireGenerationContextAttribute : Attribute Constructors RequireGenerationContextAttribute(Type) Declaration public RequireGenerationContextAttribute(Type contextType) Parameters Type Name Description Type contextType Fields ContextType The type of the IGenerationContext implementation the annotated worker uses. Declaration public readonly Type ContextType Field Value Type Description Type"
  },
  "api/Holoride.ElasticSDK.RingBufferFilter-1.html": {
    "href": "api/Holoride.ElasticSDK.RingBufferFilter-1.html",
    "title": "Class RingBufferFilter<T> | ElasticSDK Documentation",
    "keywords": "Class RingBufferFilter<T> Uses a queue to Shift: For every enqueued value, dequeue is called until the maxSampleCount is reached. Inheritance object RingBufferFilter<T> Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class RingBufferFilter<T> Type Parameters Name Description T The type of the elements stored in the ring buffer. Methods SampleAll(Action<T, int>) Applies the filterFunction to every queue sample. Declaration public void SampleAll(Action<T, int> filterFunction) Parameters Type Name Description Action<T, int> filterFunction The filter function to apply. SampleAllNonAlloc<TOut>(TOut, Func<TOut, T, int, TOut>) Applies the filterFunction to every queue sample. Declaration public TOut SampleAllNonAlloc<TOut>(TOut seed, Func<TOut, T, int, TOut> filterFunction) Parameters Type Name Description TOut seed The seed value for aggregating sample values. Func<TOut, T, int, TOut> filterFunction The function the filter applies per sample. The first parameter is the accumulator, The second parameter is the current sample. The third parameter the total count of samples. Returns Type Description TOut Type Parameters Name Description TOut Shift(T, int, int) Enqueues the newValue and dequeues overlapping entries. Declaration public void Shift(T newValue, int maxSampleCount = 1, int sampleCountDecreasingStepSize = 1) Parameters Type Name Description T newValue The new value to enqueue. int maxSampleCount The maximum number of samples to enqueue. int sampleCountDecreasingStepSize The step size how many samples should be dequeued at a time if maxSampleCount is decreasing. ShiftAndSampleAll(T, Action<T, int>, int, int) Shifts with the newValue and applies the filter. Declaration public void ShiftAndSampleAll(T newValue, Action<T, int> filterFunction, int maxSampleCount = 1, int sampleCountDecreasingStepSize = 1) Parameters Type Name Description T newValue The new value to enqueue. Action<T, int> filterFunction The function the filter applies per sample. The first parameter is the current sample. The second parameter the total count of samples. int maxSampleCount The maximum number of samples to enqueue. int sampleCountDecreasingStepSize The step size how many samples should be dequeued at a time if maxSampleCount is decreased. ShiftAndSampleAllNonAlloc<TOut>(T, TOut, Func<TOut, T, int, TOut>, int, int) Shifts with the newValue and applies the filter. Declaration public TOut ShiftAndSampleAllNonAlloc<TOut>(T newValue, TOut seed, Func<TOut, T, int, TOut> filterFunction, int maxSampleCount = 1, int sampleCountDecreasingStepSize = 1) Parameters Type Name Description T newValue The new value to enqueue. TOut seed The seed value for aggregating sample values. Func<TOut, T, int, TOut> filterFunction The function the filter applies per sample. The first parameter is the accumulator, The second parameter is the current sample. The third parameter the total count of samples. int maxSampleCount The maximum number of samples to enqueue. int sampleCountDecreasingStepSize The step size how many samples should be dequeued at a time if maxSampleCount is decreased. Returns Type Description TOut Type Parameters Name Description TOut"
  },
  "api/Holoride.ElasticSDK.RouteGeometryBender.html": {
    "href": "api/Holoride.ElasticSDK.RouteGeometryBender.html",
    "title": "Class RouteGeometryBender | ElasticSDK Documentation",
    "keywords": "Class RouteGeometryBender Bends the given renderer and collision mesh along the route spline, after it got spawned by a RouteIntervalSpawner. Inheritance object Object Component Behaviour MonoBehaviour RouteGeometryBender Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [RequireComponent(typeof(MeshRenderer))] [RequireComponent(typeof(MeshFilter))] [AddComponentMenu(\"holoride/Route Geometry Bender\")] [HelpURL(\"http://localhost:8080/api/Holoride.ElasticSDK.RouteGeometryBender.html\")] public class RouteGeometryBender : MonoBehaviour Fields BendingResolution The sampling resolution along the spline to bend the meshes with. Declaration [Tooltip(\"The sampling resolution along the spline to bend the meshes with.\")] public int BendingResolution Field Value Type Description int MeshCollider The mesh collider containing the collision mesh to bend. Declaration [Tooltip(\"The mesh collider containing the collision mesh to bend.\")] public MeshCollider MeshCollider Field Value Type Description MeshCollider MeshFilter The mesh filter containing the render mesh to bend. Declaration [Tooltip(\"The mesh filter containing the render mesh to bend.\")] public MeshFilter MeshFilter Field Value Type Description MeshFilter MeshRenderer The mesh renderer. Declaration [Tooltip(\"The mesh renderer.\")] public MeshRenderer MeshRenderer Field Value Type Description MeshRenderer OnBendingFinished The event that is called when the bending has finished. Declaration public UnityEvent OnBendingFinished Field Value Type Description UnityEvent Methods Awake() Implements the Start method of the MonoBehaviour life-cycle. Declaration public void Awake() BendGameObject(Spline, double) Bends the render mesh and the collision mesh with the spline curvature. Declaration public void BendGameObject(Spline spline, double placingDistance) Parameters Type Name Description Spline spline The spline to bend along. double placingDistance The placing distance. BendGameObject(List<Matrix4x4>, List<Matrix4x4>) Declaration public void BendGameObject(List<Matrix4x4> bendingMatrices, List<Matrix4x4> innerMatrices) Parameters Type Name Description List<Matrix4x4> bendingMatrices List<Matrix4x4> innerMatrices BendGameObject(List<Matrix4x4>) Declaration public void BendGameObject(List<Matrix4x4> bendingMatrices) Parameters Type Name Description List<Matrix4x4> bendingMatrices"
  },
  "api/Holoride.ElasticSDK.RouteSegments.html": {
    "href": "api/Holoride.ElasticSDK.RouteSegments.html",
    "title": "Class RouteSegments | ElasticSDK Documentation",
    "keywords": "Class RouteSegments A route segment defining spawn intervals. Inheritance object RouteSegments Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [Serializable] public class RouteSegments Properties Bounds Declaration public Interval Bounds { get; } Property Value Type Description Interval Count Declaration public int Count { get; } Property Value Type Description int Empty Gets an empty collection of route segments. Declaration public static RouteSegments Empty { get; } Property Value Type Description RouteSegments IsReadOnly Declaration public bool IsReadOnly { get; } Property Value Type Description bool this[int] Declaration public Interval this[int index] { get; } Parameters Type Name Description int index Property Value Type Description Interval Whole Gets a collection containing the interval [0,1]. Declaration public static RouteSegments Whole { get; } Property Value Type Description RouteSegments Methods Add(Interval) Declaration public void Add(Interval interval) Parameters Type Name Description Interval interval AddSegment(double, double) Adds an interval. Declaration public void AddSegment(double min, double max) Parameters Type Name Description double min The start of the interval within the boundaries 0.0 and 1.0. double max The end of the interval within the boundaries 0.0 and 1.0. Clear() Declaration public void Clear() Contains(Interval) Declaration public bool Contains(Interval item) Parameters Type Name Description Interval item Returns Type Description bool Contains(double, double) Tests whether the route contains the given segment. Declaration public bool Contains(double min, double max) Parameters Type Name Description double min The start of the interval within the boundaries 0.0 and 1.0. double max The end of the interval within the boundaries 0.0 and 1.0. Returns Type Description bool Whether the route contains the given segment. Contains(double) Checks if a given double value is within an interval. Declaration public bool Contains(double x) Parameters Type Name Description double x The value to check for. Returns Type Description bool Whether the interval contains the given value. CopyTo(Interval[], int) Declaration public void CopyTo(Interval[] array, int arrayIndex) Parameters Type Name Description Interval[] array int arrayIndex ForEachInterval(Action<double, double>) Applies a given action for each segment in a route. Declaration public void ForEachInterval(Action<double, double> action) Parameters Type Name Description Action<double, double> action The action that should get applied to each interval. GetEnumerator() Declaration public IEnumerator<Interval> GetEnumerator() Returns Type Description IEnumerator<Interval> Intersect(RouteSegments, RouteSegments) Creates the intersection of the segments of the specified route segment collections. Only parts that belong to both collections, will be in the intersection. Declaration public static RouteSegments Intersect(RouteSegments a, RouteSegments b) Parameters Type Name Description RouteSegments a The first route segment collection. RouteSegments b The second route segment collection. Returns Type Description RouteSegments The RouteSegments containing all intersections. Overlaps(Interval) Checks if the interval is intersecting with at least one segment of the route. Declaration public bool Overlaps(Interval interval) Parameters Type Name Description Interval interval An interval. Returns Type Description bool Whether the interval is intersecting with at least one interval of route segment collection. Overlaps(RouteSegments) Checks if the segments of a route are intersecting with these segments of a route. Declaration public bool Overlaps(RouteSegments other) Parameters Type Name Description RouteSegments other The second collection of route segments. Returns Type Description bool Whether the segments of a route are intersecting with the segments of the other route. Remove(Interval) Declaration public bool Remove(Interval item) Parameters Type Name Description Interval item Returns Type Description bool UnionWith(RouteSegments) Creates the union of the segments in this collection and the specified collection by adding all the segments of the specified collection to this one. Declaration public void UnionWith(RouteSegments other) Parameters Type Name Description RouteSegments other The other route segment collection. Extension Methods CollectionExtensions.AddDistinct<T>(ICollection<T>, T) CollectionExtensions.AddRangeDistinct<T>(ICollection<T>, IEnumerable<T>)"
  },
  "api/Holoride.ElasticSDK.RouteTraveller.html": {
    "href": "api/Holoride.ElasticSDK.RouteTraveller.html",
    "title": "Class RouteTraveller | ElasticSDK Documentation",
    "keywords": "Class RouteTraveller Controls the movement of the GameObject along the route. Inheritance object Object Component Behaviour MonoBehaviour RouteTraveller Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [AddComponentMenu(\"holoride/Route Traveller\")] [HelpURL(\"http://localhost:8080/api/Holoride.ElasticSDK.RouteTraveller.html\")] public class RouteTraveller : MonoBehaviour Fields Distance Distance on the spline where the GameObject is currently located. Declaration [Tooltip(\"Distance on the spline where the GameObject is currently located.\")] public double Distance Field Value Type Description double GameObject The GameObject to travel along the route. Declaration [Tooltip(\"The GameObject to travel along the route.\")] public GameObject GameObject Field Value Type Description GameObject MoveGameObject States whether to travel or to pause. Declaration [Tooltip(\"States whether to travel or to pause.\")] public bool MoveGameObject Field Value Type Description bool Offset Offset for the GameObject relative to its path on the spline. Declaration [Tooltip(\"Offset for the GameObject relative to its path on the spline.\")] public Vector3 Offset Field Value Type Description Vector3 Route The Route to travel along. Declaration [Tooltip(\"The Route to travel along.\")] public Route Route Field Value Type Description Holoride.ElasticSDK.Route SnapTo States whether to snap the travelling object to the ground. Declaration [Tooltip(\"Which layer to snap the travelling object to, usually the terrain.\")] public LayerMask SnapTo Field Value Type Description LayerMask Speed The GameObject's travelling speed in meters per second. Declaration [Tooltip(\"The GameObject's travelling speed in meters per second.\")] public float Speed Field Value Type Description float Methods OnEnable() Implements the OnEnable method of the MonoBehaviour life-cycle. Initializes the GameObject flight. Declaration public void OnEnable() Update() Implements the Update method of the MonoBehaviour life-cycle. Declaration public void Update()"
  },
  "api/Holoride.ElasticSDK.RuntimeInitializeAfterSingletonsMethodAttribute.html": {
    "href": "api/Holoride.ElasticSDK.RuntimeInitializeAfterSingletonsMethodAttribute.html",
    "title": "Class RuntimeInitializeAfterSingletonsMethodAttribute | ElasticSDK Documentation",
    "keywords": "Class RuntimeInitializeAfterSingletonsMethodAttribute Inheritance object Attribute RuntimeInitializeAfterSingletonsMethodAttribute Implements IExecutionPriority Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Method)] [MeansImplicitUse] public sealed class RuntimeInitializeAfterSingletonsMethodAttribute : Attribute, IExecutionPriority Properties ExecutionPriority Declaration public int ExecutionPriority { get; set; } Property Value Type Description int Implements IExecutionPriority"
  },
  "api/Holoride.ElasticSDK.SensorDataInterpolator.html": {
    "href": "api/Holoride.ElasticSDK.SensorDataInterpolator.html",
    "title": "Class SensorDataInterpolator | ElasticSDK Documentation",
    "keywords": "Class SensorDataInterpolator Utility class used to interpolate sensor data e.g. when data frequency is too low for the current frame rate, which may result in stutters otherwise. Inheritance object SensorDataInterpolator Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.StateReceivers.dll Syntax [Serializable] public sealed class SensorDataInterpolator Methods InverseLerpUnclamped(double, double, double) Declaration public static float InverseLerpUnclamped(double from, double to, double value) Parameters Type Name Description double from double to double value Returns Type Description float PatchTargetData(VehicleSensorState) Patches the most recently set interpolation target. Typically used to change individual properties of the localization state, such as its status. Declaration public void PatchTargetData(VehicleSensorState value) Parameters Type Name Description VehicleSensorState value The new localization state. Reset() Resets the reference time values the interpolator uses to associate data timestamps with current Unity time. Declaration public void Reset() SetTargetData(VehicleSensorState, long?) Updates the current interpolation target, usually the latest known data point. Declaration public void SetTargetData(VehicleSensorState value, long? microseconds = null) Parameters Type Name Description VehicleSensorState value The sensor data to interpolate towards. long? microseconds The timestamp associated with the data, in microseconds. UpdateAndGet() Updates the current interpolation state if necessary/possible and returns the interpolated data. Declaration public VehicleSensorState UpdateAndGet() Returns Type Description VehicleSensorState The current, interpolated data."
  },
  "api/Holoride.ElasticSDK.ServiceStateReceiverBackend.html": {
    "href": "api/Holoride.ElasticSDK.ServiceStateReceiverBackend.html",
    "title": "Class ServiceStateReceiverBackend | ElasticSDK Documentation",
    "keywords": "Class ServiceStateReceiverBackend Connector for receiving localization data the holoride service. Inheritance object Object ScriptableObject StateReceiverBackend ServiceStateReceiverBackend Inherited Members StateReceiverBackend.State StateReceiverBackend.Route StateReceiverBackend.AllListeners StateReceiverBackend.LocalizationListeners StateReceiverBackend.AddListener(IStateReceiverListener) StateReceiverBackend.RemoveListener(IStateReceiverListener) StateReceiverBackend.NotifyListenerConfigurationChanged() StateReceiverBackend.Pivot StateReceiverBackend.IsEnabled StateReceiverBackend.OnListenerAdded(IStateReceiverListener) StateReceiverBackend.OnListenerRemoved(IStateReceiverListener) StateReceiverBackend.OnStateUpdated() StateReceiverBackend.OnStateReceivedAsync(VehicleSensorState) StateReceiverBackend.OnRouteChanged() StateReceiverBackend.OnMapAccessTokenReceived(string) StateReceiverBackend.UpdatePivot(GeoCoordinate) Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.StateReceivers.dll Syntax [PublicAPI] public sealed class ServiceStateReceiverBackend : StateReceiverBackend Properties AutomaticallyConnectAndSubscribe Gets or sets a value indicating whether to automatically connect to service when this backend gets enabled. Declaration public bool AutomaticallyConnectAndSubscribe { get; set; } Property Value Type Description bool Remarks Changing this at runtime may lead to a re-connect to the service. InterpolationFrameSize Gets or sets the interpolation frame size controls the delay data is presented at, where this delay window is used to interpolate underlying data, to ensure it is played back at the same rate the underlying records represent. Disabling interpolation by setting it to zero may result in rubber-banding. The window size is specified in seconds. Declaration public float InterpolationFrameSize { get; set; } Property Value Type Description float TravelInformationState Gets the travel information based on the current position along the Route. Declaration public override TravelInformationState TravelInformationState { get; } Property Value Type Description TravelInformationState Overrides StateReceiverBackend.TravelInformationState VehicleSensorState Gets or sets the most recently received state. This may be updated from worker threads, so when using the value in conditionals it is recommended to store the value in a local variable. Declaration public override VehicleSensorState VehicleSensorState { get; protected set; } Property Value Type Description VehicleSensorState Overrides StateReceiverBackend.VehicleSensorState VoyagerManager Gets the underlying manager used to communicate with the service. Regular applications should use this property, but rely on the methods and events provided by this class. This property is only exposed for internal use and will be removed in the future. Declaration [Obsolete(\"Obtain from Unity Subsystem API instead.\")] public IHolorideServiceManagerSubsystem VoyagerManager { get; } Property Value Type Description Holoride.Service.SDK.IHolorideServiceManagerSubsystem Methods Disable() Declaration public override void Disable() Overrides StateReceiverBackend.Disable() Enable() Declaration public override void Enable() Overrides StateReceiverBackend.Enable() OnApplicationResume() Declaration public override void OnApplicationResume() Overrides StateReceiverBackend.OnApplicationResume() OnDestroy() Declaration protected override void OnDestroy() Overrides StateReceiverBackend.OnDestroy() ResetLocalization() Requests a localization reset from the service. Will trigger the OnVehicleLocalizationReset() event when complete. Requires an active connection to the service, i.e. State has to be Available. To wait for the connection if it has not been established, use the OnConnect() event. Declaration public void ResetLocalization() Update() Declaration public override void Update() Overrides StateReceiverBackend.Update()"
  },
  "api/Holoride.ElasticSDK.SharedGeoCoordinate.html": {
    "href": "api/Holoride.ElasticSDK.SharedGeoCoordinate.html",
    "title": "Class SharedGeoCoordinate | ElasticSDK Documentation",
    "keywords": "Class SharedGeoCoordinate A SharedGeoCoordinate that can be used to synchronize pivot depending objects. Inheritance object SharedGeoCoordinate Implements ISharedGeoCoordinate Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [HelpURL(\"http://localhost:8080/api/Holoride.ElasticSDK.SharedGeoCoordinate.html\")] public class SharedGeoCoordinate : ISharedGeoCoordinate Properties GeoCoordinate Gets the current value of the shared geo coordinate. Declaration public GeoCoordinate GeoCoordinate { get; set; } Property Value Type Description GeoCoordinate IsInitialized Gets a value indicating whether the shared coordinate has been initialized and can be used by its consumers. This typically means it has been set to a non-default value at least once by a localization source that is in known to be in a valid state. Declaration public bool IsInitialized { get; } Property Value Type Description bool OnGeoCoordinateChanged Gets the event fired when the value of GeoCoordinate changes. Declaration public UnityEvent OnGeoCoordinateChanged { get; } Property Value Type Description UnityEvent Events GeoCoordinateChanged Fired when the value of GeoCoordinate changes. Declaration public event Action GeoCoordinateChanged Event Type Type Description Action Implements ISharedGeoCoordinate"
  },
  "api/Holoride.ElasticSDK.Singleton-1.html": {
    "href": "api/Holoride.ElasticSDK.Singleton-1.html",
    "title": "Class Singleton<T> | ElasticSDK Documentation",
    "keywords": "Class Singleton<T> Inheritance object Object ScriptableObject SingletonBase Singleton<T> GlobalSettings StateReceiver TypeCacheSingleton Inherited Members SingletonBase.SingletonOnCreate() SingletonBase.SingletonOnEnable() SingletonBase.SingletonOnDisable() Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [HelpURL(\"http://localhost:8080/api/Holoride.ElasticSDK.Singleton-1.html\")] public abstract class Singleton<T> : SingletonBase where T : Singleton<T> Type Parameters Name Description T Properties Instance Declaration public static T Instance { get; } Property Value Type Description T"
  },
  "api/Holoride.ElasticSDK.SingletonBase.html": {
    "href": "api/Holoride.ElasticSDK.SingletonBase.html",
    "title": "Class SingletonBase | ElasticSDK Documentation",
    "keywords": "Class SingletonBase Inheritance object Object ScriptableObject SingletonBase Singleton<T> Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public abstract class SingletonBase : ScriptableObject Methods SingletonOnCreate() Declaration protected virtual void SingletonOnCreate() SingletonOnDisable() Declaration protected virtual void SingletonOnDisable() SingletonOnEnable() Declaration protected virtual void SingletonOnEnable()"
  },
  "api/Holoride.ElasticSDK.SparseCellDataStructure-2.DataValueToCellKeyDelegate.html": {
    "href": "api/Holoride.ElasticSDK.SparseCellDataStructure-2.DataValueToCellKeyDelegate.html",
    "title": "Delegate SparseCellDataStructure<TSourceKey, TDataValue>.DataValueToCellKeyDelegate | ElasticSDK Documentation",
    "keywords": "Delegate SparseCellDataStructure<TSourceKey, TDataValue>.DataValueToCellKeyDelegate The function delegate to convert a dataValue into a cell key. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public delegate Vector2Int SparseCellDataStructure<TSourceKey, TDataValue>.DataValueToCellKeyDelegate(TDataValue dataValue) Parameters Type Name Description TDataValue dataValue The dataValue to convert. Returns Type Description Vector2Int The cell key."
  },
  "api/Holoride.ElasticSDK.SparseCellDataStructure-2.html": {
    "href": "api/Holoride.ElasticSDK.SparseCellDataStructure-2.html",
    "title": "Class SparseCellDataStructure<TSourceKey, TDataValue> | ElasticSDK Documentation",
    "keywords": "Class SparseCellDataStructure<TSourceKey, TDataValue> An hierarchical dataValue structure to store dataValues. Inheritance object SparseCellDataStructure<TSourceKey, TDataValue> SpawnCandidateStructure<TSource> Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class SparseCellDataStructure<TSourceKey, TDataValue> Type Parameters Name Description TSourceKey The type used as a key to relate objects to their generation source. TDataValue The type of the stored cell values. Properties Sources Gets a list of all sources. Declaration public IEnumerable<TSourceKey> Sources { get; } Property Value Type Description IEnumerable<TSourceKey> Methods AddDataBySource(TSourceKey, IEnumerable<TDataValue>, DataValueToCellKeyDelegate) Adds a list of dataValues with reference to their source. Declaration public void AddDataBySource(TSourceKey source, IEnumerable<TDataValue> dataValues, SparseCellDataStructure<TSourceKey, TDataValue>.DataValueToCellKeyDelegate dataValueToCellKeyFunction) Parameters Type Name Description TSourceKey source The source of the dataValues. IEnumerable<TDataValue> dataValues The dataValues to add. SparseCellDataStructure<TSourceKey, TDataValue>.DataValueToCellKeyDelegate dataValueToCellKeyFunction Function that maps data values to cell keys. Clear() Clears the data structure. Declaration public void Clear() Contains(TSourceKey) States whether dataValues generated by a certain source are contained. Declaration public bool Contains(TSourceKey sourceKey) Parameters Type Name Description TSourceKey sourceKey The source key. Returns Type Description bool Whether dataValues generated by a certain source are contained. ForEachDataValueInCell(Vector2Int, Action<TDataValue>) Calls a function on all dataValues within a cell. Declaration public void ForEachDataValueInCell(Vector2Int cellKey, Action<TDataValue> function) Parameters Type Name Description Vector2Int cellKey The key of the cell. Action<TDataValue> function The function to call. GetDataInCell(Vector2Int) Gets a enumerable of all dataValues within a cell. Declaration public IEnumerable<TDataValue> GetDataInCell(Vector2Int cellKey) Parameters Type Name Description Vector2Int cellKey The key of the cell. Returns Type Description IEnumerable<TDataValue> Returns a collection of cell data for specified cell keys of all generation contexts. RemoveDataBySource(TSourceKey) Removes all dataValues created by the given source. Declaration public void RemoveDataBySource(TSourceKey source) Parameters Type Name Description TSourceKey source The source of the dataValues. RemoveDataFromOtherSources(TSourceKey) Removes all dataValues created by any source other than the given source. Declaration public void RemoveDataFromOtherSources(TSourceKey remainingSource) Parameters Type Name Description TSourceKey remainingSource The source of the dataValues to remain."
  },
  "api/Holoride.ElasticSDK.SpawnCandidate.html": {
    "href": "api/Holoride.ElasticSDK.SpawnCandidate.html",
    "title": "Class SpawnCandidate | ElasticSDK Documentation",
    "keywords": "Class SpawnCandidate A spawn candidate is asynchronously created on every terrain update covering the full extents of the TerrainCanvas. As the player gets closer to the candidate than the extents of the spawner, the actual GameObject is instantiated. By deriving from this class, information can be passed from the DefinePoses to the CreateObject method of the Spawner. Inheritance object SpawnCandidate Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class SpawnCandidate Constructors SpawnCandidate(GlobalPose) Instantiates the candidate at a given pose. Declaration public SpawnCandidate(GlobalPose pose) Parameters Type Name Description GlobalPose pose The pose of the candidate. SpawnCandidate(GlobalPosition, Quaternion) Instantiates the candidate at a given position and rotation. Declaration public SpawnCandidate(GlobalPosition position, Quaternion rotation) Parameters Type Name Description GlobalPosition position The position of the candidate. Quaternion rotation The rotation of the candidate. Fields Pose The pose where this object gets spawned. Declaration public GlobalPose Pose Field Value Type Description GlobalPose"
  },
  "api/Holoride.ElasticSDK.SpawnCandidateStructure-1.html": {
    "href": "api/Holoride.ElasticSDK.SpawnCandidateStructure-1.html",
    "title": "Class SpawnCandidateStructure<TSource> | ElasticSDK Documentation",
    "keywords": "Class SpawnCandidateStructure<TSource> An hierarchical data structure to store spawn candidates. Inheritance object SparseCellDataStructure<TSource, SpawnCandidate> SpawnCandidateStructure<TSource> Inherited Members SparseCellDataStructure<TSource, SpawnCandidate>.Sources SparseCellDataStructure<TSource, SpawnCandidate>.Clear() SparseCellDataStructure<TSource, SpawnCandidate>.Contains(TSource) SparseCellDataStructure<TSource, SpawnCandidate>.AddDataBySource(TSource, IEnumerable<SpawnCandidate>, SparseCellDataStructure<TSource, SpawnCandidate>.DataValueToCellKeyDelegate) SparseCellDataStructure<TSource, SpawnCandidate>.RemoveDataBySource(TSource) SparseCellDataStructure<TSource, SpawnCandidate>.RemoveDataFromOtherSources(TSource) SparseCellDataStructure<TSource, SpawnCandidate>.ForEachDataValueInCell(Vector2Int, Action<SpawnCandidate>) SparseCellDataStructure<TSource, SpawnCandidate>.GetDataInCell(Vector2Int) Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class SpawnCandidateStructure<TSource> : SparseCellDataStructure<TSource, SpawnCandidate> Type Parameters Name Description TSource The type used as a key to relate objects to their generation source. Constructors SpawnCandidateStructure(PositionToCellKeyDelegate) Instantiates a SpawnCandidateStructure. Declaration public SpawnCandidateStructure(SpawnCandidateStructure<TSource>.PositionToCellKeyDelegate positionToCellKeyFunction) Parameters Type Name Description SpawnCandidateStructure<TSource>.PositionToCellKeyDelegate positionToCellKeyFunction The function to convert a position into a cell key. Methods AddCandidatesBySource(TSource, IEnumerable<SpawnCandidate>) Adds a list of candidates with reference to their source. Declaration public void AddCandidatesBySource(TSource source, IEnumerable<SpawnCandidate> spawnCandidates) Parameters Type Name Description TSource source The source of the candidates. IEnumerable<SpawnCandidate> spawnCandidates The candidates to add. CandidatesInCell(Vector2Int) Gets a enumerable of all candidates within a cell. Declaration [Obsolete(\"This method is obsolete and will be removed. Use GetDataInCell(Vector2Int cellKey) instead.\")] public IEnumerable<SpawnCandidate> CandidatesInCell(Vector2Int cellKey) Parameters Type Name Description Vector2Int cellKey The key of the cell. Returns Type Description IEnumerable<SpawnCandidate> Returns a collection of spawn candidates for specified cell keys of all generation contexts. ForEachCandidateInCell(Vector2Int, Action<SpawnCandidate>) Calls a function on all candidates within a cell. Declaration public void ForEachCandidateInCell(Vector2Int cellKey, Action<SpawnCandidate> function) Parameters Type Name Description Vector2Int cellKey The key of the cell. Action<SpawnCandidate> function The function to call. RemoveCandidatesBySource(TSource) Removes all candidates created by the given source. Declaration public void RemoveCandidatesBySource(TSource source) Parameters Type Name Description TSource source The source of the candidates. RemoveCandidatesFromOtherSources(TSource) Removes all candidates created by any source other than the given source. Declaration public void RemoveCandidatesFromOtherSources(TSource remainingSource) Parameters Type Name Description TSource remainingSource The source of the candidates to remain."
  },
  "api/Holoride.ElasticSDK.SpawnCandidateStructure-1.PositionToCellKeyDelegate.html": {
    "href": "api/Holoride.ElasticSDK.SpawnCandidateStructure-1.PositionToCellKeyDelegate.html",
    "title": "Delegate SpawnCandidateStructure<TSource>.PositionToCellKeyDelegate | ElasticSDK Documentation",
    "keywords": "Delegate SpawnCandidateStructure<TSource>.PositionToCellKeyDelegate The function delegate to convert a position into a cell key. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public delegate Vector2Int SpawnCandidateStructure<TSource>.PositionToCellKeyDelegate(GlobalPosition position) Parameters Type Name Description GlobalPosition position The position to convert. Returns Type Description Vector2Int The cell key."
  },
  "api/Holoride.ElasticSDK.SpawnerWorker.html": {
    "href": "api/Holoride.ElasticSDK.SpawnerWorker.html",
    "title": "Class SpawnerWorker | ElasticSDK Documentation",
    "keywords": "Class SpawnerWorker The base class to spawn objects. Inheritance object PipelineWorkerBase SpawnerWorker SpawnerNode.SpawnerWorker<T> Implements IPipelineWorker Inherited Members PipelineWorkerBase.GenerationSettings PipelineWorkerBase.GenerationState PipelineWorkerBase.CurrentGenerationContext PipelineWorkerBase.Pipeline PipelineWorkerBase.IsGatheringResources PipelineWorkerBase.IsProcessing PipelineWorkerBase.Inputs PipelineWorkerBase.MissingMandatoryInputs PipelineWorkerBase.AddMissingMandatoryInput(string) PipelineWorkerBase.HasMissingMandatoryInputInHierarchy PipelineWorkerBase.AddInput(string, IPipelineWorker) PipelineWorkerBase.GetInput(string) PipelineWorkerBase.GetInput<T>(string) PipelineWorkerBase.InitResources() PipelineWorkerBase.CallInitResources() PipelineWorkerBase.Init() PipelineWorkerBase.GatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.CallGatherResourcesAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.ProcessAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.CallProcessAsync(GenerationContext, IProgress<float>, CancellationToken) PipelineWorkerBase.CleanUp() PipelineWorkerBase.CallCleanUp() Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] public abstract class SpawnerWorker : PipelineWorkerBase, IPipelineWorker Constructors SpawnerWorker(double, float, bool) Instantiates a SpawnerWorker. Declaration public SpawnerWorker(double cellSize, float extents, bool isUnconstrained) Parameters Type Name Description double cellSize The edge length of each squared cell. float extents The extents around the players position, defining the area where the objects are spawned. bool isUnconstrained Whether this spawner uses unconstrained extents. Spawners using unconstrained extents may have extents larger than the extents of the generator (and thus the area covered by maps). As such, unclamped spawners should not rely on map data. Fields CellSize The edge length of each squared cell. Declaration public readonly double CellSize Field Value Type Description double IsUnconstrained Whether the extents of this spawner are always unclamped. Declaration public readonly bool IsUnconstrained Field Value Type Description bool OnGameObjectsCreated Declaration public Action<List<GameObject>> OnGameObjectsCreated Field Value Type Description Action<List<GameObject>> Properties Bounds Gets the current bounds of this spawner. Declaration public GlobalBounds Bounds { get; } Property Value Type Description GlobalBounds DiscreteRadius Gets the radius after discretization. Declaration public int DiscreteRadius { get; } Property Value Type Description int Extents Gets the extents around the players position, defining the area where the objects are spawned. Attempts to return clamped extents for the currently used GenerationSettings. Returns raw, unclamped extents if no settings are available (e.g. worker not in a pipeline). Declaration public float Extents { get; } Property Value Type Description float MayUpdateMovingGrid Declaration protected virtual bool MayUpdateMovingGrid { get; } Property Value Type Description bool QuantityInitEstimation Gets or sets the precomputed quantity that should be initialized by an Init() call. Declaration public virtual int QuantityInitEstimation { get; protected set; } Property Value Type Description int Methods CallInit() Initializes this node. Declaration public override sealed void CallInit() Overrides PipelineWorkerBase.CallInit() CellKeyToBounds(Vector2Int) Helper function to compute the bounds of a cell. Declaration public GlobalBounds CellKeyToBounds(Vector2Int cellKey) Parameters Type Name Description Vector2Int cellKey The cell key to convert. Returns Type Description GlobalBounds The bounds of the cell. ComputeCellKeyFromPosition(GlobalPosition) Hashes the position coordinates to receive a discrete cell key. Declaration public Vector2Int ComputeCellKeyFromPosition(GlobalPosition position) Parameters Type Name Description GlobalPosition position The position to hash. Returns Type Description Vector2Int The discrete cell key. DestroyAllCells() Destroys all currently existing spawned game objects and clears the internal cache. Declaration protected void DestroyAllCells() DestroyCell(IEnumerable<GameObject>) Destroys all objects within a cell by destroying them. Override this function to treat disappearing objects differently, e.g. to return them to an object pool. Declaration public virtual void DestroyCell(IEnumerable<GameObject> gameObjects) Parameters Type Name Description IEnumerable<GameObject> gameObjects The game objects to destroy. Dispose() Declaration public override void Dispose() Overrides PipelineWorkerBase.Dispose() EvaluateSpawnCandidate(int, GlobalPosition, CancellationToken) Declaration protected virtual UniTask<GameObject> EvaluateSpawnCandidate(int seed, GlobalPosition globalPosition, CancellationToken cancellationToken) Parameters Type Name Description int seed GlobalPosition globalPosition CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask<T><GameObject> MoveSpawnPosition(GlobalPosition, CancellationToken) Moves the spawn position. Declaration public UniTask MoveSpawnPosition(GlobalPosition position, CancellationToken cancellationToken) Parameters Type Name Description GlobalPosition position The position to move to. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask SpawnCell(Vector2Int, IList<GameObject>, CancellationToken) Implement to spawn all objects within the given cell. Declaration protected abstract UniTask SpawnCell(Vector2Int cellKey, IList<GameObject> spawnedObjects, CancellationToken cancellationToken) Parameters Type Name Description Vector2Int cellKey The cell key. IList<GameObject> spawnedObjects The list to which to add all objects that were spawned. CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask Implements IPipelineWorker"
  },
  "api/Holoride.ElasticSDK.SpeedCategory.html": {
    "href": "api/Holoride.ElasticSDK.SpeedCategory.html",
    "title": "Enum SpeedCategory | ElasticSDK Documentation",
    "keywords": "Enum SpeedCategory Major speed categories. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public enum SpeedCategory Fields Name Description Fast Fast speeds from 65(+-5) km/h onward. In imperial units: from ~40(+-3) mp/h. Medium Medium speeds from 35(+-5) to 65(+-5) km/h. In imperial units: from ~22(+-3) to ~40(+-3) mp/h. Slow Slow speeds up to 35(+-5) km/h. In imperial units: up to ~22(+-3) mp/h."
  },
  "api/Holoride.ElasticSDK.SpeedSegment.html": {
    "href": "api/Holoride.ElasticSDK.SpeedSegment.html",
    "title": "Struct SpeedSegment | ElasticSDK Documentation",
    "keywords": "Struct SpeedSegment Segments along the route defined by the distance and speed category. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [Serializable] public struct SpeedSegment Fields Category The speed category for this interval. Declaration public SpeedCategory Category Field Value Type Description SpeedCategory Segment Segment describing the start and end distance along the route. Declaration public Interval Segment Field Value Type Description Interval Methods Equals(SpeedSegment) Declaration public bool Equals(SpeedSegment other) Parameters Type Name Description SpeedSegment other Returns Type Description bool Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides ValueType.Equals(Object) GetHashCode() Declaration public override int GetHashCode() Returns Type Description int Overrides ValueType.GetHashCode() ToString() Declaration public override string ToString() Returns Type Description string Overrides ValueType.ToString()"
  },
  "api/Holoride.ElasticSDK.Spline.html": {
    "href": "api/Holoride.ElasticSDK.Spline.html",
    "title": "Class Spline | ElasticSDK Documentation",
    "keywords": "Class Spline A spline class to provide infinitesimal pose information on a path defined by discrete positions. Inheritance object Spline Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [Serializable] public class Spline Constructors Spline(IReadOnlyList<GeoCoordinate>, int, float, GeoCoordinate?) Initializes a new instance of the Spline class, prepares distance lookup table and performs filter operations. Declaration public Spline(IReadOnlyList<GeoCoordinate> geoCoordinates, int distanceSamplesPerInterval = 10, float controlPointRatio = 0.3, GeoCoordinate? pivot = null) Parameters Type Name Description IReadOnlyList<GeoCoordinate> geoCoordinates A list of geoCoordinates to align a spline to. int distanceSamplesPerInterval The number of samples per interval to add to the distance lookup-table. The value implies a trade-off between precision and cpu/memory consumption. float controlPointRatio Controls spline smoothing. 0 = tight, 1 = smooth. GeoCoordinate? pivot The pivot to use when interpreting the provided coordinates. Spline(List<GlobalPosition>, int, float) Initializes a new instance of the Spline class, prepares distance lookup table and performs filter operations. Declaration public Spline(List<GlobalPosition> positions, int distanceSamplesPerInterval = 10, float controlPointRatio = 0.3) Parameters Type Name Description List<GlobalPosition> positions A list of positions to align a spline to. int distanceSamplesPerInterval The number of samples per interval to add to the distance lookup-table. The value implies a trade-off between precision and cpu/memory consumption. float controlPointRatio Controls spline smoothing. 0 = tight, 1 = smooth. Fields Pivot The Pivot this Spline was created with. Declaration public GeoCoordinate Pivot Field Value Type Description GeoCoordinate Properties Length Gets the length of the spline. Declaration public double Length { get; } Property Value Type Description double SupportPointCount Gets the number of positions to define the spline. Declaration public int SupportPointCount { get; } Property Value Type Description int Methods FindClosestDistance(GlobalPosition, double, RouteSegments) Finds the spline distance of the closest point to a given search position. Declaration public double FindClosestDistance(GlobalPosition searchPosition, double stepDistance, RouteSegments searchRouteSegments = null) Parameters Type Name Description GlobalPosition searchPosition The position to search the closest distance. double stepDistance The step distance. A smaller distance increases computation effort. RouteSegments searchRouteSegments The optional interval to search within. Returns Type Description double The distance of the spline point closest to the search position. FindClosestPoseOnSpline(GlobalPosition, double, RouteSegments) Finds the closest position on a spline to a given search position. Declaration public GlobalPose FindClosestPoseOnSpline(GlobalPosition searchPosition, double stepDistance, RouteSegments searchRouteSegments = null) Parameters Type Name Description GlobalPosition searchPosition The position to search. double stepDistance The step distance. A smaller distance increases computation effort. RouteSegments searchRouteSegments The optional interval to search within. Returns Type Description GlobalPose The closest pose on the spline. FindClosestPositionOnSupportLines(GlobalPosition, out double) Finds the closest position between support points. Declaration public GlobalPosition FindClosestPositionOnSupportLines(GlobalPosition searchPosition, out double sqrDistance) Parameters Type Name Description GlobalPosition searchPosition The position to search the closest distance for. double sqrDistance The minimum squared distance found. Returns Type Description GlobalPosition The closest position. FindClosestRatio(GlobalPosition, double, RouteSegments) Finds the closest spline ratio to a given search position. Declaration public double FindClosestRatio(GlobalPosition searchPosition, double stepDistance, RouteSegments searchRouteSegments = null) Parameters Type Name Description GlobalPosition searchPosition The position to search the closest distance. double stepDistance The step distance. A smaller distance increases computation effort. RouteSegments searchRouteSegments The optional interval to search within. Returns Type Description double The computed spline ratio. ForEachSupportPosition(Action<GlobalPosition, double>) Calls an action for each support position. Declaration public void ForEachSupportPosition(Action<GlobalPosition, double> action) Parameters Type Name Description Action<GlobalPosition, double> action The action to call. Contains the position and the distance on the spline. GenerateSimplifiedSplineByRadius(double) Generates a simplified spline based on this spline. Declaration public Spline GenerateSimplifiedSplineByRadius(double supportRadius) Parameters Type Name Description double supportRadius Defines the distance between the generated support positions. Returns Type Description Spline The simplified spline. GetCurvatureAtDistance(double, double) Gets the curvature at a specified distance. Declaration public Vector3 GetCurvatureAtDistance(double distance, double curvatureDistanceDelta) Parameters Type Name Description double distance The distance. double curvatureDistanceDelta The curvature distance delta. Returns Type Description Vector3 The curvature of the spline. GetDistanceAtIndex(double) Looks up the distance at a given index. Declaration public double GetDistanceAtIndex(double index) Parameters Type Name Description double index The index where to look at. Returns Type Description double The computed distance on the spline. GetDistanceAtRatio(double) Looks up the distance at a given ratio. Declaration public double GetDistanceAtRatio(double ratio) Parameters Type Name Description double ratio The ratio where to look at. Returns Type Description double The computed distance on the spline. GetDistanceAtSupportPoint(int) Looks up the distance at a given support point index. Declaration public double GetDistanceAtSupportPoint(int supportPointNumber) Parameters Type Name Description int supportPointNumber The support point number where to look at. Returns Type Description double The computed distance on the spline. GetIndexAtDistance(double) Gets the index at a specific distance. Declaration public double GetIndexAtDistance(double distance) Parameters Type Name Description double distance The distance. Returns Type Description double The computed spline index. GetIndexAtRatio(double) Looks up the index at a given ratio. Declaration public double GetIndexAtRatio(double ratio) Parameters Type Name Description double ratio The ratio where to look at. Returns Type Description double The computed index on the spline. GetRatioAtDistance(double) Gets the ratio at a specific distance. Declaration public double GetRatioAtDistance(double distance) Parameters Type Name Description double distance The distance. Returns Type Description double The computed spline ratio. GetRatioAtIndex(double) Looks up the ratio at a given index. Declaration public double GetRatioAtIndex(double index) Parameters Type Name Description double index The index where to look at. Returns Type Description double The computed ratio on the spline. GetSupportPosition(int) Returns a support position at a given index. Declaration public GlobalPosition GetSupportPosition(int index) Parameters Type Name Description int index The index of the support position to return. Returns Type Description GlobalPosition The support position at the given index. ProjectRatioFromReferenceSpline(Spline, double, double) Computes the ratio of the position with the closest distance to the result of sampling a reference spline at a given ratio. This method is referred to as ratio projection. Declaration public double ProjectRatioFromReferenceSpline(Spline referenceSpline, double ratio, double errorMargin) Parameters Type Name Description Spline referenceSpline The reference spline. double ratio The ratio to project. double errorMargin The error margin. Beyond the margin distance, the result is precisely computed. A smaller margin increases computation effort. Returns Type Description double The projected ratio. SampleAtDistance(double, bool) Samples the spline at a specific distance. Declaration public GlobalPose SampleAtDistance(double distance, bool oppositeDirection = false) Parameters Type Name Description double distance The distance in units where to sample the spline. bool oppositeDirection States whether to return a pose in the opposite direction. Returns Type Description GlobalPose The doublePose (translation and rotation along the tangent) at the defined distance. SampleAtDistance(double, out double, bool) Samples the spline at a specific distance. Declaration public GlobalPose SampleAtDistance(double distance, out double controlPointIndex, bool oppositeDirection = false) Parameters Type Name Description double distance The distance in units where to sample the spline. double controlPointIndex The optional output of the interpolated control point index at the given distance. bool oppositeDirection States whether to return a pose in the opposite direction. Returns Type Description GlobalPose The doublePose (translation and rotation along the tangent) at the defined distance. SampleAtIndex(double, bool) Samples the hermite spline at a specific index. Declaration public GlobalPose SampleAtIndex(double sampleIndex, bool oppositeDirection = false) Parameters Type Name Description double sampleIndex The index between 0.0 and 1.0 where to sample the spline. bool oppositeDirection States whether to return a pose in the opposite direction. Returns Type Description GlobalPose The doublePose (translation and rotation aligned with the tangent) at the given index. SampleAtRatio(double, bool) Samples the hermite spline at a specific ratio. Declaration public GlobalPose SampleAtRatio(double sampleRatio, bool oppositeDirection = false) Parameters Type Name Description double sampleRatio The ratio between 0.0 and 1.0 where to sample the spline. bool oppositeDirection States whether to return a pose in the opposite direction. Returns Type Description GlobalPose The double precision pose (translation and rotation aligned with the tangent) at the given ratio. SamplePositionAtIndex(double) Samples the hermite spline at a specific index. Declaration public GlobalPosition SamplePositionAtIndex(double sampleIndex) Parameters Type Name Description double sampleIndex The index between 0.0 and 1.0 where to sample the spline. Returns Type Description GlobalPosition The position at the given index. Scale(double) Scales the spline by a given factor. Declaration public void Scale(double factor) Parameters Type Name Description double factor The factor to scale the spline with. ToString() Declaration public override string ToString() Returns Type Description string Overrides Object.ToString()"
  },
  "api/Holoride.ElasticSDK.StateReceiver.BackendChangedHandler.html": {
    "href": "api/Holoride.ElasticSDK.StateReceiver.BackendChangedHandler.html",
    "title": "Delegate StateReceiver.BackendChangedHandler | ElasticSDK Documentation",
    "keywords": "Delegate StateReceiver.BackendChangedHandler Event handler for the OnBackendChanged event. Takes a StateReceiverBackend argument. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public delegate void StateReceiver.BackendChangedHandler(StateReceiverBackend stateReceiverBackend) Parameters Type Name Description StateReceiverBackend stateReceiverBackend The current StateReceiverBackend that was switched to."
  },
  "api/Holoride.ElasticSDK.StateReceiver.html": {
    "href": "api/Holoride.ElasticSDK.StateReceiver.html",
    "title": "Class StateReceiver | ElasticSDK Documentation",
    "keywords": "Class StateReceiver This is the central data source for localization data and any other data provided by StateReceiverBackends. Inheritance object Object ScriptableObject SingletonBase Singleton<StateReceiver> StateReceiver Inherited Members Singleton<StateReceiver>.Instance SingletonBase.SingletonOnCreate() SingletonBase.SingletonOnEnable() SingletonBase.SingletonOnDisable() Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [PublicAPI] [HelpURL(\"http://localhost:8080/api/Holoride.ElasticSDK.StateReceiver.html\")] [Obfuscation(Exclude = true, ApplyToMembers = true)] public sealed class StateReceiver : Singleton<StateReceiver> Properties AvailableBackends Gets the list of all available backends. Declaration public static IReadOnlyList<StateReceiverBackend> AvailableBackends { get; } Property Value Type Description IReadOnlyList<StateReceiverBackend> CurrentBackend Gets or sets the backend currently in use. Note: Beware when changing the CurrentBackend you need to re-acquire the references to the Pivot and Route. Declaration public static StateReceiverBackend CurrentBackend { get; set; } Property Value Type Description StateReceiverBackend EditorBackend Declaration public StateReceiverBackend EditorBackend { get; } Property Value Type Description StateReceiverBackend Pivot Gets the pivot of the CurrentBackend, used as reference point for the mapping between real world GeoCoordinate and the coordinate system in Unity. Note: Beware when changing the CurrentBackend you need to re-acquire the reference to the Pivot. Declaration public static ISharedGeoCoordinate Pivot { get; } Property Value Type Description ISharedGeoCoordinate Route Gets the current route of the CurrentBackend. Note: Beware when changing the CurrentBackend you need to re-acquire the reference to the Route. Declaration public static IRoute Route { get; } Property Value Type Description IRoute State Declaration public static StateReceiverState State { get; } Property Value Type Description StateReceiverState StationaryBackend Declaration public StateReceiverBackend StationaryBackend { get; } Property Value Type Description StateReceiverBackend TravelBackend Declaration public StateReceiverBackend TravelBackend { get; } Property Value Type Description StateReceiverBackend TravelInformationState Declaration public static TravelInformationState TravelInformationState { get; } Property Value Type Description TravelInformationState VehicleSensorState Declaration public static VehicleSensorState VehicleSensorState { get; } Property Value Type Description VehicleSensorState Methods AddListener(IStateReceiverListener) Registers a new listener that should be notified of state receiver events. All registered listeners will automatically migrated when the selected TravelBackend changes. Declaration public static void AddListener(IStateReceiverListener listener) Parameters Type Name Description IStateReceiverListener listener The listener to add. NotifyListenerConfigurationChanged() Declaration public static void NotifyListenerConfigurationChanged() RemoveListener(IStateReceiverListener) Removes a listener previously registered with AddListener(IStateReceiverListener). Declaration public static void RemoveListener(IStateReceiverListener listener) Parameters Type Name Description IStateReceiverListener listener The listener to remove. TryGetBackend(Type, out StateReceiverBackend) Get the first available backend with the specified type. Declaration public static bool TryGetBackend(Type type, out StateReceiverBackend result) Parameters Type Name Description Type type The type of the backend to get. StateReceiverBackend result The first backend with the specified type. Returns Type Description bool Whether a backend with the specified type exists and could be returned. TryGetBackend<T>(out T) Get the first available backend with the specified type. Declaration public static bool TryGetBackend<T>(out T result) where T : StateReceiverBackend Parameters Type Name Description T result The first backend with the specified type. Returns Type Description bool Whether a backend with the specified type exists and could be returned. Type Parameters Name Description T The type of the backend to get. Events OnBackendChanged Invoked when the CurrentBackend has changed. Declaration public static event StateReceiver.BackendChangedHandler OnBackendChanged Event Type Type Description StateReceiver.BackendChangedHandler Remarks StateReceiver.BackendChangedHandler takes a StateReceiverBackend argument."
  },
  "api/Holoride.ElasticSDK.StateReceiverBackend.html": {
    "href": "api/Holoride.ElasticSDK.StateReceiverBackend.html",
    "title": "Class StateReceiverBackend | ElasticSDK Documentation",
    "keywords": "Class StateReceiverBackend Backend implementation for the StateReceiver. Implementations of this class represent connections to actual underlying data sources for vehicle localization etc. These may either we be annotated with StateReceiverBackendAttribute to be automatically added to the StateReceiver, or can be added via the inspector. Inheritance object Object ScriptableObject StateReceiverBackend FixedPositionStateReceiverBackend NullStateReceiverBackend ReplayStateReceiverBackend ServiceStateReceiverBackend Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public abstract class StateReceiverBackend : ScriptableObject Fields AllListeners Declaration protected readonly HashSet<object> AllListeners Field Value Type Description HashSet<object> LocalizationListeners Declaration protected readonly List<IStateReceiverLocalizationEventListener> LocalizationListeners Field Value Type Description List<IStateReceiverLocalizationEventListener> Properties IsEnabled Declaration public bool IsEnabled { get; } Property Value Type Description bool Pivot Gets the pivot, used as reference point for the mapping between real world GeoCoordinate and the coordinate system in Unity. Declaration public SharedGeoCoordinate Pivot { get; } Property Value Type Description SharedGeoCoordinate Route Gets or sets the current route. Declaration public virtual IRoute Route { get; protected set; } Property Value Type Description IRoute State Gets or sets the current state of this backend, indicating if it is ready for use. Declaration public StateReceiverState State { get; protected set; } Property Value Type Description StateReceiverState TravelInformationState Gets the travel information based on the current position along the Route. Declaration public virtual TravelInformationState TravelInformationState { get; } Property Value Type Description TravelInformationState VehicleSensorState Gets or sets the most recently received state. This may be updated from worker threads, so when using the value in conditionals it is recommended to store the value in a local variable. Declaration public virtual VehicleSensorState VehicleSensorState { get; protected set; } Property Value Type Description VehicleSensorState Methods AddListener(IStateReceiverListener) Declaration public void AddListener(IStateReceiverListener listener) Parameters Type Name Description IStateReceiverListener listener Disable() Called when this backend was the active one and another backend is made the active backend in the StateReceiver. Backend should dispose underlying connections and state and release unmanaged resources when this is called. Declaration public virtual void Disable() Enable() Called when this backend is made the active backend in the StateReceiver. Backend (re)initialization should be started when this is called. Declaration public virtual void Enable() NotifyListenerConfigurationChanged() Declaration public virtual void NotifyListenerConfigurationChanged() OnApplicationResume() Declaration public virtual void OnApplicationResume() OnDestroy() Declaration protected virtual void OnDestroy() OnListenerAdded(IStateReceiverListener) Declaration protected virtual void OnListenerAdded(IStateReceiverListener listener) Parameters Type Name Description IStateReceiverListener listener OnListenerRemoved(IStateReceiverListener) Declaration protected virtual void OnListenerRemoved(IStateReceiverListener listener) Parameters Type Name Description IStateReceiverListener listener OnMapAccessTokenReceived(string) Declaration protected void OnMapAccessTokenReceived(string token) Parameters Type Name Description string token OnRouteChanged() Notifies the listeners that the route has changed. Declaration protected void OnRouteChanged() OnStateReceivedAsync(VehicleSensorState) Fires the OnVehicleLocalizationReceivedAsync(VehicleSensorState) event. Should be called directly and as soon as possible whenever new state is received, even if this call happens from a separate thread. Declaration protected void OnStateReceivedAsync(VehicleSensorState state) Parameters Type Name Description VehicleSensorState state The received state. OnStateUpdated() Updates the state. Should be called once per physics update. Declaration protected void OnStateUpdated() RemoveListener(IStateReceiverListener) Declaration public void RemoveListener(IStateReceiverListener listener) Parameters Type Name Description IStateReceiverListener listener Update() Declaration public virtual void Update() UpdatePivot(GeoCoordinate) This method allows us to update the pivot. Declaration public virtual void UpdatePivot(GeoCoordinate geoCoordinate) Parameters Type Name Description GeoCoordinate geoCoordinate The new pivot position."
  },
  "api/Holoride.ElasticSDK.StateReceiverBackendAttribute.html": {
    "href": "api/Holoride.ElasticSDK.StateReceiverBackendAttribute.html",
    "title": "Class StateReceiverBackendAttribute | ElasticSDK Documentation",
    "keywords": "Class StateReceiverBackendAttribute Implementations of StateReceiverBackend annotated with this attribute will be made available in the StateReceiver. Alternatively, providers can be manually assigned in the StateReceiver. Inheritance object Attribute StateReceiverBackendAttribute Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Class)] [MeansImplicitUse] [BaseTypeRequired(typeof(StateReceiverBackend))] public sealed class StateReceiverBackendAttribute : Attribute Properties DefaultForPlatform Declaration public StateReceiverBackendAttribute.Platform DefaultForPlatform { get; set; } Property Value Type Description StateReceiverBackendAttribute.Platform RequiresStationaryPermission Declaration public bool RequiresStationaryPermission { get; set; } Property Value Type Description bool SupportedPlatforms Declaration public StateReceiverBackendAttribute.Platform SupportedPlatforms { get; set; } Property Value Type Description StateReceiverBackendAttribute.Platform"
  },
  "api/Holoride.ElasticSDK.StateReceiverBackendAttribute.Platform.html": {
    "href": "api/Holoride.ElasticSDK.StateReceiverBackendAttribute.Platform.html",
    "title": "Enum StateReceiverBackendAttribute.Platform | ElasticSDK Documentation",
    "keywords": "Enum StateReceiverBackendAttribute.Platform Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [Flags] public enum StateReceiverBackendAttribute.Platform Fields Name Description Editor None Standalone Stationary"
  },
  "api/Holoride.ElasticSDK.StateReceiverBackendSelector.html": {
    "href": "api/Holoride.ElasticSDK.StateReceiverBackendSelector.html",
    "title": "Class StateReceiverBackendSelector | ElasticSDK Documentation",
    "keywords": "Class StateReceiverBackendSelector Manages the StateReceiverBackend assigned to CurrentBackend. Inheritance object StateReceiverBackendSelector Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public static class StateReceiverBackendSelector Properties Override Gets or sets an override to assign as the current backend, ignoring default heuristics. Declaration public static StateReceiverBackend Override { get; set; } Property Value Type Description StateReceiverBackend"
  },
  "api/Holoride.ElasticSDK.StateReceiverEventListenerAdapter.html": {
    "href": "api/Holoride.ElasticSDK.StateReceiverEventListenerAdapter.html",
    "title": "Class StateReceiverEventListenerAdapter | ElasticSDK Documentation",
    "keywords": "Class StateReceiverEventListenerAdapter Inheritance object StateReceiverEventListenerAdapter Implements IStateReceiverLocalizationEventListener IStateReceiverListener Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class StateReceiverEventListenerAdapter : IStateReceiverLocalizationEventListener, IStateReceiverListener Events OnConnect Declaration public event Action OnConnect Event Type Type Description Action OnConnectError Declaration public event Action<StateReceiverInitializationError> OnConnectError Event Type Type Description Action<StateReceiverInitializationError> OnDisconnect Declaration public event Action OnDisconnect Event Type Type Description Action OnRouteChanged Declaration public event Action OnRouteChanged Event Type Type Description Action OnVehicleLocalizationReceivedAsync Declaration public event Action<VehicleSensorState> OnVehicleLocalizationReceivedAsync Event Type Type Description Action<VehicleSensorState> OnVehicleLocalizationReset Declaration public event Action OnVehicleLocalizationReset Event Type Type Description Action OnVehicleLocalizationStart Declaration public event Action OnVehicleLocalizationStart Event Type Type Description Action OnVehicleLocalizationStatusChanged Declaration public event Action<VehicleLocalizationStatus> OnVehicleLocalizationStatusChanged Event Type Type Description Action<VehicleLocalizationStatus> Explicit Interface Implementations IStateReceiverLocalizationEventListener.OnConnect() Declaration void IStateReceiverLocalizationEventListener.OnConnect() IStateReceiverLocalizationEventListener.OnConnectError(StateReceiverInitializationError) Declaration void IStateReceiverLocalizationEventListener.OnConnectError(StateReceiverInitializationError error) Parameters Type Name Description StateReceiverInitializationError error IStateReceiverLocalizationEventListener.OnDisconnect() Declaration void IStateReceiverLocalizationEventListener.OnDisconnect() IStateReceiverLocalizationEventListener.OnRouteChanged() Declaration void IStateReceiverLocalizationEventListener.OnRouteChanged() IStateReceiverLocalizationEventListener.OnVehicleLocalizationReceivedAsync(VehicleSensorState) Declaration void IStateReceiverLocalizationEventListener.OnVehicleLocalizationReceivedAsync(VehicleSensorState state) Parameters Type Name Description VehicleSensorState state IStateReceiverLocalizationEventListener.OnVehicleLocalizationReset() Declaration void IStateReceiverLocalizationEventListener.OnVehicleLocalizationReset() IStateReceiverLocalizationEventListener.OnVehicleLocalizationStart() Declaration void IStateReceiverLocalizationEventListener.OnVehicleLocalizationStart() IStateReceiverLocalizationEventListener.OnVehicleLocalizationStatusChanged(VehicleLocalizationStatus) Declaration void IStateReceiverLocalizationEventListener.OnVehicleLocalizationStatusChanged(VehicleLocalizationStatus status) Parameters Type Name Description VehicleLocalizationStatus status Implements IStateReceiverLocalizationEventListener IStateReceiverListener"
  },
  "api/Holoride.ElasticSDK.StateReceiverInitializationError.html": {
    "href": "api/Holoride.ElasticSDK.StateReceiverInitializationError.html",
    "title": "Enum StateReceiverInitializationError | ElasticSDK Documentation",
    "keywords": "Enum StateReceiverInitializationError Error states that may occur during StateReceiver initialization, typically while connecting to a required service. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public enum StateReceiverInitializationError Fields Name Description ServiceAuthenticationFailed This error is raised when a required service refused the connection. This may be the case when the current application built using an invalid holoride manifest (HMF). ServiceConnectionFailed This error is raised when a required service could not be connected to. This may be the case when the holoride App has not been installed on the device. UnknownError An unknown error."
  },
  "api/Holoride.ElasticSDK.StateReceiverState.html": {
    "href": "api/Holoride.ElasticSDK.StateReceiverState.html",
    "title": "Enum StateReceiverState | ElasticSDK Documentation",
    "keywords": "Enum StateReceiverState The possible global states of the StateReceiver. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public enum StateReceiverState Fields Name Description Available The state receiver is currently available and ready to provide data. Initializing The state receiver is currently in a transitioning state, initializing a new backend. Unavailable The tate receiver initialization failed and the state receiver is unavailable."
  },
  "api/Holoride.ElasticSDK.StateRecorder.html": {
    "href": "api/Holoride.ElasticSDK.StateRecorder.html",
    "title": "Class StateRecorder | ElasticSDK Documentation",
    "keywords": "Class StateRecorder Utility component that can be used to record state received by StateReceiverBackends into a file that may later be used for playing the state back using the ReplayStateReceiverBackend. Recording is automatically stopped when the component is disabled. Inheritance object Object Component Behaviour MonoBehaviour StateRecorder Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.StateReceivers.dll Syntax [HelpURL(\"http://localhost:8080/api/Holoride.ElasticSDK.StateRecorder.html\")] public class StateRecorder : MonoBehaviour Methods StartRecording() Start a new recording. Will stop any currently running recording first. The recording will be stored in a file inside Unity's persistent data folder, named by the time stamp the recording starts at. Declaration public void StartRecording() StartRecording(string) Start a new recording. Will stop any currently running recording first. Declaration public void StartRecording(string filePath) Parameters Type Name Description string filePath The path to the file to store the recording in. StopRecording() Stops the currently running recording, if any. Declaration public void StopRecording()"
  },
  "api/Holoride.ElasticSDK.StationaryModeEvents.html": {
    "href": "api/Holoride.ElasticSDK.StationaryModeEvents.html",
    "title": "Class StationaryModeEvents | ElasticSDK Documentation",
    "keywords": "Class StationaryModeEvents Inheritance object Object Component Behaviour MonoBehaviour StationaryModeEvents Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public sealed class StationaryModeEvents : MonoBehaviour Properties OnStationaryModeDisabled Declaration public UnityEvent OnStationaryModeDisabled { get; } Property Value Type Description UnityEvent OnStationaryModeEnabled Declaration public UnityEvent OnStationaryModeEnabled { get; } Property Value Type Description UnityEvent"
  },
  "api/Holoride.ElasticSDK.StringUnityEvent.html": {
    "href": "api/Holoride.ElasticSDK.StringUnityEvent.html",
    "title": "Class StringUnityEvent | ElasticSDK Documentation",
    "keywords": "Class StringUnityEvent Inheritance object UnityEventBase UnityEvent<string> StringUnityEvent Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [Serializable] public class StringUnityEvent : UnityEvent<string>"
  },
  "api/Holoride.ElasticSDK.StylizedVehicleRotation.html": {
    "href": "api/Holoride.ElasticSDK.StylizedVehicleRotation.html",
    "title": "Class StylizedVehicleRotation | ElasticSDK Documentation",
    "keywords": "Class StylizedVehicleRotation Inheritance object Object Component Behaviour MonoBehaviour BaseRotation StylizedVehicleRotation Inherited Members BaseRotation.ShowDebugVisualization BaseRotation.ActiveRotationAxes BaseRotation.Awake() BaseRotation.OnEnable() BaseRotation.OnDisable() BaseRotation.Update() BaseRotation.Start() BaseRotation.OnDrawGizmos() Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [HelpURL(\"http://localhost:8080/api/Holoride.ElasticSDK.StylizedVehicleRotation.html\")] public class StylizedVehicleRotation : BaseRotation Fields PitchFromLongAcceleration Declaration [Space] [FormerlySerializedAs(\"LongitudinalAccelerationPitchCurve\")] [Tooltip(\"Defines how the absolute forward-backward acceleration (in m/s^2) affects the transform's signed pitch rotation around the x-axis (in degrees).\")] public AnimationCurve PitchFromLongAcceleration Field Value Type Description AnimationCurve PitchSmoothingSeconds Declaration [Tooltip(\"The strength of the longitudinal motion smoothing. Note: This induces latency which might affect UX and motion sickness.\")] [SerializeField] [Range(0, 3)] public float PitchSmoothingSeconds Field Value Type Description float RollFromLatAcceleration Declaration [Space] [FormerlySerializedAs(\"LateralAccelerationRollCurve\")] [Tooltip(\"Defines how the absolute left-right acceleration (in m/s^2) affects the transform's signed roll rotation around the z-axis (in degrees).\")] public AnimationCurve RollFromLatAcceleration Field Value Type Description AnimationCurve RollSmoothingSeconds Declaration [Tooltip(\"The strength of the lateral motion smoothing. Note: This induces latency which might affect UX and motion sickness.\")] [SerializeField] [Range(0, 3)] public float RollSmoothingSeconds Field Value Type Description float Methods UpdateEulerAngles() Declaration protected override Vector3 UpdateEulerAngles() Returns Type Description Vector3 Overrides BaseRotation.UpdateEulerAngles()"
  },
  "api/Holoride.ElasticSDK.TerrainCanvas.html": {
    "href": "api/Holoride.ElasticSDK.TerrainCanvas.html",
    "title": "Class TerrainCanvas | ElasticSDK Documentation",
    "keywords": "Class TerrainCanvas Once it is created by the ElasticSceneGenerator the TerrainCanvas takes care of all the different steps, that need to be done to create the terrain. Traversing over all filter trees to evaluate and generate the height-, texture- and spawnArea maps and creating the actual Terrain out of precomputed terrainData. Inheritance object TerrainCanvas Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class TerrainCanvas Constructors TerrainCanvas(GenerationContext, GenerationSettings, GenerationState) Instantiates a TerrainCanvas. Declaration public TerrainCanvas(GenerationContext context, GenerationSettings settings, GenerationState state) Parameters Type Name Description GenerationContext context Contains the immutable meta-information of a single update iteration. GenerationSettings settings Contains immutable data that cannot be changed during the whole generation loop. GenerationState state Contains the current state of the generation process and will be updated over time. TerrainCanvas(GenerationContext, TerrainCanvas) Initializes a new instance of the TerrainCanvas class. Declaration public TerrainCanvas(GenerationContext context, TerrainCanvas previousTerrainCanvas) Parameters Type Name Description GenerationContext context Contains the immutable meta-information of a single update iteration. TerrainCanvas previousTerrainCanvas The previous terrain canvas if it exists. Fields GenerationContext Contains the immutable meta-information of a single update iteration. Declaration public readonly GenerationContext GenerationContext Field Value Type Description GenerationContext GenerationSettings Contains immutable data that cannot be changed during the whole generation loop. Declaration public readonly GenerationSettings GenerationSettings Field Value Type Description GenerationSettings GenerationState Contains the current state of the generation process and will be updated over time. Declaration public readonly GenerationState GenerationState Field Value Type Description GenerationState HeightMap The HeightMap created by the height compositing. Declaration public IReadOnlyList<float> HeightMap Field Value Type Description IReadOnlyList<float> HeightRatioMap The HeightRatioMap created by the height compositing with height values normalized between 0 and 1. Declaration public float[,] HeightRatioMap Field Value Type Description float[,] HeightRatioMapChunk A single chunk to upload to the height of the TerrainData. Declaration public float[,] HeightRatioMapChunk Field Value Type Description float[,] PreviousTerrainCanvas The previous terrain canvas. Declaration public TerrainCanvas PreviousTerrainCanvas Field Value Type Description TerrainCanvas Terrain The actual Unity Terrain object. Declaration public Terrain Terrain Field Value Type Description Terrain TerrainData The terrainData of the Unity Terrain object. Declaration public TerrainData TerrainData Field Value Type Description TerrainData TerrainExtents The extents of the generated terrain. Declaration public readonly float TerrainExtents Field Value Type Description float TerrainFloatFilterOffset The offset of the terrain to the underlying FloatFilter. Declaration public readonly int TerrainFloatFilterOffset Field Value Type Description int TerrainGenerationSettings Contains immutable data that cannot be changed during the whole generation loop. Declaration public readonly TerrainGenerationSettings TerrainGenerationSettings Field Value Type Description TerrainGenerationSettings TerrainGenerationState Contains the current state of the terrain generation process and will be updated over time. Declaration public readonly TerrainGenerationState TerrainGenerationState Field Value Type Description TerrainGenerationState TerrainResolution The resolution of the generated terrain. Declaration public readonly int TerrainResolution Field Value Type Description int TextureWeightmapChunk A single chunk to upload to the texture weights of the TerrainData. Declaration public float[,,] TextureWeightmapChunk Field Value Type Description float[,,] TextureWeightmapData The heightRatioMap created by the height compositing with height values normalized between 0 and 1. Declaration public float[,,] TextureWeightmapData Field Value Type Description float[,,] Properties TextureLayers Gets the attached terrain layers. Declaration public List<KeyValuePair<TerrainLayer, MapWorker>> TextureLayers { get; } Property Value Type Description List<KeyValuePair<TerrainLayer, MapWorker>> Methods GenerateTerrainAsync(CancellationToken) Starts the whole generation process of the Terrain. Declaration public UniTask GenerateTerrainAsync(CancellationToken cancellationToken = default) Parameters Type Name Description CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask GetFloorPosition(GlobalPosition, bool) Computes the position on the ground. Declaration public GlobalPosition GetFloorPosition(GlobalPosition position, bool mindPivotHeight = true) Parameters Type Name Description GlobalPosition position The position. bool mindPivotHeight States whether the pivot altitude should be added. Returns Type Description GlobalPosition The position on the ground. GetHeightAtPosition(GlobalPosition, bool) Computes the height at a given position. Declaration public float GetHeightAtPosition(GlobalPosition position, bool mindPivotHeight = true) Parameters Type Name Description GlobalPosition position The position. bool mindPivotHeight States whether the pivot altitude should be added. Returns Type Description float The height at the given position. GetHeightAtPosition(Vector3, bool) Computes the height at a given position. Declaration public float GetHeightAtPosition(Vector3 position, bool mindPivotHeight = true) Parameters Type Name Description Vector3 position The position. bool mindPivotHeight States whether the pivot altitude should be added. Returns Type Description float The height at the given position. GetHeightAtUV(Vector2, bool) Computes the height at a given ratio. Declaration public float GetHeightAtUV(Vector2 ratio, bool mindPivotHeight = true) Parameters Type Name Description Vector2 ratio The ratio where to sample the height. bool mindPivotHeight States whether the pivot altitude should be added. Returns Type Description float The height at a given ratio. SampleMapData(GlobalPosition, float[]) Samples a mapData at a given position. Declaration public float SampleMapData(GlobalPosition position, float[] mapData) Parameters Type Name Description GlobalPosition position The position where to sample. float[] mapData The data to sample from. Returns Type Description float The mapData value."
  },
  "api/Holoride.ElasticSDK.TerrainGenerationSettings.html": {
    "href": "api/Holoride.ElasticSDK.TerrainGenerationSettings.html",
    "title": "Class TerrainGenerationSettings | ElasticSDK Documentation",
    "keywords": "Class TerrainGenerationSettings Contains immutable data that cannot be changed during the whole generation loop regarding terrain specific features. Inheritance object TerrainGenerationSettings Implements IGenerationSettings Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class TerrainGenerationSettings : IGenerationSettings Fields BasemapDistance The distance the terrain rendering falls back to a pre-lightened basemap. Declaration public float BasemapDistance Field Value Type Description float BaseMapResolution The resolution of the base map of the Terrain. Declaration public int BaseMapResolution Field Value Type Description int DrawInstanced States whether to enable instanced drawing of the terrain. Declaration public bool DrawInstanced Field Value Type Description bool HeightmapPixelError Trade-off between rendering performance and popup effects. Declaration public float HeightmapPixelError Field Value Type Description float HeightMapWorker The input worker that is used as a height map. Declaration public MapWorker HeightMapWorker Field Value Type Description MapWorker HeightUploadChunkCount The number of frames the upload process of the Heightmap to the VRAM is distributed into. A trade-off between performance and the time-span it takes. Declaration public int HeightUploadChunkCount Field Value Type Description int MaxHeight The maximum height of the terrain. Declaration public float MaxHeight Field Value Type Description float MinHeight The minimum height of the terrain. Declaration public float MinHeight Field Value Type Description float QuarterSizedTerrainObject States whether the terrain is quarter the size of the processed data. Declaration public bool QuarterSizedTerrainObject Field Value Type Description bool TerrainGOLayer The GameObject layer of the generated terrain. Declaration public int TerrainGOLayer Field Value Type Description int TerrainMaterial The material used for terrain rendering. Declaration public Material TerrainMaterial Field Value Type Description Material TextureLayers A list of pairs containing the TerrainLayers and their respective workers. Declaration public readonly List<KeyValuePair<TerrainLayer, MapWorker>> TextureLayers Field Value Type Description List<KeyValuePair<TerrainLayer, MapWorker>> TextureWeightmapUploadChunkCount The number of frames the upload process of the TextureWeightmap to the VRAM is distributed into. A trade-off between performance and the time-span it takes. Declaration public int TextureWeightmapUploadChunkCount Field Value Type Description int Implements IGenerationSettings"
  },
  "api/Holoride.ElasticSDK.TerrainGenerationState.html": {
    "href": "api/Holoride.ElasticSDK.TerrainGenerationState.html",
    "title": "Class TerrainGenerationState | ElasticSDK Documentation",
    "keywords": "Class TerrainGenerationState The GenerationContext extension for terrain-related generation. Inheritance object TerrainGenerationState Implements IGenerationState Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class TerrainGenerationState : IGenerationState Fields FinalGenerationContext The GenerationContext of the final terrain generation result. Declaration public GenerationContext FinalGenerationContext Field Value Type Description GenerationContext FinalTerrainCanvas The TerrainCanvas of the latest finished pipeline iteration. Declaration public TerrainCanvas FinalTerrainCanvas Field Value Type Description TerrainCanvas GenerationContextUnderConstruction The GenerationContext of the terrain that is currently generated. Declaration public GenerationContext GenerationContextUnderConstruction Field Value Type Description GenerationContext TerrainCanvasUnderConstruction The TerrainCanvas of the current pipeline iteration that is not finished yet. This value is null if no TerrainCanvas is currently under construction. Declaration public TerrainCanvas TerrainCanvasUnderConstruction Field Value Type Description TerrainCanvas Properties HasFinalTerrainCanvas Gets a value indicating whether a FinalTerrainCanvas is available. Declaration public bool HasFinalTerrainCanvas { get; } Property Value Type Description bool HasTerrainCanvasUnderConstruction Gets a value indicating whether there is a TerrainCanvasUnderConstruction. Declaration public bool HasTerrainCanvasUnderConstruction { get; } Property Value Type Description bool Implements IGenerationState"
  },
  "api/Holoride.ElasticSDK.TickBasedMeshPool.html": {
    "href": "api/Holoride.ElasticSDK.TickBasedMeshPool.html",
    "title": "Class TickBasedMeshPool | ElasticSDK Documentation",
    "keywords": "Class TickBasedMeshPool This class provides a pool of meshes that assumes most meshes are requested when needed and all are returned after being used. Inheritance object TickBasedMeshPool Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class TickBasedMeshPool Constructors TickBasedMeshPool(float) Declaration public TickBasedMeshPool(float allowedUnusedMeshPercentage = 0.4) Parameters Type Name Description float allowedUnusedMeshPercentage Methods Clear() Destroys all meshes in the mesh pool. Declaration public void Clear() Get() Declaration public Mesh Get() Returns Type Description Mesh ReturnAll() Declaration public void ReturnAll()"
  },
  "api/Holoride.ElasticSDK.TileAreaDescription.html": {
    "href": "api/Holoride.ElasticSDK.TileAreaDescription.html",
    "title": "Class TileAreaDescription | ElasticSDK Documentation",
    "keywords": "Class TileAreaDescription Manages the distribution of tiles of a certain zoom level within the given bounds. Inheritance object TileAreaDescription Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class TileAreaDescription Constructors TileAreaDescription(int, GlobalBounds, GeoCoordinate) Constructor of the TileAreaDescription class. Declaration public TileAreaDescription(int zoomLevel, GlobalBounds bounds, GeoCoordinate pivot) Parameters Type Name Description int zoomLevel The zoom level of this tile area. GlobalBounds bounds The bounds to gather the resources within. GeoCoordinate pivot The pivot to transfer cartesian into geoCoordinates. Fields NorthWestGeo The most north-west GeoCoordinate. Declaration public readonly GeoCoordinate NorthWestGeo Field Value Type Description GeoCoordinate NorthWestTilePos The most north-west TilePosition. Declaration public readonly Vector2Int NorthWestTilePos Field Value Type Description Vector2Int NorthWestTileUV The most north-west UV coordinate. Declaration public readonly Vector2 NorthWestTileUV Field Value Type Description Vector2 SouthEastGeo The most south-east GeoCoordinate. Declaration public readonly GeoCoordinate SouthEastGeo Field Value Type Description GeoCoordinate SouthEastTilePos The most south-east TilePosition. Declaration public readonly Vector2Int SouthEastTilePos Field Value Type Description Vector2Int SouthEastTileUV The most south-east UV coordinate. Declaration public readonly Vector2 SouthEastTileUV Field Value Type Description Vector2 ZoomLevel The map service this tile array refers to. Declaration public readonly int ZoomLevel Field Value Type Description int Properties Center Gets the center tile. Declaration public Vector2Int Center { get; } Property Value Type Description Vector2Int GlobalTilePositions Gets a list of all tile positions in global space. Declaration public List<Vector2Int> GlobalTilePositions { get; } Property Value Type Description List<Vector2Int> LocalTilePositions Gets a list of all tile positions in local space. Declaration public List<Vector2Int> LocalTilePositions { get; } Property Value Type Description List<Vector2Int> TileCount Gets the total tile count. Declaration public int TileCount { get; } Property Value Type Description int TileCountNorthSouth Gets the tile count from north to south. Declaration public int TileCountNorthSouth { get; } Property Value Type Description int TileCountWestEast Gets the tile count from west to east. Declaration public int TileCountWestEast { get; } Property Value Type Description int Methods LocalToGlobalTilePos(Vector2Int) Converts a local position to a global tile position. Declaration public Vector2Int LocalToGlobalTilePos(Vector2Int localTilePos) Parameters Type Name Description Vector2Int localTilePos The local tile position to convert. Returns Type Description Vector2Int The corresponding global tile position. MaximumTileCount(int, float, out int, out int) The further to north tiles are requested, the smaller is the area they cover. This method computes the maximum number of tiles that is required to cover areas under a given maximum supported latitude. Main usage is to have a reasonable magnitude for memory allocation. Declaration public static void MaximumTileCount(int zoomLevel, float extents, out int maximumTileCountWestEast, out int maximumTileCountNorthSouth) Parameters Type Name Description int zoomLevel The zoomLevel. float extents The extents of the area. int maximumTileCountWestEast The maximum tile count in west east direction. int maximumTileCountNorthSouth The maximum tile count in north south direction. MaximumTileCount(int, float) The further to north tiles are requested, the smaller is the area they cover. This method computes the maximum number of tiles that is required to cover areas under a given maximum supported latitude. Main usage is to have a reasonable magnitude for memory allocation. Declaration public static int MaximumTileCount(int zoomLevel, float extents) Parameters Type Name Description int zoomLevel The zoomLevel. float extents The extents of the area. Returns Type Description int The maximum map tile number that can occur."
  },
  "api/Holoride.ElasticSDK.TileDataCache.html": {
    "href": "api/Holoride.ElasticSDK.TileDataCache.html",
    "title": "Class TileDataCache | ElasticSDK Documentation",
    "keywords": "Class TileDataCache Utilities for interacting with the application's tiled data cache. Inheritance object TileDataCache Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public static class TileDataCache Methods ClearTileData() Completely clears the tile data cache for this application. Declaration public static void ClearTileData() PrefetchTileDataAsync(Node, GeoCoordinate, float, params IContextProvider[]) Prefetches resources (e.g. tile data) for a specified area. It is the callers responsibility to run the returned enumerator as a coroutine. Declaration public static UniTask PrefetchTileDataAsync(Node sceneDefinition, GeoCoordinate center, float extents, params IContextProvider[] contextProviders) Parameters Type Name Description Node sceneDefinition The node up to which to gather resources for a graph, typically a ElasticSceneDefinitionNode. GeoCoordinate center The center of the area in which to gather resources. float extents The extents of the area in which to gather resources. IContextProvider[] contextProviders List of context providers required for the evaluated graph, if any. Returns Type Description Cysharp.Threading.Tasks.UniTask Examples // Inside some MonoBehaviour: void OnEnable() { StartCoroutine(TileDataManager.PrefetchTileData(sceneDefinition, center, extents, GetComponents<IContextProvider>()); // or StartCoroutine(DoPrefetchAndMore()); } IEnumerator DoPrefetchAndMore() { // ... yield return TileDataManager.PrefetchTileData(sceneDefinition, center, extents, GetComponents<IContextProvider>()); // ... } PrefetchTileDataAsync(Node, GeoCoordinate, float, CancellationToken, params IContextProvider[]) Prefetches resources (e.g. tile data) for a specified area. It is the callers responsibility to run the returned enumerator as a coroutine. Declaration public static UniTask PrefetchTileDataAsync(Node sceneDefinition, GeoCoordinate center, float extents, CancellationToken cancellationToken, params IContextProvider[] contextProviders) Parameters Type Name Description Node sceneDefinition The node up to which to gather resources for a graph, typically a ElasticSceneDefinitionNode. GeoCoordinate center The center of the area in which to gather resources. float extents The extents of the area in which to gather resources. CancellationToken cancellationToken The token to monitor for cancellation requests. IContextProvider[] contextProviders List of context providers required for the evaluated graph, if any. Returns Type Description Cysharp.Threading.Tasks.UniTask Examples // Inside some MonoBehaviour: void OnEnable() { StartCoroutine(TileDataManager.PrefetchTileData(sceneDefinition, center, extents, GetComponents<IContextProvider>()); // or StartCoroutine(DoPrefetchAndMore()); } IEnumerator DoPrefetchAndMore() { // ... yield return TileDataManager.PrefetchTileData(sceneDefinition, center, extents, GetComponents<IContextProvider>()); // ... } PrefetchTileDataAsync(Node, IRoute, float, params IContextProvider[]) Prefetches resources (e.g. tile data) along a specified route. Declaration public static UniTask PrefetchTileDataAsync(Node sceneDefinition, IRoute route, float extents, params IContextProvider[] contextProviders) Parameters Type Name Description Node sceneDefinition The node up to which to gather resources for a graph, typically a ElasticSceneDefinitionNode. IRoute route The route along which to prefetch. float extents The extents around the route to prefetch. IContextProvider[] contextProviders The context providers to use while prefetching. Returns Type Description Cysharp.Threading.Tasks.UniTask PrefetchTileDataAsync(Node, IRoute, float, CancellationToken, params IContextProvider[]) Prefetches resources (e.g. tile data) along a specified route. Declaration public static UniTask PrefetchTileDataAsync(Node sceneDefinition, IRoute route, float extents, CancellationToken cancellationToken, params IContextProvider[] contextProviders) Parameters Type Name Description Node sceneDefinition The node up to which to gather resources for a graph, typically a ElasticSceneDefinitionNode. IRoute route The route along which to prefetch. float extents The extents around the route to prefetch. CancellationToken cancellationToken The token to monitor for cancellation requests. IContextProvider[] contextProviders The context providers to use while prefetching. Returns Type Description Cysharp.Threading.Tasks.UniTask"
  },
  "api/Holoride.ElasticSDK.TileDataCacheFormatVersionAttribute.html": {
    "href": "api/Holoride.ElasticSDK.TileDataCacheFormatVersionAttribute.html",
    "title": "Class TileDataCacheFormatVersionAttribute | ElasticSDK Documentation",
    "keywords": "Class TileDataCacheFormatVersionAttribute Inheritance object Attribute TileDataCacheFormatVersionAttribute Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Class)] [BaseTypeRequired(typeof(TileDataService<>))] public class TileDataCacheFormatVersionAttribute : Attribute Properties CacheVersion Declaration public int CacheVersion { get; set; } Property Value Type Description int"
  },
  "api/Holoride.ElasticSDK.TileDataManager-1.html": {
    "href": "api/Holoride.ElasticSDK.TileDataManager-1.html",
    "title": "Class TileDataManager<T> | ElasticSDK Documentation",
    "keywords": "Class TileDataManager<T> Manages the loading and unloading of data tiles. Inheritance object TileDataManager<T> TileTextureManager Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class TileDataManager<T> where T : class Type Parameters Name Description T Constructors TileDataManager(int, float, ITileDataProvider<T>) The base constructor of a TileDataManager. Declaration public TileDataManager(int zoomLevel, float extents, ITileDataProvider<T> tileDataProvider) Parameters Type Name Description int zoomLevel The zoom level. float extents The extents of the area in which tiles should be kept in memory. ITileDataProvider<T> tileDataProvider The tile data provider. Methods GetTile(Vector2Int) Gets a specific tile at a given global position. Declaration public T GetTile(Vector2Int tilePos) Parameters Type Name Description Vector2Int tilePos The tile position. Returns Type Description T GetTiles(TileAreaDescription) Returns an IEnumerable T for all Tiles in the TileAreaDescription. Declaration public IEnumerable<T> GetTiles(TileAreaDescription tileAreaDescription) Parameters Type Name Description TileAreaDescription tileAreaDescription The area for which to return tiles. Returns Type Description IEnumerable<T> All tiles in the given area. Exceptions Type Condition ArgumentException Throws an ArgumentException in case the provided TileAreaDescription isn't fully contained in the supported area of this TileDataManager. HasTile(Vector2Int) Checks if a tile is currently in the memory. Declaration public bool HasTile(Vector2Int tilePos) Parameters Type Name Description Vector2Int tilePos The tile position. Returns Type Description bool True, if the tile was already downloaded. LoadResourcesAsync(TileAreaDescription, Action<Vector2Int, T>, Action<Vector2Int, T>, IProgress<float>, CancellationToken) Loads all the resources that are not already available. Declaration public UniTask LoadResourcesAsync(TileAreaDescription tileAreaDescription, Action<Vector2Int, T> onTileLoaded = null, Action<Vector2Int, T> onTileUnloaded = null, IProgress<float> onProgressUpdate = null, CancellationToken cancellationToken = default) Parameters Type Name Description TileAreaDescription tileAreaDescription The tile array. Action<Vector2Int, T> onTileLoaded The function to call when the tile is loaded. This function is called on a separate thread, e.g. in order to deserialize data in a background process. Action<Vector2Int, T> onTileUnloaded The function to call when the tile is unloaded. IProgress<float> onProgressUpdate Called with relative progress in [0, 1]. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask"
  },
  "api/Holoride.ElasticSDK.TileDataService-1.html": {
    "href": "api/Holoride.ElasticSDK.TileDataService-1.html",
    "title": "Class TileDataService<T> | ElasticSDK Documentation",
    "keywords": "Class TileDataService<T> Downloads and caches tiles to the hard drive. Inheritance object TileDataService<T> TileImageServiceRoadMask Implements ITileDataService<T> ITileDataProvider<T> Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public abstract class TileDataService<T> : ITileDataService<T>, ITileDataProvider<T> Type Parameters Name Description T Constructors TileDataService(TileDataServiceConfiguration) Instantiates a TileDataService. Declaration protected TileDataService(TileDataServiceConfiguration configuration) Parameters Type Name Description TileDataServiceConfiguration configuration Fields CacheVersion Version of the cached files. Used in case of incompatibility with previously downloaded files. Declaration protected readonly int CacheVersion Field Value Type Description int Configuration Configuration for this service. Declaration protected readonly TileDataServiceConfiguration Configuration Field Value Type Description TileDataServiceConfiguration VersionedCacheSubDirectory The fully qualified path to the tile data cache, of the specific service, based on its name and version. Declaration protected readonly string VersionedCacheSubDirectory Field Value Type Description string Methods CacheMapTileDataAsync(TileAreaDescription, IProgress<float>, CancellationToken) Caches all map tiles of a given tile array. Declaration public UniTask<LoadResourceResult> CacheMapTileDataAsync(TileAreaDescription tileAreaDescription, IProgress<float> onProgressUpdate = null, CancellationToken cancellationToken = default) Parameters Type Name Description TileAreaDescription tileAreaDescription A tile array. IProgress<float> onProgressUpdate A callback providing the current caching progress as a value between 0 and 1. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask<T><LoadResourceResult> CacheMapTileDataAsync(int, Vector2Int, IProgress<float>, CancellationToken) Caches a single map tile. Declaration public UniTask<LoadResourceResult> CacheMapTileDataAsync(int zoomLevel, Vector2Int tilePos, IProgress<float> onProgressUpdate = null, CancellationToken cancellationToken = default) Parameters Type Name Description int zoomLevel The zoom level the tile position refers to. Vector2Int tilePos The global position index with respect to the chosen zoom level. IProgress<float> onProgressUpdate A callback providing the current caching progress as a value between 0 and 1. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask<T><LoadResourceResult> Deserialize(byte[], out T) Defines how the downloaded data is deserialized. This function will be called on the Unity main thread. Declaration protected virtual bool Deserialize(byte[] data, out T result) Parameters Type Name Description byte[] data The downloaded data. T result The deserialized object. Returns Type Description bool Whether the object was deserialized successfully. Deserialize(Stream, out T) Defines how the downloaded data is deserialized. This function will be called on the Unity main thread. Declaration protected virtual bool Deserialize(Stream data, out T result) Parameters Type Name Description Stream data The downloaded data. T result The deserialized object. Returns Type Description bool Whether the object was deserialized successfully. DeserializeAsync(byte[], out T) Defines how the downloaded data is deserialized. This function is an alternative to the Deserialize function and will be called in an extra thread. Therefore, it is not applicable for Unity objects. Declaration protected virtual bool DeserializeAsync(byte[] data, out T result) Parameters Type Name Description byte[] data The downloaded data. T result The deserialized object. Returns Type Description bool Whether the object was deserialized successfully. DeserializeAsync(Stream, out T) Defines how the downloaded data is deserialized. This function is an alternative to the Deserialize function and will be called in an extra thread. Therefore, it is not applicable for Unity objects. Declaration protected virtual bool DeserializeAsync(Stream data, out T result) Parameters Type Name Description Stream data The downloaded data. T result The deserialized object. Returns Type Description bool Whether the object was deserialized successfully. GetFileName(int, Vector2Int) The file name based on a given tile position and zoom level. Declaration protected abstract string GetFileName(int zoomLevel, Vector2Int tilePos) Parameters Type Name Description int zoomLevel The zoom level the tile position refers to. Vector2Int tilePos The tile position of the tile which should get downloaded. Returns Type Description string The file name. GetWebRequest(int, Vector2Int, CancellationToken) The download URL based on a given tile position and zoom level. Declaration protected abstract UniTask<Func<UnityWebRequest>> GetWebRequest(int zoomLevel, Vector2Int tilePos, CancellationToken cancellationToken = default) Parameters Type Name Description int zoomLevel The zoom level the tile position refers to. Vector2Int tilePos The tile position of the tile which should get downloaded. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask<T><Func<UnityWebRequest>> The download url. PrepareTileData(int, Vector2Int, IProgress<float>, CancellationToken, string, bool) This only exists for Elastic SDK tests; it will go a way in a future refactor. Do not override this method outside of tests. It is only visible to all sub-classes due to C# limitations, not by design. Declaration protected virtual Task<LoadResourceResult> PrepareTileData(int zoomLevel, Vector2Int tilePos, IProgress<float> onProgressUpdate, CancellationToken cancellationToken, string fileName, bool retryUntilDownloadedSucceeded = true) Parameters Type Name Description int zoomLevel Vector2Int tilePos IProgress<float> onProgressUpdate CancellationToken cancellationToken string fileName bool retryUntilDownloadedSucceeded Returns Type Description Task<LoadResourceResult> RequestMapTileDataAsync(int, Vector2Int, Action<T>, CancellationToken) Requests a tile data. Declaration public UniTask RequestMapTileDataAsync(int zoomLevel, Vector2Int tilePos, Action<T> onTileLoaded, CancellationToken cancellationToken = default) Parameters Type Name Description int zoomLevel The zoom level the tile position refers to. Vector2Int tilePos The global position index with respect to the chosen zoom level. Action<T> onTileLoaded A callback providing the object that has been loaded. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask Implements ITileDataService<T> ITileDataProvider<T>"
  },
  "api/Holoride.ElasticSDK.TileDataService.html": {
    "href": "api/Holoride.ElasticSDK.TileDataService.html",
    "title": "Class TileDataService | ElasticSDK Documentation",
    "keywords": "Class TileDataService Inheritance object TileDataService Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public static class TileDataService Properties CacheFolder Gets path to the directory containing cached tile data. Used to store and re-use downloaded data. Declaration public static string CacheFolder { get; } Property Value Type Description string EmbeddedFolder Gets path to the directory containing embedded tile data. Used to save on server traffic. Declaration public static string EmbeddedFolder { get; } Property Value Type Description string"
  },
  "api/Holoride.ElasticSDK.TileDataServiceConfiguration.html": {
    "href": "api/Holoride.ElasticSDK.TileDataServiceConfiguration.html",
    "title": "Class TileDataServiceConfiguration | ElasticSDK Documentation",
    "keywords": "Class TileDataServiceConfiguration Groups configuration values passed to TileDataService<T> instances used when running a Pipeline. Different configuration values may be used in a regular pipeline run versus tests, editor tooling and so on. Inheritance object TileDataServiceConfiguration Implements IGenerationSettings Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class TileDataServiceConfiguration : IGenerationSettings Constructors TileDataServiceConfiguration() Creates a new, uninitialized set of configuration values. Declaration public TileDataServiceConfiguration() TileDataServiceConfiguration(TileDataServiceConfiguration) Creates a copy of the specified configuration set. Useful for creating copies of the default configuration, when only overwriting a subset of the available configuration values. var config = new TileDataServiceConfiguration(TileDataServiceConfiguration.Default) { LogDownloadURLs = true, }; Declaration public TileDataServiceConfiguration(TileDataServiceConfiguration copyFrom) Parameters Type Name Description TileDataServiceConfiguration copyFrom The configuration to initialize the defaults from. Fields CachedFileUpdateInterval Time to wait until a cached file will try to update itself. Declaration public TimeSpan CachedFileUpdateInterval Field Value Type Description TimeSpan LogDownloadURLs Whether to log URLs of downloaded tile data for easier debugging. Declaration [Obsolete] public bool LogDownloadURLs Field Value Type Description bool MapServiceCredentials Credentials used to authenticate with the tile data server. Used in cases where we don't have an access token. Declaration public string MapServiceCredentials Field Value Type Description string QueryMapServiceAccessTokenFunc Function to query the current AccessToken that is used to authenticate with the tile data server. Declaration public Func<string> QueryMapServiceAccessTokenFunc Field Value Type Description Func<string> ReadableCacheDirectories A list of directories with previously downloaded tile data. In the default configuration, this includes the mutable on-device cache as well as a set of application embedded, pre-downloaded set of data. Usually should also contain the WritableCacheDirectory. Declaration public string[] ReadableCacheDirectories Field Value Type Description string[] WritableCacheDirectory A directory to which to save downloaded tile data, typically a subdirectory of the persistentDataPath. Usually should also be present in the ReadableCacheDirectories. Declaration public string WritableCacheDirectory Field Value Type Description string Properties MapServiceAccessToken Gets the access token used to authenticate with the tile data server. Declaration public string MapServiceAccessToken { get; } Property Value Type Description string Methods WaitForMapCredentials(CancellationToken) Declaration public UniTask WaitForMapCredentials(CancellationToken cancellationToken = default) Parameters Type Name Description CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask Implements IGenerationSettings"
  },
  "api/Holoride.ElasticSDK.TileDataServiceConfigurationUtils.html": {
    "href": "api/Holoride.ElasticSDK.TileDataServiceConfigurationUtils.html",
    "title": "Class TileDataServiceConfigurationUtils | ElasticSDK Documentation",
    "keywords": "Class TileDataServiceConfigurationUtils Inheritance object TileDataServiceConfigurationUtils Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public static class TileDataServiceConfigurationUtils Properties Default Gets the default configuration value set used at runtime. Declaration public static TileDataServiceConfiguration Default { get; } Property Value Type Description TileDataServiceConfiguration"
  },
  "api/Holoride.ElasticSDK.TileImageServiceRoadMask.html": {
    "href": "api/Holoride.ElasticSDK.TileImageServiceRoadMask.html",
    "title": "Class TileImageServiceRoadMask | ElasticSDK Documentation",
    "keywords": "Class TileImageServiceRoadMask Downloads RoadMask tiles and deserializes them into textures. Inheritance object TileDataService<Texture2D> TileImageServiceRoadMask Implements ITileDataService<Texture2D> ITileDataProvider<Texture2D> Inherited Members TileDataService<Texture2D>.Configuration TileDataService<Texture2D>.CacheVersion TileDataService<Texture2D>.VersionedCacheSubDirectory TileDataService<Texture2D>.CacheMapTileDataAsync(int, Vector2Int, IProgress<float>, CancellationToken) TileDataService<Texture2D>.PrepareTileData(int, Vector2Int, IProgress<float>, CancellationToken, string, bool) TileDataService<Texture2D>.CacheMapTileDataAsync(TileAreaDescription, IProgress<float>, CancellationToken) TileDataService<Texture2D>.RequestMapTileDataAsync(int, Vector2Int, Action<Texture2D>, CancellationToken) TileDataService<Texture2D>.Deserialize(Stream, out Texture2D) TileDataService<Texture2D>.DeserializeAsync(byte[], out Texture2D) TileDataService<Texture2D>.DeserializeAsync(Stream, out Texture2D) Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [Obfuscation(Exclude = true)] public class TileImageServiceRoadMask : TileDataService<Texture2D>, ITileDataService<Texture2D>, ITileDataProvider<Texture2D> Constructors TileImageServiceRoadMask(TileDataServiceConfiguration) Declaration public TileImageServiceRoadMask(TileDataServiceConfiguration configuration) Parameters Type Name Description TileDataServiceConfiguration configuration Fields Resolution The resolution of each tile image. Declaration public const int Resolution = 256 Field Value Type Description int Methods Deserialize(byte[], out Texture2D) Defines how the downloaded data is deserialized. Declaration protected override bool Deserialize(byte[] data, out Texture2D result) Parameters Type Name Description byte[] data The downloaded data. Texture2D result The deserialized object. Returns Type Description bool Whether the object was deserialized successfully. Overrides Holoride.ElasticSDK.TileDataService<UnityEngine.Texture2D>.Deserialize(byte[], out UnityEngine.Texture2D) GetFileName(int, Vector2Int) Gets the dedicated download fileName for the specific service. Declaration protected override string GetFileName(int zoomLevel, Vector2Int tilePos) Parameters Type Name Description int zoomLevel The zoom level the tile position refers to. Vector2Int tilePos The global position index with respect to the chosen zoom level. Returns Type Description string The file name. Overrides Holoride.ElasticSDK.TileDataService<UnityEngine.Texture2D>.GetFileName(int, UnityEngine.Vector2Int) GetWebRequest(int, Vector2Int, CancellationToken) Gets the dedicated download URL for the specific service. Declaration protected override UniTask<Func<UnityWebRequest>> GetWebRequest(int zoomLevel, Vector2Int tilePos, CancellationToken cancellationToken = default) Parameters Type Name Description int zoomLevel The zoom level the tile position refers to. Vector2Int tilePos The global position index with respect to the chosen zoom level. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask<T><Func<UnityWebRequest>> The request string to download the tile. Overrides Holoride.ElasticSDK.TileDataService<UnityEngine.Texture2D>.GetWebRequest(int, UnityEngine.Vector2Int, System.Threading.CancellationToken) Implements ITileDataService<T> ITileDataProvider<T>"
  },
  "api/Holoride.ElasticSDK.TileTextureManager.html": {
    "href": "api/Holoride.ElasticSDK.TileTextureManager.html",
    "title": "Class TileTextureManager | ElasticSDK Documentation",
    "keywords": "Class TileTextureManager The base class of a TileTextureManager holds all important information about the tiles that should get downloaded. Resulting from the zoom level and the tile position it creates the correct key to download the correct tile. Inheritance object TileDataManager<Texture2D> TileTextureManager Inherited Members TileDataManager<Texture2D>.HasTile(Vector2Int) TileDataManager<Texture2D>.GetTile(Vector2Int) TileDataManager<Texture2D>.GetTiles(TileAreaDescription) TileDataManager<Texture2D>.LoadResourcesAsync(TileAreaDescription, Action<Vector2Int, Texture2D>, Action<Vector2Int, Texture2D>, IProgress<float>, CancellationToken) Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public class TileTextureManager : TileDataManager<Texture2D> Constructors TileTextureManager(int, float, ITileDataProvider<Texture2D>) The base constructor of a TileDataManager. Declaration public TileTextureManager(int zoomLevel, float extents, ITileDataProvider<Texture2D> tileDataProvider) Parameters Type Name Description int zoomLevel The zoom level. float extents The extents of the area in which tiles should be kept in memory. ITileDataProvider<Texture2D> tileDataProvider The tile data provider. Methods FillTextureArrayAsync(TileAreaDescription, Texture2DArray, int, IProgress<float>, CancellationToken) Loads all required textures and fills a texture array. Declaration public UniTask FillTextureArrayAsync(TileAreaDescription tileAreaDescription, Texture2DArray textureArray, int copiedTexturesPerFrame = 5, IProgress<float> onProgressUpdate = null, CancellationToken cancellationToken = default) Parameters Type Name Description TileAreaDescription tileAreaDescription The tile array. Texture2DArray textureArray The texture array. int copiedTexturesPerFrame The number of textures to be copied per frame. IProgress<float> onProgressUpdate Called with relative progress in [0, 1]. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask"
  },
  "api/Holoride.ElasticSDK.TravelInformationState.html": {
    "href": "api/Holoride.ElasticSDK.TravelInformationState.html",
    "title": "Struct TravelInformationState | ElasticSDK Documentation",
    "keywords": "Struct TravelInformationState The TravelInformation state contains information based on the current location and route driven such as the estimated time to arrival. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [Serializable] public struct TravelInformationState Fields CurrentSpeedSegment The speed segment based on the current location. Declaration public SpeedSegment CurrentSpeedSegment Field Value Type Description SpeedSegment CurrentTravelDistanceMeter The distance in meters moved along the route. Declaration public float CurrentTravelDistanceMeter Field Value Type Description float CurrentTravelDurationSec The time in seconds since the travel started. Declaration public double CurrentTravelDurationSec Field Value Type Description double RemainingTravelDistanceMeter The remaining distance in meters until the end of the route. Declaration public float RemainingTravelDistanceMeter Field Value Type Description float RemainingTravelDurationSec The estimated remaining time in seconds that remain until arriving at the destination. Declaration public double RemainingTravelDurationSec Field Value Type Description double Properties TotalEstimatedTravelDistanceMeter Gets the estimated total distance until the end of the route. Declaration public float TotalEstimatedTravelDistanceMeter { get; } Property Value Type Description float TotalEstimatedTravelDurationSec Gets the total estimated time of travel. Declaration public double TotalEstimatedTravelDurationSec { get; } Property Value Type Description double Methods Equals(TravelInformationState, TravelInformationState) Declaration public bool Equals(TravelInformationState x, TravelInformationState y) Parameters Type Name Description TravelInformationState x TravelInformationState y Returns Type Description bool Equals(TravelInformationState) Declaration public bool Equals(TravelInformationState other) Parameters Type Name Description TravelInformationState other Returns Type Description bool GetHashCode(TravelInformationState) Declaration public int GetHashCode(TravelInformationState obj) Parameters Type Name Description TravelInformationState obj Returns Type Description int ToString() Declaration public override string ToString() Returns Type Description string Overrides ValueType.ToString()"
  },
  "api/Holoride.ElasticSDK.TypeCacheSingleton.html": {
    "href": "api/Holoride.ElasticSDK.TypeCacheSingleton.html",
    "title": "Class TypeCacheSingleton | ElasticSDK Documentation",
    "keywords": "Class TypeCacheSingleton Inheritance object Object ScriptableObject SingletonBase Singleton<TypeCacheSingleton> TypeCacheSingleton Inherited Members Singleton<TypeCacheSingleton>.Instance SingletonBase.SingletonOnCreate() SingletonBase.SingletonOnEnable() SingletonBase.SingletonOnDisable() Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [HelpURL(\"http://localhost:8080/api/Holoride.ElasticSDK.TypeCacheSingleton.html\")] public class TypeCacheSingleton : Singleton<TypeCacheSingleton> Methods GetMethodsWithAttribute(Type) Declaration public ICollection<MethodInfo> GetMethodsWithAttribute(Type attributeType) Parameters Type Name Description Type attributeType Returns Type Description ICollection<MethodInfo> GetMethodsWithAttribute<T>() Declaration public ICollection<MethodInfo> GetMethodsWithAttribute<T>() where T : Attribute Returns Type Description ICollection<MethodInfo> Type Parameters Name Description T GetTypesDerivedFrom(Type) Declaration public ICollection<Type> GetTypesDerivedFrom(Type parentType) Parameters Type Name Description Type parentType Returns Type Description ICollection<Type> GetTypesDerivedFrom<T>() Declaration public ICollection<Type> GetTypesDerivedFrom<T>() Returns Type Description ICollection<Type> Type Parameters Name Description T OnAfterDeserialize() Declaration public void OnAfterDeserialize() OnBeforeSerialize() Declaration public void OnBeforeSerialize()"
  },
  "api/Holoride.ElasticSDK.TypeExtensions.html": {
    "href": "api/Holoride.ElasticSDK.TypeExtensions.html",
    "title": "Class TypeExtensions | ElasticSDK Documentation",
    "keywords": "Class TypeExtensions Inheritance object TypeExtensions Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public static class TypeExtensions Methods GetSerializedField(Type, string) Declaration public static FieldInfo GetSerializedField(this Type type, string name) Parameters Type Name Description Type type string name Returns Type Description FieldInfo"
  },
  "api/Holoride.ElasticSDK.UniTaskUtils.html": {
    "href": "api/Holoride.ElasticSDK.UniTaskUtils.html",
    "title": "Class UniTaskUtils | ElasticSDK Documentation",
    "keywords": "Class UniTaskUtils Utility calls to workaround some UniTask inconveniences. Inheritance object UniTaskUtils Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public static class UniTaskUtils Remarks Use immediate condition pre-check to ensure synchronous return when possible. UniTask.WaitUntil will perform the check in the next frame to mimic the behavior of Unity's coroutine WaitUntil. Methods WaitUntilOrEarlyOut(Func<bool>, PlayerLoopTiming, CancellationToken) Declaration public static UniTask WaitUntilOrEarlyOut(Func<bool> predicate, PlayerLoopTiming timing = PlayerLoopTiming.Update, CancellationToken cancellationToken = default) Parameters Type Name Description Func<bool> predicate Cysharp.Threading.Tasks.PlayerLoopTiming timing CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask Remarks Use immediate condition pre-check to ensure synchronous return when possible. UniTask.WaitUntil will perform the check in the next frame to mimic the behavior of Unity's coroutine WaitUntil. WaitWhileOrEarlyOut(Func<bool>, PlayerLoopTiming, CancellationToken) Declaration public static UniTask WaitWhileOrEarlyOut(Func<bool> predicate, PlayerLoopTiming timing = PlayerLoopTiming.Update, CancellationToken cancellationToken = default) Parameters Type Name Description Func<bool> predicate Cysharp.Threading.Tasks.PlayerLoopTiming timing CancellationToken cancellationToken Returns Type Description Cysharp.Threading.Tasks.UniTask Remarks Use immediate condition pre-check to ensure synchronous return when possible. UniTask.WaitUntil will perform the check in the next frame to mimic the behavior of Unity's coroutine WaitUntil."
  },
  "api/Holoride.ElasticSDK.Utils.html": {
    "href": "api/Holoride.ElasticSDK.Utils.html",
    "title": "Class Utils | ElasticSDK Documentation",
    "keywords": "Class Utils A collection of useful functions without a specific object context. Inheritance object Utils Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public static class Utils Methods ApplyPoseToTransform(Pose, Transform) Applies a Pose to a transform. Declaration public static void ApplyPoseToTransform(Pose pose, Transform transform) Parameters Type Name Description Pose pose The pose to apply. Transform transform The transform to apply the pose to. BlochHash(double, double) Computes a hash code using a strategy by Josh Bloch. Declaration public static int BlochHash(double x, double y) Parameters Type Name Description double x The first seed value. double y The second seed value. Returns Type Description int The hashed value. CalculateGaussianKernel(int, float) Calculates a Gaussian Kernel. Declaration public static float[,] CalculateGaussianKernel(int length, float weight) Parameters Type Name Description int length The lenght. float weight The weight. Returns Type Description float[,] A float array with the Gaussian Kernel. Clamp(double, double, double) Clamps a double value between a min and a max value. Declaration public static double Clamp(double number, double min, double max) Parameters Type Name Description double number The value to clamp. double min The minimum value. double max The maximum value. Returns Type Description double The clamped value. Clamp01(double) Clamps a double value into a range of [0, 1]. Declaration public static double Clamp01(double value) Parameters Type Name Description double value The value to clamp. Returns Type Description double The clamped value. Clone<T>(T) Perform a deep Copy of the object. Note: This code was obtained from https://stackoverflow.com/questions/78536/deep-cloning-objects. Declaration public static T Clone<T>(T source) Parameters Type Name Description T source The object instance to copy. Returns Type Description T The copied object. Type Parameters Name Description T The type of object being copied. ComputeCentroid(List<GeoCoordinate>) Computes the centroid of a given polygon build of a list of coordinates. Declaration public static GeoCoordinate ComputeCentroid(List<GeoCoordinate> polygon) Parameters Type Name Description List<GeoCoordinate> polygon The list of the polygon coordinates. Returns Type Description GeoCoordinate The centroid of the polygon. CopyComponent(Component, Component) Copies a component and its values within this game object. Declaration public static Component CopyComponent(Component comp, Component target) Parameters Type Name Description Component comp The component to copy. Component target Returns Type Description Component The new copy of the component. DegreeToRadian(double) Converts degree to radian. Declaration public static double DegreeToRadian(double angle) Parameters Type Name Description double angle The angle as degree. Returns Type Description double The angle as radian. ForEachCoordinateOverlapAsync(int, Vector2Int, Action<bool, Vector2Int, Vector2Int>, bool, CancellationToken) Traverses all cells of a not further specified square grid (i.e. a two dimensional buffer) and calls a function that has the offset to a second square grid as a parameter. Declaration public static UniTask ForEachCoordinateOverlapAsync(int resolution, Vector2Int offset, Action<bool, Vector2Int, Vector2Int> function, bool processOverlapOnly = false, CancellationToken cancellationToken = default) Parameters Type Name Description int resolution The resolution of both square grids. Vector2Int offset The offset between two square grids. Action<bool, Vector2Int, Vector2Int> function The function to be called. The parameters are: A bool to state whether this cell overlaps. A vector to the cell position that is visited in the first grid. A vector to the overlapping cell position the second grid. bool processOverlapOnly Calls the function only for overlapping regions. CancellationToken cancellationToken The token to monitor for cancellation requests. Returns Type Description Cysharp.Threading.Tasks.UniTask ForEachEvenlyDistributedStep(double, double, Action<double>) A loop over evenly distributed steps along a given distance. Declaration public static void ForEachEvenlyDistributedStep(double maxStepSize, double totalDistance, Action<double> function) Parameters Type Name Description double maxStepSize The maximum step size. double totalDistance The total distance to cover. Action<double> function The function to call per step. GetSpiralLoopIndices(int) Creates spiral loop indices. Declaration public static List<int[]> GetSpiralLoopIndices(int radius) Parameters Type Name Description int radius The spiral radius >=0. Returns Type Description List<int[]> A list containing spiral loop indices. GreatestCommonDivisor(int, int) Computes the greatest common divisor. Declaration public static int GreatestCommonDivisor(int a, int b) Parameters Type Name Description int a The first value. int b The second value. Returns Type Description int The greatest common divisor of a and b. HaltonSequence(float, float) Calculates a value of the halton sequence based on an index and base value. Declaration public static float HaltonSequence(float index, float haltonBase) Parameters Type Name Description float index The index value. float haltonBase The base value. Returns Type Description float The resulting value of the halton sequence. InverseLerp(double, double, double) Inverse lerps between two double values. Declaration public static double InverseLerp(double a, double b, double v) Parameters Type Name Description double a First bound. double b Second bound. double v The in-between value. Returns Type Description double The ratio where v splits the interval between a and b. InverseLerp(Vector2, Vector2, Vector2) Inverse lerps between two Vector2 values. Declaration public static Vector2 InverseLerp(Vector2 a, Vector2 b, Vector2 v) Parameters Type Name Description Vector2 a First bound. Vector2 b Second bound. Vector2 v The in-between value. Returns Type Description Vector2 The ratio where v splits the interval between a and b. IsWithinArea(Vector2, Vector2, float, float) Determines whether a position is inside defined area. Declaration public static bool IsWithinArea(Vector2 position, Vector2 center, float extend, float margin = 0) Parameters Type Name Description Vector2 position The position to check. Vector2 center The center of the area. float extend The extend in x and y direction. float margin An optional margin. Returns Type Description bool Whether the position inside the given area. KilometersPerHourToMetersPerSecond(float) Converts km/h into m/s. Declaration public static float KilometersPerHourToMetersPerSecond(float kilometersPerHour) Parameters Type Name Description float kilometersPerHour The speed value in km/h. Returns Type Description float The speed value in m/s. KnutHash(int) Computes a knut-hash. Declaration public static int KnutHash(int value) Parameters Type Name Description int value The value to hash. Returns Type Description int The hashed value. KnutHash(long) Computes a knut-hash. Declaration public static long KnutHash(long value) Parameters Type Name Description long value The value to hash. Returns Type Description long The hashed value. KnutHash(Vector2Int) Computes a knut-hash from a Vector2Int. Declaration public static int KnutHash(Vector2Int value) Parameters Type Name Description Vector2Int value The value to hash. Returns Type Description int The hashed value. Lerp(double, double, double) Lerps between two double values. Declaration public static double Lerp(double a, double b, double t) Parameters Type Name Description double a First value. double b Second value. double t The percentage. Returns Type Description double The lerped value. MetersPerSecondToKilometersPerHour(float) Converts m/s into km/h. Declaration public static float MetersPerSecondToKilometersPerHour(float metersPerSecond) Parameters Type Name Description float metersPerSecond The speed value in m/s. Returns Type Description float The speed value in km/h. Mod(float, float) Computes the modulo similar to x % m except the added support for negative values. Declaration public static float Mod(float x, float m) Parameters Type Name Description float x The first operand. float m The second operand. Returns Type Description float The modulo result with support for negative values. NormalDistribution(double, double, double) Calculates a normal distribution, based on a mu-value and a sigma value. Declaration public static double NormalDistribution(double x, double mu = 0.5, double sigma = 0.5) Parameters Type Name Description double x double mu double sigma Returns Type Description double RadianToDegree(double) Converts radian to degree. Declaration public static double RadianToDegree(double angle) Parameters Type Name Description double angle The angle as radian. Returns Type Description double The angle as degree. ResetAnimator(Animator, string) Resets an animator and all of its parameters. Declaration public static void ResetAnimator(Animator animator, string resetTrigger) Parameters Type Name Description Animator animator The animator to reset. string resetTrigger The trigger to set. RoundUpToPowOfTwo(int) Rounds up a value to the next higher power of two. Declaration public static int RoundUpToPowOfTwo(int value) Parameters Type Name Description int value The value to round up. Returns Type Description int The rounded up value. RunOnThreadPool(Action, string, CancellationToken) Utility wrapper for Cysharp.Threading.Tasks.UniTask.RunOnThreadPool(System.Action,System.Boolean,System.Threading.CancellationToken) with Unity profiler support. Declaration public static UniTask RunOnThreadPool(Action action, string profilerSectionName = null, CancellationToken cancellationToken = default) Parameters Type Name Description Action action The action to run on the thread pool. string profilerSectionName An optional name for the action being performed, to allow identification in the profiler. CancellationToken cancellationToken The cancellation token to observe to cancel the operation on the thread pool. Returns Type Description Cysharp.Threading.Tasks.UniTask The task to await when waiting for the thread pool task to finish. Shuffle<T>(IList<T>, Random) Shuffles a list. Declaration public static void Shuffle<T>(IList<T> list, Random randomGenerator) Parameters Type Name Description IList<T> list The list to shuffle. Random randomGenerator The randomGenerator. Type Parameters Name Description T Truncate(double, float) Truncates a double value to a given number of digits. Declaration public static float Truncate(double value, float digits) Parameters Type Name Description double value The double value. float digits The number of digits. Returns Type Description float The truncated value. Vector2ToVector3xz(Vector2) Maps a vector 3D to the x and z coordinates of a vector 3D. Declaration public static Vector3 Vector2ToVector3xz(Vector2 vector) Parameters Type Name Description Vector2 vector The 3D vector to map. Returns Type Description Vector3 The mapped vector 3D. Vector3xzToVector2(Vector3) Maps the x and z coordinate to a vector 2D. Declaration public static Vector2 Vector3xzToVector2(Vector3 vector) Parameters Type Name Description Vector3 vector The 3D vector to map. Returns Type Description Vector2 The mapped vector 2D. WaitForThread(Action) Starts a thread and delays a coroutine until finished. Declaration public static IEnumerator WaitForThread(Action function) Parameters Type Name Description Action function The function to run in a thread. Returns Type Description IEnumerator"
  },
  "api/Holoride.ElasticSDK.Vector3Extensions.html": {
    "href": "api/Holoride.ElasticSDK.Vector3Extensions.html",
    "title": "Class Vector3Extensions | ElasticSDK Documentation",
    "keywords": "Class Vector3Extensions Various extension methods for the Vector3 type. Inheritance object Vector3Extensions Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax public static class Vector3Extensions Methods ToGlobalPosition(Vector3) Converts a single precision vector representing a position in shifted space into a global position with the exact same values, i.e. the conversion behaves as though the current shift were zero. Declaration public static GlobalPosition ToGlobalPosition(this Vector3 self) Parameters Type Name Description Vector3 self The single precision vector. Returns Type Description GlobalPosition The double precision vector."
  },
  "api/Holoride.ElasticSDK.VehicleLocalizationStatus.html": {
    "href": "api/Holoride.ElasticSDK.VehicleLocalizationStatus.html",
    "title": "Enum VehicleLocalizationStatus | ElasticSDK Documentation",
    "keywords": "Enum VehicleLocalizationStatus Different types of vehicle localization state. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [Serializable] public enum VehicleLocalizationStatus Fields Name Description Initializing Localization source is available but still initializing, no localization data is available yet. This usually does not have to be handled by regular content and can be treated as Unavailable. Limited Reduced quality of localization data, e.g. due to bad signal. Normal Regular localization localization data is available. Unavailable No vehicle localization is available at this time."
  },
  "api/Holoride.ElasticSDK.VehiclePosition.html": {
    "href": "api/Holoride.ElasticSDK.VehiclePosition.html",
    "title": "Class VehiclePosition | ElasticSDK Documentation",
    "keywords": "Class VehiclePosition Inheritance object Object Component Behaviour MonoBehaviour VehiclePosition Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public sealed class VehiclePosition : MonoBehaviour"
  },
  "api/Holoride.ElasticSDK.VehicleRotation.html": {
    "href": "api/Holoride.ElasticSDK.VehicleRotation.html",
    "title": "Class VehicleRotation | ElasticSDK Documentation",
    "keywords": "Class VehicleRotation Inheritance object Object Component Behaviour MonoBehaviour BaseRotation VehicleRotation Inherited Members BaseRotation.ShowDebugVisualization BaseRotation.ActiveRotationAxes BaseRotation.Awake() BaseRotation.OnEnable() BaseRotation.OnDisable() BaseRotation.Update() BaseRotation.Start() BaseRotation.OnDrawGizmos() Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax public class VehicleRotation : BaseRotation Methods UpdateEulerAngles() Declaration protected override Vector3 UpdateEulerAngles() Returns Type Description Vector3 Overrides BaseRotation.UpdateEulerAngles()"
  },
  "api/Holoride.ElasticSDK.VehicleSensorState.html": {
    "href": "api/Holoride.ElasticSDK.VehicleSensorState.html",
    "title": "Struct VehicleSensorState | ElasticSDK Documentation",
    "keywords": "Struct VehicleSensorState The data obtained by the vehicle sensors. Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [Serializable] public struct VehicleSensorState Fields GeoCoordinate Latitude in degrees. Declaration public GeoCoordinate GeoCoordinate Field Value Type Description GeoCoordinate LateralAcceleration_ms2 Lateral acceleration in the vehicle. Declaration public float LateralAcceleration_ms2 Field Value Type Description float LocalizationStatus The current LocalizationStatus. Declaration public VehicleLocalizationStatus LocalizationStatus Field Value Type Description VehicleLocalizationStatus LongitudinalAcceleration_ms2 Longitudinal acceleration in the vehicle. Declaration public float LongitudinalAcceleration_ms2 Field Value Type Description float VehicleHeading_Deg Heading amount provided by the GPS in degrees. Declaration public double VehicleHeading_Deg Field Value Type Description double VehiclePitch_Deg Vehicle pitch amount in degrees. Declaration public float VehiclePitch_Deg Field Value Type Description float VehicleRoll_Deg Vehicle roll amount in degrees. Declaration public float VehicleRoll_Deg Field Value Type Description float VehicleSpeed_Kmh Vehicle speed. Declaration public float VehicleSpeed_Kmh Field Value Type Description float VerticalAcceleration_ms2 Vertical acceleration in the vehicle. Declaration public float VerticalAcceleration_ms2 Field Value Type Description float YawRate_DegPerSec Vehicle yaw rate in degrees. Declaration public double YawRate_DegPerSec Field Value Type Description double Properties IsGeoCoordinateSet Gets a value indicating whether the GeoCoordinate has been set. Declaration public bool IsGeoCoordinateSet { get; } Property Value Type Description bool Methods Equals(VehicleSensorState) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(VehicleSensorState other) Parameters Type Name Description VehicleSensorState other An object to compare with this object. Returns Type Description bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Determines whether the specified object is equal to the current object. Declaration public override bool Equals(object obj) Parameters Type Name Description object obj The object to compare with the current object. Returns Type Description bool true if the specified object is equal to the current object; otherwise, false. Overrides ValueType.Equals(Object) GetHashCode() Serves as the default hash function. Declaration public override int GetHashCode() Returns Type Description int A hash code for the current object. Overrides ValueType.GetHashCode() ToString() Returns a string that represents the current object. Declaration public override string ToString() Returns Type Description string A string that represents the current object. Overrides ValueType.ToString()"
  },
  "api/Holoride.ElasticSDK.WorkerGroupAttribute.html": {
    "href": "api/Holoride.ElasticSDK.WorkerGroupAttribute.html",
    "title": "Class WorkerGroupAttribute | ElasticSDK Documentation",
    "keywords": "Class WorkerGroupAttribute Allows grouping workers into named groups. This is used to limit the maximum count of some particular node type in graphs, for example. Inheritance object Attribute WorkerGroupAttribute Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Library.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Class)] [BaseTypeRequired(typeof(IPipelineWorker))] public class WorkerGroupAttribute : Attribute Constructors WorkerGroupAttribute(string) Declaration public WorkerGroupAttribute(string groupName) Parameters Type Name Description string groupName Fields GroupName The name of the group. Declaration public readonly string GroupName Field Value Type Description string"
  },
  "api/Holoride.ElasticSDK.WorldShiftManager.html": {
    "href": "api/Holoride.ElasticSDK.WorldShiftManager.html",
    "title": "Class WorldShiftManager | ElasticSDK Documentation",
    "keywords": "Class WorldShiftManager This class moves all transforms generated by the ElasticSceneGenerator, under any listed Holoride.ElasticSDK.WorldShiftManager.ShiftParents as well as the game object itself towards the center of the coordinate system. This shift is mandatory to prevent floating point inaccuracies when moving along real world localization data that is mapped to engine units. Inheritance object Object Component Behaviour MonoBehaviour WorldShiftManager Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [DisallowMultipleComponent] [HelpURL(\"http://localhost:8080/api/Holoride.ElasticSDK.WorldShiftManager.html\")] public class WorldShiftManager : MonoBehaviour Fields OnOriginShift The event which is called when a shift has been performed. Declaration public WorldShiftManager.OriginShiftEvent OnOriginShift Field Value Type Description WorldShiftManager.OriginShiftEvent Methods AddPipelineContainer(IPipelineContainer) Registers a pipeline container with this shift manager. IShiftParent workers of pipelines of registered containers will be shifted. Declaration public void AddPipelineContainer(IPipelineContainer container) Parameters Type Name Description IPipelineContainer container The pipeline container to register. AddShiftParent(Transform) Adds a single shift parent. Child transforms of the registered transform will be shifted. Declaration public void AddShiftParent(Transform parent) Parameters Type Name Description Transform parent The parent transform to register. AddShiftParents(IEnumerable<Transform>) Adds a list of shift parents. Child transforms of the registered transforms will be shifted. Declaration public void AddShiftParents(IEnumerable<Transform> parents) Parameters Type Name Description IEnumerable<Transform> parents The list of parent transforms to register. RemovePipelineContainer(IPipelineContainer) Removes a pipeline container previously registered using AddPipelineContainer(IPipelineContainer). Declaration public void RemovePipelineContainer(IPipelineContainer container) Parameters Type Name Description IPipelineContainer container The pipeline container to unregister. RemoveShiftParent(Transform) Removes a single shift parent previously registered using AddShiftParents(IEnumerable<Transform>) or AddShiftParent(Transform). Declaration public void RemoveShiftParent(Transform parent) Parameters Type Name Description Transform parent The parent transform to unregister. RemoveShiftParents(IEnumerable<Transform>) Removes a list of shift parents previously registered using AddShiftParents(IEnumerable<Transform>) or AddShiftParent(Transform). If called without specified parameter, all shift parents are cleared. Declaration public void RemoveShiftParents(IEnumerable<Transform> parents = null) Parameters Type Name Description IEnumerable<Transform> parents The list of parent transforms to unregister."
  },
  "api/Holoride.ElasticSDK.WorldShiftManager.OriginShiftEvent.html": {
    "href": "api/Holoride.ElasticSDK.WorldShiftManager.OriginShiftEvent.html",
    "title": "Class WorldShiftManager.OriginShiftEvent | ElasticSDK Documentation",
    "keywords": "Class WorldShiftManager.OriginShiftEvent Implements a special case of a UnityEvent as a OriginShiftEvent. The first template argument is the shift vector all objects are moved along. Inheritance object UnityEventBase UnityEvent<Vector3> WorldShiftManager.OriginShiftEvent Namespace: Holoride.ElasticSDK Assembly: Holoride.ElasticSDK.Runtime.dll Syntax [Serializable] public class WorldShiftManager.OriginShiftEvent : UnityEvent<Vector3>"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "User Extensibility | ElasticSDK Documentation",
    "keywords": "User Extensibility Spawners, Maps and modules dedicated to online services like NavigationAPIs, TileDataServices, and TileDataServices are user-extensible. Every module comes with an API consisting of a superclass to inherit from or an interface for being implemented. These scripts seamlessly integrate into the holoride core pipeline. Therefore, the provided examples can be copied and modified according to your needs. Create Your Own Nodes When deriving from the different Elastic SDK node classes, the nodes can be instantiated right from the graph editor’s right-click menu. The SDK comes with numerous example nodes for learning how to use the API and getting inspired. You can find these example implementations in the Unity folder Packages/ElasticSDK/Runtime/Graph/Nodes."
  },
  "index.html": {
    "href": "index.html",
    "title": "Elastic SDK User Guide | ElasticSDK Documentation",
    "keywords": "Welcome Important For business inquiries, please contact content@holoride.com. If you are a returning developer, note that for new versions of the Elastic SDK, you will need a new holoride manifest. Please contact us at esdk-support@holoride.com in that case. Welcome to the Elastic SDK User Guide. Here you will find all the knowledge needed to create truly Elastic Content. We have prepared a variety of educational formats such as Learning Tracks, How-To Guides, and a Manual that cover a range of basic to advanced features of the ElasticSDK environment. For a coding quick start, take a look into our API Documentation. [əˈlæstɪk] At holoride, we’re building nothing less than the platform for the future of in-car entertainment—connecting mobility and media in a way that’s absolutely seamless. Our vehicle localization software syncs content with the vehicle’s motion, position, and map data in real time—creating an entirely new level of immersion. You start to feel what you see! At the same time, this real-time synchronization can actually reduce motion sickness, enabling more passengers to enjoy visual content in cars. We call this new content category for vehicles Elastic Content—the word “elastic” reflects the content’s adaptive behavior and nonlinear characteristics, which allow passengers to enjoy constantly changing experiences that adjust to their route. Spotlight - Learning Tracks Getting Started This Learning Track teaches you step by step how to add the Elastic SDK to your Unity project and how to build for the target hardware. Learn how to setup a minimal scene, about the Elastic Graph system and several test scenarios, including file playback of recorded vehicle sensor data. Get Started World Creation The Elastic SDK offers a powerful node graph system to gather map data as well as artificial and real world points of interest. Learn how to process them to distill important information about the vehicle's surroundings and define rules on how the virtual environment is generated at runtime. This Learning Track is a deep dive from node descriptions to terrain generation. Get Procedural Code (Preview) The Elastic SDK ships with a comprehensive API to support the developer with access to the holoride tech stack needed to create dedicated elastic experiences. Learn how to use and expand this API. Get Upgraded How-To Due to its procedural nature, Elastic Content creation requires knowledge of suited implementation strategies and workflows. Learn best practices from our focused blog-like instructions. Learn How To"
  },
  "learn/Code.html": {
    "href": "learn/Code.html",
    "title": "Code (Preview) | ElasticSDK Documentation",
    "keywords": "Code (Preview) The Code Learning Track focuses on logic and programmability. The goal of this track is to build a good understanding of the ElasticSDK API. Starting with existing hooks like events, that can be used to trigger custom logic, ideas and principles of runtime behavior is then established, that directly utilizes elastic data . Finally, ways to extend the existing API are discussed. Learning Modules This Learning Track consists of 3 modules. Each of the parts listed below will be covered in general detail and provide you with a solid understanding of how they work and relate to each other. Events & Callbacks module describes existing API that can be used to trigger custom logic. Graph Data Access module describes data access from the Elastic SDK node graph system in code. Custom Nodes module describes how to extend the feature set of the Elastic SDK node graph system with custom nodes. Start ❯"
  },
  "learn/Code/Custom-Nodes.html": {
    "href": "learn/Code/Custom-Nodes.html",
    "title": "Custom Nodes | ElasticSDK Documentation",
    "keywords": "Custom Nodes Advanced | 30 minutes Goal Learn how to extend the feature set of the Elastic SDK node graph system with custom nodes. Prerequisite Elastic SDK Getting Started Learning Track. Content Custom Map Nodes ❮ How-To: Graph Data Access Custom Map Nodes ❯"
  },
  "learn/Code/Custom-Nodes/Custom-Map-Nodes.html": {
    "href": "learn/Code/Custom-Nodes/Custom-Map-Nodes.html",
    "title": "Custom Map Nodes | ElasticSDK Documentation",
    "keywords": "❮ Custom Nodes Custom Map Nodes Although the Elastic SDK comes with a large number of Map nodes, you may find that you need one with custom behavior. All Map nodes have in common that their output is also a Map, i.e. a 2D array of float values whose resolution is defined in the Elastic Scene Generator. The following code is a minimal example that encodes the latitude of every pixel into the Map. We will focus on the different steps involved in creating a custom Map node over the course of this lesson. using System.Collections; using Holoride.ElasticSDK; using Holoride.ElasticSDK.Graph.Maps; using UnityEngine; public class MyMapNode : MapNode { public override IPipelineWorker GeneratePipelineWorker() { return new MyMapWorker(this); } private class MyMapWorker : MapWorker<MyMapNode> { public MyMapWorker(MyMapNode node) : base(node, provideDoubleBuffer: true, provideCPUBuffer: true, provideGPUBuffer: false) { } public override IEnumerator Process(GenerationContext context) { yield return Utils.WaitForThread(() => { int resolution = this.GenerationSettings.FilterResolution; for (int x = 0; x < resolution; x++) { for (int z = 0; z < resolution; z++) { var uv = new Vector2((float)x / resolution, (float)z / resolution); var geoCoordinate = context.Bounds.GeoCoordinateAtUV(uv, context.Pivot); this.SetCPUWriteBufferValue(x, z, (float)geoCoordinate.Latitude); } } }); } } } Create a file containing the script as MyMapNode.cs within your Asset folder or rename all occurrences of the prefix MyMap according to your purpose. Now the node can be selected from the node creation menu in the holoride graph view. Let us take a deeper look into what we just created: public class MyMapNode : MapNode { public override IPipelineWorker GeneratePipelineWorker() { return new MyMapWorker(this); } private class MyMapWorker : MapWorker<MyMapNode> { //... } } A node class generates a Worker object of the embedded Worker class. Internally, depending on the situation, multiple Workers generated from one node might exist at a time. One might be generated for an Elastic Scene Generator and another one for the node graph editor to show a preview. All nodes that have been created for the same consumer are arranged into a pipeline, the logical order in which the nodes are processed. public MyMapWorker(MyMapNode node) : base(node, provideDoubleBuffer: true, provideCPUBuffer: true, provideGPUBuffer: false) { } The constructor of our Worker takes four arguments: A reference to the node to access parameters set in the node graph. A bool that states whether to use a double buffer to ensure values can be read even if the Worker is currently processing an update. A bool that indicates that the node fills a CPU buffer. A bool that indicates that the node fills a GPU buffer additionally or alternatively. Note The GPU buffer represents a compute buffer a compute shader draws into, while the CPU buffer is an array in the memory. It depends on your algorithm which implementation is more efficient. Only in rare cases, e.g. when drawing sparse data like individual pixels, a CPU implementation is the better choice. However, a GPU implementation requires some boilerplate code. For the sake of ease we will fill a CPU buffer in the following example. public override IEnumerator Process(GenerationContext context) { yield return Utils.WaitForThread(() => { //... }); } The process function is the heart of a node that updates with every pipeline iteration. It is called in a coroutine and can yield to distribute the workload over multiple frames. In this example we even outsource the computation to another thread. Keep in mind though, that most Unity operations cannot be called within a separate thread. int resolution = this.GenerationSettings.FilterResolution; for (int x = 0; x < resolution; x++) { for (int z = 0; z < resolution; z++) { ///... } } Inside our function we iterate over every pixel of the output Map. The pixel count in both dimensions (in Unity's x and z direction) is determined in the GenerationSettings class. These settings are shared by all nodes in a pipeline and won't change over time. Additionally, in this case the original value for the Filter Resolution setting is set on the Elastic Scene Generator component. var uv = new Vector2((float)x / resolution, (float)z / resolution); var geoCoordinate = context.InnerBounds.GeoCoordinateAtUV(uv, context.Pivot); this.SetCPUWriteBufferValue(x, z, (float)geoCoordinate.Latitude); The very core of the process function describes what happens to every pixel. In this case, we compute the UV coordinates of the area the Map covers. Then, we use our GenerationContext object context to determine the geo coordinate on the earth surface which corresponds to the Map coordinate at hand. In general, the GenerationContext class holds all information that changes between pipeline iterations, such as the generation bounds which contain the range in latitude and longitude direction. Finally, we use the latitude information of the geo coordinate and write it to the respective CPU buffer position. Moving On Congratulations, you have completed the Code learning track! If you have not yet completed preceding learning tracks, consider to do so now to get deeper insights into the ElasticSDK environment and its features: Getting Started Learn about the setup process and the key components of the Elastic SDK. World Creation Learn how to create elastic environments utilizing key graph features. ❮ Custom Nodes"
  },
  "learn/Code/Custom-Nodes/Custom-Spawner-Nodes.html": {
    "href": "learn/Code/Custom-Nodes/Custom-Spawner-Nodes.html",
    "title": "Custom Spawner Nodes | ElasticSDK Documentation",
    "keywords": "Custom Spawner Nodes"
  },
  "learn/Code/Events-And-Callbacks.html": {
    "href": "learn/Code/Events-And-Callbacks.html",
    "title": "Events & Callbacks | ElasticSDK Documentation",
    "keywords": "Events & Callbacks Advanced | 10 minutes Goal Learn how to utilize existing API in the form of events, to trigger custom logic based on essential states of the Elastic SDK environment. Prerequisite Elastic SDK Getting Started Learning Track. Content Scene Generation Events Localization Events & Sensor Data ❮ Code Scene Generation Events ❯"
  },
  "learn/Code/Events-And-Callbacks/Localization-Events-And-Sensor-Data.html": {
    "href": "learn/Code/Events-And-Callbacks/Localization-Events-And-Sensor-Data.html",
    "title": "Localization Events & Sensor Data | ElasticSDK Documentation",
    "keywords": "❮ Scene Generation Events Graph Data Access ❯ Localization Events & Sensor Data In the ElasticSDK environment, the Player is moving through the virtual world, based on real-world localization data. It is important to understand how this data is reflected in the virtual world to create content that offers an acceptable user experience, even in suboptimal data quality scenarios. Localization Events Localization Events are a subcategory of the overarching Quality Events theme. Localization Events are located on a component with the same name in the Holoride Player prefab. These events are meant to be hooks where your program flow can execute different behavior based on the different states of the real-world localization data. Setting Description DistanceToStreetUntilOffRoad The distance in meters from the street until the player is considered to be too far away from the road and the OnOffRoadMode event is triggered. FireModeEventOnStart When enabled this component will fire the localization mode event for the current state when Unity's Start method is called on this component. Event Description OnLocalizationInitialized The event which is invoked when the localization becomes available and the pivot is set. OnLocalizationNormalMode The event which is invoked when the localization is available and we are on the street (up to the road distance threshold). OnOffRoadMode This event which is invoked when the localization is available but we are not on the road and the distance to the road is larger than the threshold configured in DistanceToStreetUntilOffRoad. OnLocalizationUnavailableMode This event which is invoked when the localization is unavailable and thus the player won't move even though the vehicle in the real world might. OnErrorOccured This event which is invoked when any localization error occurs. This component handles different localization quality events and reduces them to three distinct states: Normal: This state represents good localization where everything works as expected. Off-road: This state is active when the localization is available but due to inaccuracies in localization or outdated Map data, the Player might not be on the road which the content should handle accordingly. The distance to the road until the player is considered to be \"off-road\" is adjustable and should reflect the requirements of the individual content. Unavailable: This state means that no localization information is available. Provisions should be made for the content of an experience to respond to different localization states: Since the Unavailable state does not show any movement at all, even though the vehicle may in fact be moving, it is suggested not to show any indication of false movement that occurs when the Player's localization is not present but the VR headset's IMU interprets a turning car as a head rotation. In many scenarios, this means that it is not even recommended to show the player a world . The experience should start in this mode until localization is available and Map data is ready. Caution Any experience must be designed to reflect this state at any point in time to comfort the user in those situations where valid data is not available to present an elastic environment. One suggestion is to fade out the world when this mode is activated and fade it in once another state becomes active. The other interesting state is the Off-road state where there appears to be normal localization but due to limited GPS reception (e.g. in a tunnel) the Player might be off the road. In this case the experience should make sure that the player is not colliding with any objects. How this is handled depends very much on the experience that is built and could range from unloading objects that are too close to loading a different scene. The Distance To Street Until Off Road setting for this mode makes it possible to tighten or loosen the constraints for this mode, depending on the individual content. Sensor Data The sensor data itself is transmitted from our service to the ElasticSDK at runtime. A editor-only serialized version of the structured service values can be found on the Player component. To obtain the structured service values programmatically, the StateReceiver API can be used. The static VehicleSensorState member contains the same data that is serialized in the Player editor. Additionally a custom IStateReceiverLocalizationEventListener can be registered to be notified whenever new sensor data arrives from the service. The vehicle sensor state data is structured as follows: Data Type Description GeoCoordinate GeoCoordinate Latitude, longitude and altitude of the vehicle. VehicleSpeed_Kmh float Vehicle speed. VehicleHeading_Deg double Heading amount provided by the GPS in degrees. YawRate_DegPerSec double Vehicle yaw rate in degrees/s. LateralAcceleration_ms2 float Lateral acceleration of the vehicle in m/s^2 LongitudinalAcceleration_ms2 float Longitudinal acceleration in the vehicle in m/s^2 VehiclePitch_Deg float Vehicle pitch amount in degrees. VehicleRoll_Deg float Vehicle roll amount in degrees. LocalizationStatus VehicleLocalizationStatus The current LocalizationStatus. ❮ Scene Generation Events Graph Data Access ❯"
  },
  "learn/Code/Events-And-Callbacks/Route-Based-Events.html": {
    "href": "learn/Code/Events-And-Callbacks/Route-Based-Events.html",
    "title": "Route Based Events | ElasticSDK Documentation",
    "keywords": "Route Based Events"
  },
  "learn/Code/Events-And-Callbacks/Scene-Generation-Events.html": {
    "href": "learn/Code/Events-And-Callbacks/Scene-Generation-Events.html",
    "title": "Scene Generation Events | ElasticSDK Documentation",
    "keywords": "❮ Events & Callbacks Localization Events & Sensor Data ❯ Scene Generation Events Scene Generation Events are a subcategory of the overarching Quality Events theme. The Elastic SDK is a whole suite of software that has to process various tasks like service communication and procedural generation. The later includes graph data processing, which ultimately results in terrain being generated and objects being spawned, based on user-defined node graphs. While this whole processing step is done by a single pipeline (per Elastic Scene Generator), the various tasks that have to be completed are not only distributed across multiple frames but some also across different threads or even different hardware pieces. Each graph node queries a worker in the pipeline that has to complete its work before the pipeline can finish. Some of them run on the CPU, others utilize compute shaders to run on the GPU. To abstract and simplify this complexity, the Elastic Scene Generator component drives each pipeline run, including certain pre- and post-processing steps, and exposes multiple generation events that map certain states of an individual generation iteration. Event Overview The Elastic Scene Generator component has dedicated Events and Fallback Events sections, that provide the user with a variety of UnityEvents. These events are meant to be hooks where your program flow can execute different behavior based on the different states of the generation process. Event Description OnGenerationStarted The event which is invoked when the initial generation process has started. OnGenerationFinished The event which is invoked when the initial generation process is finished. OnUpdateStarted The event which is invoked every time a generation process has started, except the first time. OnUpdateFinished The event which is invoked every time a generation process has finished, except the first time. Generation/Update Started The OnGenerationStarted event is invoked when the initial generation process of the Elastic Scene Generator has started. This means it is only invoked when the pipeline was not running already. In contrast to that, the OnUpdateStarted event is invoked only when the generator has finished its initial generation iteration and subsequent iterations have started. Tip In development builds these events are wrapped in a dedicated Unity Profiler marker: OnUpdateStarted/OnGenerationStarted Generation/Update Finished The OnGenerationFinished event is invoked when the initial generation process of the Elastic Scene Generator has finished. This means it is only invoked when the pipeline was not running already. In contrast to that, the OnUpdateFinished event is invoked only when the generator has finished its initial generation iteration already and subsequent iterations have finished after. Tip In development builds these events are wrapped in a dedicated Unity Profiler marker: OnUpdateFinished/OnGenerationFinished Important In case the generator is stopped and started programmatically via StopGenerator and StartGenerator, the generation started state is reset, which means the OnGenerationStarted and OnGenerationFinished events will be invoked again. Fallback Event Overview Fallback events are a special treat in that they are only called if something goes wrong in the generation process. Since the Elastic SDK works in complex scenarios, i.e. a player moving in a real world vehicle that is projected in a procedurally generated, virtual world, this can have a multitude of reasons. And often more than one at the same time. Currently, the Elastic Scene Generator provides two fallback events that boil down all the different reasons for poor generation into a single overdue state. Fallback Event Description OnEnterGenerationOverdue The event which is invoked when the GenerationOrigin, i.e. the Player, got too close to the latest finished generation context's InnerBounds, based on the given BoundsDistanceThreshold. OnLeaveGenerationOverdue The event which is invoked when the current generation left the overdue state. Enter Generation Overdue The OnEnterGenerationOverdue event is invoked whenever the Player approaches the bounds of the latest finished generation. It can be used to identify and compensate poor content states before they actually happen. There are several reasons why a generation cannot finish in time and it is likely that there is more than one reason. For example, a poor internet connection can cause excessive download times for areas where no cached map data exists in the user's application. This would ultimately stall the generation and the Player would approach the bounds because they cannot be updated. Same could happen when the graph is too complex overall, the vehicle drives very fast or the extents of the Elastic Scene Generator are too small. Important In general it is recommended that there is always a fallback solution, e.g. a separate, graph independent scene transition, hooked up to this event. The BoundsDistanceThreshold is a user-defined value on the Elastic Scene Generator, that can be used to adjust the distance towards the bounds from where the Player will cause the event invokation. Leave Generation Overdue As complementary event, OnLeaveGenerationOverdue is invoked when the current generation has finished in time and thus has left the overdue state. Here, \"in time\" means that any current generation must have finished before the Player gets too close to the InnerBounds of its generation context again. ❮ Events & Callbacks Localization Events & Sensor Data ❯"
  },
  "learn/Code/Graph-Data-Access.html": {
    "href": "learn/Code/Graph-Data-Access.html",
    "title": "Graph Data Access | ElasticSDK Documentation",
    "keywords": "Graph Data Access Advanced | 1 hour | Programmers Goal Learn how to access data from the Elastic SDK node graph system in code. Prerequisite Elastic SDK Getting Started Learning Track. Content Graph Data Access ❮ Events & Callbacks How-To: Graph Data Access ❯"
  },
  "learn/Code/Graph-Data-Access/Global-Graph-Output.html": {
    "href": "learn/Code/Graph-Data-Access/Global-Graph-Output.html",
    "title": "Global Graph Output | ElasticSDK Documentation",
    "keywords": "Global Graph Output"
  },
  "learn/Code/Graph-Data-Access/How-To-Graph-Data-Access.html": {
    "href": "learn/Code/Graph-Data-Access/How-To-Graph-Data-Access.html",
    "title": "How-To: Access Graph Data | ElasticSDK Documentation",
    "keywords": "❮ Graph Data Access Custom Nodes ❯ How-To: Access Graph Data Advanced | 1 hour | Programmers Introduction Goal In this tutorial we learn how we can access node data in scripts from outside the elastic node graph. Prerequisite Using the access systems: Familiarity with the node graph Familiarity with Spawner nodes Familiarity with UniTask Proficiency in C# scripts Extending the access systems: Knowledge of the Worker system Learning Path Spawning objects with graph data Accessing graph data globally Writing custom mappers to access data Summary Content We start by passing data from graphs to spawned prefabs. Afterwards, we learn how we can make data accessible globally. In the end we take a deep dive into how the process of returning data from a node works. Note The graph data API of the Elastic SDK uses the UniTask framework to efficiently access available pipeline data. It is important to be familiar with this framework in order to fully understand the code flow and its implications. Spawning objects with graph data We start by creating a new C# script and attach it to a prefab in a spawner. The next step is to let the node graph know that we would like to fill one of our variables with data from the graph. For this we create a public variable and add the InjectGraphData attribute. The only missing piece is now the type of the variable. This is the most interesting part, because it describes both the node type that we want to access and the type that it returns. The ElasticSDK currently contains mappings for three output types, but we will later see how we can implement our own mappings and returned types. These output types are: FloatValueFromMapProvider.FloatValue Requiring a Map node and returning the value of the map at the spawned position IReadOnlyList<float> Requiring a Map node and returning all float values in the map IReadOnlyList<GlobalPose> Requiring a PoseSet node and returning all poses in the connected node With this knowledge we have everything to build our example: [InjectGraphData] public FloatValueFromMapProvider.FloatValue ParkMask; If we take a look into the graph, after adding this change, we can see the following: This shows that by simply using this variable type the ElasticSDK knows that we want to access a Map node and creates a port for us where we can plug in a Map node. What actually happens under the hood is that there are different mappers for the types outlined above. These mappers use the node that they require as an input and access the worker of the node for data to return the data. One specialty of the workers is that their access queries always contain the position of the prefab to be spawned. The mapper implementation that we used above, which returns a float, uses this position to query the map at this exact spot for a value. The other two return types simply ignore this position and return the full data available. In case we don't only need to have data ready in our spawned objects but query the world in general we can achieve this with the next approach. Accessing graph data globally A different approach to accessing graph data is to use the global graph output of the Elastic Scene Definition node. Here we can simply add and name new input ports to the node as shown above. With the two nodes connected we can then create a new script and access the node data from there. using System.Threading; using Cysharp.Threading.Tasks; using Holoride.ElasticSDK; using Holoride.ElasticSDK.Graph; using UnityEngine; public class MyMapDependingDynamicScaleScript : MonoBehaviour { private CancellationTokenSource CancellationTokenSource; [SerializeField] private ElasticSceneGenerator ESG; [SerializeField] private string GlobalGraphOutput; private void OnEnable() { CancellationTokenSource = new CancellationTokenSource(); ProcessGraphOutput().Forget(); } private async UniTaskVoid ProcessGraphOutput() { while (!this.CancellationTokenSource.IsCancellationRequested) { var position = GlobalPosition.FromShifted(transform.position); var output = await ESG.TryGetGlobalOutput<FloatValueFromMapProvider.FloatValue>(GlobalGraphOutput, position, CancellationTokenSource.Token); if (output.success) { transform.localScale = Vector3.one * output.result; } await UniTask.NextFrame(CancellationTokenSource.Token); } } private void OnDisable() { this.CancellationTokenSource?.Cancel(); this.CancellationTokenSource?.Dispose(); } } In the script, we first need to get a reference to the Elastic Scene Generator that uses this elastic scene definition. Now, we can query the current connected nodes using the TryGetGlobalOutput method on the Elastic Scene Generator and the entered name of the port as the first parameter. In our example above this could be either MapOutput or PosesOutput. An overload that takes in a second parameter allows us to pass the position where we want to query the node. While we might be interested in all of the poses that are currently available for the Map based nodes it is usually useful to sample a certain position. The GlobalPosition argument that the method requires, can be easily created using the GlobalPosition.FromShifted(Vector3) method. Lastly, we need to specify the generic type parameter. The possible types in this case, similar to the spawner example above, are the following: FloatValueFromMapProvider.FloatValue IReadOnlyList<float> IReadOnlyList<GlobalPose> It is important to note that not all generic types allow querying a specific position. While options 2 and 3 always return the full map or pose data connected, no matter if a position was passed to the mapper or not, option 1 is different. Since we can only return a single float value when using FloatValueFromMapProvider.FloatValue there is a way in which we need to decide which float needs to be picked from the map. When passing a position we can use this to sample the map at this exact location but when no position is passed we default to returning the first entry in the map. In case this behavior is not what we want we can create our own mapping behavior, which is what we will do in the next section. Writing custom mappers to access data We will now take a look under the hood on how we can create new mappings. This is done by IWorkerMapper interface. The generic type parameter T defines the type of the returned value of this mapper. As we have seen in the previous two chapters, we use this type when querying the Elastic Scene Generator or defining a variable in a script of a spawned prefabs. After deciding on a return type, we have to set the SourceNodeType property of the interface to the node we want to work with. The final step is to implement the mapping behavior between the node and the returned value type. With this overview over the interface we can use it in an example: For this example, our goal is to return the closest Pose of a Pose Set node. We create a class called ClosestPoseMapper and implement the IWorkerMapper<GlobalPose> interface. We chose GlobalPose since we want to return a Pose from the Pose Set. Small note here: It might make sense to not use existing types as the return type, but we will have a short discussion at the end of this chapter on this topic. public class ClosestPoseMapper : IWorkerMapper<GlobalPose> { public Type SourceNodeType { get; } = typeof(PoseSetNode); // [...] Omitted Map methods } In the snippet above, we can see the interesting property SourceNodeType that defines the type of the node this mapper requires. Next, we will see how we can access the data from the worker of the required node and use it to generate the desired output. async UniTask<object> IWorkerMapper.Map(IPipelineWorker worker, GlobalPosition position, CancellationToken cancellationToken) { return await Map(worker, position, cancellationToken); } async UniTask<object> IWorkerMapper.Map(IPipelineWorker worker, CancellationToken cancellationToken) { return await Map(worker, cancellationToken); } public UniTask<GlobalPose> Map(IPipelineWorker worker, GlobalPosition position, CancellationToken cancellationToken = default) { // TODO Implement } public UniTask<GlobalPose> Map(IPipelineWorker worker, CancellationToken cancellationToken = default) { // TODO Implement } The interface includes four map methods that can be split into two main groups. While generally the upper two methods would be sufficient, the lower two map methods are simply type safe variants of the same method. This is why we simply forward the calls of the non type safe variants to the type safe methods. public UniTask<GlobalPose> Map(IPipelineWorker worker, CancellationToken cancellationToken = default) { var poseSetWorker = (PoseSetWorker) worker; var poses = UniTask.FromResult(poseSetWorker.ReadPoses); // we don't have a position to compare against return poses[0]; } public UniTask<GlobalPose> Map(IPipelineWorker worker, GlobalPosition position, CancellationToken cancellationToken = default) { var poseSetWorker = (PoseSetWorker) worker; var poses = poseSetWorker.ReadPoses; // order the poses and return the smallest return UniTask.FromResult(poses.OrderBy(pose => (position - pose.Position).SquaredLength).First()); } Since we know that we will access the worker of a PoseSetNode, we can cast the incoming pipeline worker to a PoseSetWorker. We have now access to the ReadPoses property of the worker that stores a readonly list of GlobalPoses. The final step is to return a single pose from the list. Since the Map(IPipelineWorker) method doesn't pass a position we have to a agree on a selection method. For simplicity we can decide on simply returning the first Pose in the list. The second Map method is more interesting to us, because we sort the Poses and return the Pose that is closest to the passed position. The example above is technically complete, but we should consider that we might want to implement other mappers that return a GlobalPose. This would make it impossible for the system that needs to decide which mapper should be used since we decide this based on the returned variable. To sidestep this issue and make it more obvious which mapper is used we can simply create a wrapper class for our returned type. If we make this wrapper class a nested class inside the mapper, then we always see what mapper is used. We have already seen an example for this pattern: FloatValueFromMapProvider.FloatValue public class FloatValueFromMapProvider : IWorkerMapper<FloatValueFromMapProvider.FloatValue> { // Omitted methods and fields public struct FloatValue { public float Value; public static implicit operator float(FloatValue val) => val.Value; public static implicit operator FloatValue(float value) => new FloatValue { Value = value }; public override string ToString() => this.Value.ToString(CultureInfo.InvariantCulture); } } As we can see this is a wrapper around a float. To make it more convenient we implement the operator float and operator FloatValue to be able to convert to and from a float. Summary We have learned in this guide how we can use data from the graph inside C# scripts, either by letting the spawners inject data or by querying the Elastic Scene Definition node. For more advanced use cases this tutorial also covered, how we can build our own mapper, allowing us to access the data of the node in a different way. The example above can be a little inspiration on what we can now do with this. If we want to know, whether the spawned prefab is inside a park, we can simply pass this information and alter our gameplay with this piece of information. ❮ Graph Data Access Custom Nodes ❯"
  },
  "learn/Code/Graph-Data-Access/Prefab-Component-Injection.html": {
    "href": "learn/Code/Graph-Data-Access/Prefab-Component-Injection.html",
    "title": "Prefab Component Injection | ElasticSDK Documentation",
    "keywords": "Prefab Component Injection"
  },
  "learn/Code/Runtime-Behavior.html": {
    "href": "learn/Code/Runtime-Behavior.html",
    "title": "Runtime Behavior | ElasticSDK Documentation",
    "keywords": "Runtime Behavior"
  },
  "learn/Code/Runtime-Behavior/Objects-React-To-Map.html": {
    "href": "learn/Code/Runtime-Behavior/Objects-React-To-Map.html",
    "title": "Objects React To Map | ElasticSDK Documentation",
    "keywords": "Objects React To Map"
  },
  "learn/Code/Runtime-Behavior/Objects-React-To-Vehicle.html": {
    "href": "learn/Code/Runtime-Behavior/Objects-React-To-Vehicle.html",
    "title": "Object React To Vehicle | ElasticSDK Documentation",
    "keywords": "Object React To Vehicle"
  },
  "learn/Getting-Started.html": {
    "href": "learn/Getting-Started.html",
    "title": "Getting Started | ElasticSDK Documentation",
    "keywords": "Getting Started The Getting Started Learning Track provides you with a holistic overview of the key components of the Elastic SDK environments. Starting with the basic setup of the Elastic SDK and its dependencies, a minimalistic Unity scene is created which will then act as a foundation to utilize basic principles of the Elastic Graph. The last part of this Learning Track will explain the different test environments that the Elastic SDK and the holoride tech stack supports. Learning Modules This Learning Track consists of 3 modules. Each of the parts listed below will be covered in general detail and provide you with a solid understanding of how they work and relate to each other. Minimal Scene Setup module describes the initial setup of the Elastic SDK and the key components of an elastic scene. The Elastic Graph module gives a holistic overview of the graph system and its node types. Test Environment module outlines the currently supported test environments and how to use them. Start ❯"
  },
  "learn/Getting-Started/Minimal-Scene-Setup.html": {
    "href": "learn/Getting-Started/Minimal-Scene-Setup.html",
    "title": "Minimal Scene Setup | ElasticSDK Documentation",
    "keywords": "Minimal Scene Setup Beginner | 30 minutes Goal Learn how to setup the Elastic SDK and how to use it in the Unity environment. Prerequisite Basic Unity knowledge. Content Elastic SDK Setup Creating a Simple Scene The holoride Player The Elastic Scene Generator ❮ Getting Started Elastic SDK Setup ❯"
  },
  "learn/Getting-Started/Minimal-Scene-Setup/Creating-a-Simple-Scene_Content.html": {
    "href": "learn/Getting-Started/Minimal-Scene-Setup/Creating-a-Simple-Scene_Content.html",
    "title": "Creating a Simple Scene | ElasticSDK Documentation",
    "keywords": "Creating a Simple Scene Create a new scene and name it as you wish Add a holoride Player game object by right clicking in the hierarchy and navigating to holoride > Player Place the Main Camera into the LocalRotation object within the Holoride Player and zero out the camera transforms except for the scale. If the sample scene comes with a Simple Camera Controller component attached to the camera, remove it. Add an Elastic Scene Generator game object by right clicking in the scene hierarchy and selecting holoride > Elastic Scene Generator Create a Elastic Graph asset in the assets folder where you like by right clicking in the assets folder and selecting Create > holoride > Elastic Graph Right click on the graph and rename it as you like Double click the Elastic Graph asset just created to open the Elastic Graph window Within the Elastic Graph window, press the spacebar or right-click and add the following nodes and connect them in the order shown with the same parameters Select the Elastic Scene Generator and fill in the Scene Definition reference by expanding the Elastic Graph asset and dragging the Elastic Scene Definition into the Scene Definition field Enter play mode to see a simple terrain in the game view"
  },
  "learn/Getting-Started/Minimal-Scene-Setup/Creating-a-Simple-Scene.html": {
    "href": "learn/Getting-Started/Minimal-Scene-Setup/Creating-a-Simple-Scene.html",
    "title": "Creating a Simple Scene | ElasticSDK Documentation",
    "keywords": "❮ Elastic SDK Setup The holoride Player ❯ Creating a Simple Scene Create a new scene and name it as you wish Add a holoride Player game object by right clicking in the hierarchy and navigating to holoride > Player Place the Main Camera into the LocalRotation object within the Holoride Player and zero out the camera transforms except for the scale. If the sample scene comes with a Simple Camera Controller component attached to the camera, remove it. Add an Elastic Scene Generator game object by right clicking in the scene hierarchy and selecting holoride > Elastic Scene Generator Create a Elastic Graph asset in the assets folder where you like by right clicking in the assets folder and selecting Create > holoride > Elastic Graph Right click on the graph and rename it as you like Double click the Elastic Graph asset just created to open the Elastic Graph window Within the Elastic Graph window, press the spacebar or right-click and add the following nodes and connect them in the order shown with the same parameters Select the Elastic Scene Generator and fill in the Scene Definition reference by expanding the Elastic Graph asset and dragging the Elastic Scene Definition into the Scene Definition field Enter play mode to see a simple terrain in the game view ❮ Elastic SDK Setup The holoride Player ❯"
  },
  "learn/Getting-Started/Minimal-Scene-Setup/Elastic-SDK-Setup_Content.html": {
    "href": "learn/Getting-Started/Minimal-Scene-Setup/Elastic-SDK-Setup_Content.html",
    "title": "Elastic SDK Setup | ElasticSDK Documentation",
    "keywords": "Elastic SDK Setup System Requirements Tested Unity versions: 6000.0.25f1 Stable internet connection Get the Elastic SDK To download the Elastic SDK, you have to use Unity’s built-in package manager (UPM). You will need to add our registry for this, as described below. As a quick start you can skip these steps by using our Unity Template Project on GitHub. Step 1 Add the necessary registries as a scoped registry in the Unity Package Manager. To do this, open Unity and navigate to Project Settings > Package Manager and add the following scoped registry: Label Entry Name holoride URL https://npm.pkg.holoride.com/ Scope(s) com.holoride Add a new line with 'plus' button to insert the scopes separately Be sure there is no white spaces at the end of any of the fields Since we have a dependency to xNode and Unitask we also need to add these dependencies. We can do this via OpenUPM which is another scoped registry: Label Entry Name OpenUPM URL https://package.openupm.com Scope(s) com.github.siccity.xnode com.cysharp.unitask Step 2 Now you can install the Elastic SDK from the Package Manager window. Choose Packages: My Registries in the top bar. The Elastic SDK can now be selected in the list and be installed by clicking the button on the bottom. Enable your Unity project To enable your Unity Project to be used with the Elastic SDK, you need to link a holoride manifest file (HMF) specifically created for your project. Please contact us at esdk-support@holoride.com to get in touch. Validate Your Project After successfully importing the ElasticSDK package with all its dependencies, see the holoride Project Validation window to set up your project and fix all points on the list that show an exclamation mark (Check the Inspector when clicking Select). You can also find it the main menu under holoride > Project Validation, if you accidentally closed it. You can update the Elastic SDK from the Unity Package Manager window whenever a new version is available."
  },
  "learn/Getting-Started/Minimal-Scene-Setup/Elastic-SDK-Setup.html": {
    "href": "learn/Getting-Started/Minimal-Scene-Setup/Elastic-SDK-Setup.html",
    "title": "Elastic SDK Setup | ElasticSDK Documentation",
    "keywords": "❮ Minimal Scene Setup Creating a Simple Scene ❯ Elastic SDK Setup System Requirements Tested Unity versions: 6000.0.25f1 Stable internet connection Get the Elastic SDK To download the Elastic SDK, you have to use Unity’s built-in package manager (UPM). You will need to add our registry for this, as described below. As a quick start you can skip these steps by using our Unity Template Project on GitHub. Step 1 Add the necessary registries as a scoped registry in the Unity Package Manager. To do this, open Unity and navigate to Project Settings > Package Manager and add the following scoped registry: Label Entry Name holoride URL https://npm.pkg.holoride.com/ Scope(s) com.holoride Add a new line with 'plus' button to insert the scopes separately Be sure there is no white spaces at the end of any of the fields Since we have a dependency to xNode and Unitask we also need to add these dependencies. We can do this via OpenUPM which is another scoped registry: Label Entry Name OpenUPM URL https://package.openupm.com Scope(s) com.github.siccity.xnode com.cysharp.unitask Step 2 Now you can install the Elastic SDK from the Package Manager window. Choose Packages: My Registries in the top bar. The Elastic SDK can now be selected in the list and be installed by clicking the button on the bottom. Enable your Unity project To enable your Unity Project to be used with the Elastic SDK, you need to link a holoride manifest file (HMF) specifically created for your project. Please contact us at esdk-support@holoride.com to get in touch. Validate Your Project After successfully importing the ElasticSDK package with all its dependencies, see the holoride Project Validation window to set up your project and fix all points on the list that show an exclamation mark (Check the Inspector when clicking Select). You can also find it the main menu under holoride > Project Validation, if you accidentally closed it. You can update the Elastic SDK from the Unity Package Manager window whenever a new version is available. ❮ Minimal Scene Setup Creating a Simple Scene ❯"
  },
  "learn/Getting-Started/Minimal-Scene-Setup/The-Elastic-Scene-Generator.html": {
    "href": "learn/Getting-Started/Minimal-Scene-Setup/The-Elastic-Scene-Generator.html",
    "title": "The Elastic Scene Generator | ElasticSDK Documentation",
    "keywords": "❮ The holoride Player The Elastic Graph ❯ The Elastic Scene Generator Besides the holoride Player the Elastic Scene Generator is one of the two key components enabling a full elastic experience. For easy integration, the Elastic SDK provides a Elastic Scene Generator Prefab for Unity. The Elastic Scene Generator visualizes map data and node information from the Elastic Graph. By referencing a Scene Definition from an Elastic Graph as well as a Terrain Material on the generator's component, the user enables it to procedurally generate a terrain and spawn objects based on the Scene Definition's output data. The generated terrain is based on Unity's terrain implementaion. Tip You can create a Elastic Scene Generator game object in Unity's scene hierarchy from the righ-click context menu Create > holoride > Elastic Scene Generator. Dependencies Shared Pivot - this is the origin of the world over time. In this case, it is the Player Prefab. Parent - this is the object which spawned content will be childed to. We use the Elastic Scene Generator game object. Generation Origin - this is the center point from which content is spawned. We use the Player Prefab again. Scene Definition - this is filled with the output node on the Elastic Graph. It is dragged from the Project window into this reference. Terrain Material - if there is a terrain being generated, this is the material which is used. Generation Behavior - these booleans allow terrains to be generated automatically or not. The default is true for both options. Terrain Dimensions - this is the size of the generated terrain and its extents. The default terrain/spawning height is -3. This creates a little visual buffer from 0,0,0. Quality and Performance - the terrain settings that are the same and in reference to Unity's native terrain system. To learn more about the terrain system and its settings, check out the official documentation GameObject Layers - the layer on which spawned objects will be set to Update Behavior - how two terrains are blended together Events - allows calling custom events based on generation states ❮ The holoride Player The Elastic Graph ❯"
  },
  "learn/Getting-Started/Minimal-Scene-Setup/The-holoride-Player.html": {
    "href": "learn/Getting-Started/Minimal-Scene-Setup/The-holoride-Player.html",
    "title": "The holoride Player | ElasticSDK Documentation",
    "keywords": "❮ Creating a Simple Scene The Elastic Scene Generator ❯ The holoride Player For easy integration, the Elastic SDK provides a holoride Player Prefab for Unity that is controlled by the car’s sensors and moved through the elastic experience. A camera rig must be parented under the holoride Player's GlobalRotation to add the current head rotation to the mix. Decorating objects or user interfaces can be attached to either of them. In addition, the sensor data can be accessed at any time. It can serve as a constantly updating parameter to emphasize the visual feedback to velocity, acceleration and rotation provided by affecting particles, loose objects, or moving characters. It is also possible to exaggerate the whole vehicle’s motion to imitate a jet that leans into the bend, or a sailboat that is dragged in the opposite direction—an effect that can be achieved using our Floating Platform component. Tip You can create a holoride Player game object in Unity's scene hierarchy from the right-click context menu Create > holoride > Player. The root game object HoloridePlayer performs the vehicle 3D translation and heading about the y-axis (i.e. the vertical axis with respect to the ground). Note In this scene, the debug bool for Show Debug Visualization is set to true, allowing us to see the rotations. The player prefab is made of 3 parts: Global Rotation Content is aligned to the global coordinate system. This means that, when the vehicle turns the content does not turn with it. Place any persistent background objects here, such as mountains or hills. Note Note: For testing in a moving vehicle, place the main camera or camera rig here. Local Rotation Content is aligned with the local coordinate system of the vehicle but it only consists of translation and yaw rotation of the vehicle. Neither roll nor pitch rotation is applied. Content moves as if attached to the vehicle. Note For testing at your desk, place the main camera or camera rig here. Floating Platform The FloatingPlatform uses translation and all rotation axes of the vehicle. Placing a cockpit model here and adjusting the associated curves in the editor will give the feeling of banking, when the real-world vehicle turns. With these curves, we can also emphasize acceleration or braking forces of the vehicle. World Shift Manager The World Shift Manager is a component that shifts all objects back to the origin if the player moves further away than the threshold set in the component. This is done to avoid inaccuracies and errors that occur when driving in the real world too far away from the generation pivot. Game objects parented under either of the above Player Transforms, as well as the ones generated by the Elastic Scene Generator, are automatically registered for the shift process. Game objects that are not parented under one of the above mentioned Player Transforms or are spawned by the Elastic Scene Generator can be registered by using the AddShiftParent method or via the component inspector. Localization Events Localization Events are located on a component with the same name in the Holoride Player prefab. These events are meant to be hooks where your program flow can execute different behavior based on the different states of the real-world localization data. Setting Description DistanceToStreetUntilOffRoad The distance in meters from the street until the player is considered to be too far away from the road and the OnOffRoadMode event is triggered. FireModeEventOnStart When enabled this component will fire the localization mode event for the current state when Unity's Start method is called on this component. Event Description OnLocalizationInitialized The event which is invoked when the localization becomes available and the pivot is set. OnLocalizationNormalMode The event which is invoked when the localization is available and we are on the street (up to the road distance threshold). OnOffRoadMode This event which is invoked when the localization is available but we are not on the road and the distance to the road is larger than the threshold configured in DistanceToStreetUntilOffRoad. OnLocalizationUnavailableMode This event which is invoked when the localization is unavailable and thus the player won't move even though the vehicle in the real world might. OnErrorOccured This event which is invoked when any localization error occurs. This component handles different localization quality events and reduces them to three distinct states: Normal: This state represents good localization where everything works as expected. Off-road: This state is active when the localization is available but due to inaccuracies in localization or outdated Map data, the Player might not be on the road which the content should handle accordingly. The distance to the road until the player is considered to be \"off-road\" is adjustable and should reflect the requirements of the individual content. Unavailable: This state means that no localization information is available. Provisions should be made for the content of an experience to respond to different localization states: Since the Unavailable state does not show any movement at all, even though the vehicle may in fact be moving, it is suggested not to show any indication of false movement that occurs when the Player's localization is not present but the VR headset's IMU interprets a turning car as a head rotation. In many scenarios, this means that it is not even recommended to show the player a world . The experience should start in this mode until localization is available and Map data is ready. Caution Any experience must be designed to reflect this state at any point in time to comfort the user in those situations where valid data is not available to present an elastic environment. One suggestion is to fade out the world when this mode is activated and fade it in once another state becomes active. The other interesting state is the Off-road state where there appears to be normal localization but due to limited GPS reception (e.g. in a tunnel) the Player might be off the road. In this case the experience should make sure that the player is not colliding with any objects. How this is handled depends very much on the experience that is built and could range from unloading objects that are too close to loading a different scene. The Distance To Street Until Off Road setting for this mode makes it possible to tighten or loosen the constraints for this mode, depending on the individual content. ❮ Creating a Simple Scene The Elastic Scene Generator ❯"
  },
  "learn/Getting-Started/Test-Environment.html": {
    "href": "learn/Getting-Started/Test-Environment.html",
    "title": "Test Environment | ElasticSDK Documentation",
    "keywords": "Test Environment Beginner | 45 minutes Goal Learn how to test environments built using the Elastic SDK in both the Unity editor as well as on the device. Prerequisite Basic Unity knowledge, basic Elastic SDK knowledge. Content Replay Holo Files In-Vehicle Tests Build Setup ❮ Spawner Nodes Replay Holo Files ❯"
  },
  "learn/Getting-Started/Test-Environment/Build-Setup_Content.html": {
    "href": "learn/Getting-Started/Test-Environment/Build-Setup_Content.html",
    "title": "Build Setup | ElasticSDK Documentation",
    "keywords": "Build Setup Holoride currently supports devices that run Android. This step will walk you through additional setup steps required when building with the Elastic SDK for Android. Changing the build target In Unity's File > Build Settings window, under Platform select Android, hit the Switch Platform button and wait until the switch to Android is complete. Afterwards, the holoride validation window will notify you about further required setup steps. XR Platform setup Install the XR Plugin Management by pressing the button under Project Settings > XR Plugin Management. If the Plug-in provider is not listed, add the corresponding SDK as described by the respective HMD vendor's user manual. If no SDK exists, choose Unity Mock HMD instead. Adjust Project Settings and Scene Setup Further adjustments regarding the compile process have to be applied by pressing the corresponding Fix buttons in the validation window, or by changing them manually under Project Settings > Player > Other Settings. There may also be some changes that have to be made in the scene, such as on the XR Camera Rig. These may also be applied by pressing the corresponding Fix buttons in the validation window, or by changing them manually on the respective components. Setup the XRRig If necessary move the Main Camera to the root of the hierarchy and select it. Navigate to and click GameObject > XR > Convert Main Camera To XR Rig. Move the converted XRRig to the Holoride Player > GlobalRotation child. Change the Requested Tracking of the Camera Offset component into Floor. Note that the name of this component and field might have changed with later XR Plugin versions into Tracking Origin. Search for the Tracking Pose Driver component on the camera child and change the *Tracking Type to Rotation Only."
  },
  "learn/Getting-Started/Test-Environment/Build-Setup.html": {
    "href": "learn/Getting-Started/Test-Environment/Build-Setup.html",
    "title": "Build Setup | ElasticSDK Documentation",
    "keywords": "❮ Replay Holo Files World Creation ❯ Build Setup Holoride currently supports devices that run Android. This step will walk you through additional setup steps required when building with the Elastic SDK for Android. Changing the build target In Unity's File > Build Settings window, under Platform select Android, hit the Switch Platform button and wait until the switch to Android is complete. Afterwards, the holoride validation window will notify you about further required setup steps. XR Platform setup Install the XR Plugin Management by pressing the button under Project Settings > XR Plugin Management. If the Plug-in provider is not listed, add the corresponding SDK as described by the respective HMD vendor's user manual. If no SDK exists, choose Unity Mock HMD instead. Adjust Project Settings and Scene Setup Further adjustments regarding the compile process have to be applied by pressing the corresponding Fix buttons in the validation window, or by changing them manually under Project Settings > Player > Other Settings. There may also be some changes that have to be made in the scene, such as on the XR Camera Rig. These may also be applied by pressing the corresponding Fix buttons in the validation window, or by changing them manually on the respective components. Setup the XRRig If necessary move the Main Camera to the root of the hierarchy and select it. Navigate to and click GameObject > XR > Convert Main Camera To XR Rig. Move the converted XRRig to the Holoride Player > GlobalRotation child. Change the Requested Tracking of the Camera Offset component into Floor. Note that the name of this component and field might have changed with later XR Plugin versions into Tracking Origin. Search for the Tracking Pose Driver component on the camera child and change the *Tracking Type to Rotation Only. Moving On Congratulations, you have completed the Getting Started learning track! For deeper insights into the ElasticSDK environment and its features consider proceeding with the following tracks: World Creation Learn how to create elastic environments utilizing key graph features. Code Learn how to integrate and extend the Elastic SDK API ❮ Replay Holo Files World Creation ❯"
  },
  "learn/Getting-Started/Test-Environment/In-Vehicle-Tests.html": {
    "href": "learn/Getting-Started/Test-Environment/In-Vehicle-Tests.html",
    "title": "In-Vehicle Tests | ElasticSDK Documentation",
    "keywords": "❮ Replay Holo Files Build Setup ❯ In-Vehicle Tests Sooner or later, you'll want to test your development effort in a vehicle. There are some changes that need to be made compared to when testing at a desk. We'll go through those changes below. Changing between \"Desk\" and \"Vehicle\" Configurations When you want to switch between desk testing and real-world in-vehicle testing, you have to make sure that your camera rig, including the Main Camera, is parented correctly to the fitting scenario in the holoride Player prefab. You also have to ensure the correct StateReceiver configuration. The two child GameObjects within the holoride Player that impact how the camera rotates in relation to world space and vehicle changes are LocalRotation and GlobalRotation. Put your Main Camera into GlobalRotation before you hop into a car and try it out. Putting the Main Camera into LocalRotation is a convenience feature for testing at your desk. Note You can configure the StateReceiver either by selecting the asset or in the holoride Project Settings category. Important Placing the Main Camera under the GlobalRotation object ensures the player keeps facing forwards as the vehicle travels in real-world space when the real-world vehicle turns. Vehicle Data Sources / State Receiver When testing in the vehicle, you will usually want the data source for vehicle localization to be a live data stream of the vehicle's sensors. This data is provided through the ServiceStateReceiverBackend. This backend receives live data from the holoride DevKit or a supported vehicle. Select it as the Standalone Backend in the StateReceiver. ❮ Replay Holo Files Build Setup ❯"
  },
  "learn/Getting-Started/Test-Environment/Replay-Holo-Files.html": {
    "href": "learn/Getting-Started/Test-Environment/Replay-Holo-Files.html",
    "title": "Replay Holo Files | ElasticSDK Documentation",
    "keywords": "❮ Test Environment In-Vehicle Tests ❯ Replay Holo Files Testing during development is highly important and the Elastic SDK provides the ability to test in-car experiences at your desk. This is possible by playing back replays of recorded or simulated vehicle localization data within the Unity Editor. All such replays are represented by Replay assets. Playback Replays are typically based on recorded .holo and .holo2 files. These file types contain the recorded motion data of real-world travel in a car. A default replay over the full length of the recording will be automatically created for each .holo and .holo2 file imported into your Unity project. It is possible to create further replays representing different time slices of the recordings. Tip Alternatively, @Holoride.ElasticSDK.Route assets can be used as a source for synthetic rides, with a subset of possible sensory data. A common source for such routes are .kml files and the @Holoride.ElasticSDK.RouteFromAddresses Scriptable Object. Route from Addresses assets can be created via the Create > holoride right-click context menu. As with .holo and .holo2 files, multiple replays over varying time slices can be created based on the same route. Replays are played back through the ReplayStateReceiverBackend. To use the ReplayStateReceiverBackend: select it in the StateReceiver for the context to use it in (editor and/or standalone). add a Replay of a .holo or .holo2 file to the Replay field in the inspector. Note You can download a variety of ride replay assets here: here. Recording In order to record your data at runtime, add the StateRecorder component to any GameObject in your Unity scene. By default, recording will start automatically. If you prefer to start recording manually, untick the Automatically Start Recording checkbox on the component and call the StartRecording method when you wish to start recording. The recording is automatically stopped when the component is disabled or the game stops. The recording is stored in a file located in your application's persistent data path, in the /holoride/Recordings subdirectory. As with any other .holo file, it's Replay may be used with the ReplayStateReceiverBackend. Note You can learn more about the persistent data path in the Unity documentation. ❮ Test Environment In-Vehicle Tests ❯"
  },
  "learn/Getting-Started/The-Elastic-Graph.html": {
    "href": "learn/Getting-Started/The-Elastic-Graph.html",
    "title": "The Elastic Graph | ElasticSDK Documentation",
    "keywords": "The Elastic Graph Beginner | 30 minutes Goal Get a clear overview of the Elastic Graph System and its components. Prerequisite Basic Unity knowledge. Content Graph Overview Map Nodes Pose Nodes Spawner Nodes ❮ The Elastic Scene Generator Graph Overview ❯"
  },
  "learn/Getting-Started/The-Elastic-Graph/Graph-Overview_Content.html": {
    "href": "learn/Getting-Started/The-Elastic-Graph/Graph-Overview_Content.html",
    "title": "Graph Overview | ElasticSDK Documentation",
    "keywords": "Graph Overview Using the project folder’s context menu (Create > holoride > Elastic Graph), a new graph can be instantiated. Nodes can be added by pressing the space bar or using the right-click context menu on the graph window’s background. Same-colored ports can be connected by dragging the mouse from the output to the input port. Small exclamation marks next to node ports depict a missing mandatory input. It is important to understand that the environment the Elastic Graph produces is always based on an initial set of data, which is then modified based on functions the user defines in the graph system. There are two major types of source nodes, to generate initial data sets, and associated modifier nodes, to alter these data sets: Map nodes, which can be seen as 2D grayscale textures, and Pose Set nodes, which represent containers of Position-Rotation tuples and serve as information for where to spawn objects. Other nodes such as Spawners will use the modified data sets to define how engine related content like game objects is created at runtime. Tip Every node in the Elastic Graph system can be renamed to your liking via a right-click context menu. Elastic Scene Definition The Elastic Scene Definition is the core node of every Elastic Graph. This is where all the data lines end. Ultimately it is used to communicate the output of the graph system towards the runtime pipeline of the Elastic Scene Generator component. Important The Elastic Scene Definition asset has to be referenced on the Elastic Scene Generator component. Using the Graph in the Scene The Elastic Scene Generator is the central component to execute an Elastic Graph at playtime. It will update the scene as the Generation Origin moves and is responsible for terrain generation. Terrain In order to keep things procedural, the terrain’s appearance can be modeled by using map nodes in contrast to traditional manual terrain painting. Maps can contain any float value and therefore be used to define the heights and texture weights (aka control texture) of a Unity Terrain. The Elastic SDK utilizes Unity’s default Terrain Layer assets referenced by Texture Layer nodes. The heightmap can also be used to determine the spawn height of objects that should spawn on the terrain surface. Settings The Graph Settings window can be accessed from the top-left corner of the graph window. It contains options related to the preview functionality and the processing state of the nodes, which is indicated by flashing when enabled. The WorldExtents, FilterResolution, and Location are independent from the scene the graph is used in. If an Elastic Scene Generator is using an opened graph, the previews will be replaced by the actual buffers that are used during play mode."
  },
  "learn/Getting-Started/The-Elastic-Graph/Graph-Overview.html": {
    "href": "learn/Getting-Started/The-Elastic-Graph/Graph-Overview.html",
    "title": "Graph Overview | ElasticSDK Documentation",
    "keywords": "❮ The Elastic Graph Map Nodes ❯ Graph Overview Using the project folder’s context menu (Create > holoride > Elastic Graph), a new graph can be instantiated. Nodes can be added by pressing the space bar or using the right-click context menu on the graph window’s background. Same-colored ports can be connected by dragging the mouse from the output to the input port. Small exclamation marks next to node ports depict a missing mandatory input. It is important to understand that the environment the Elastic Graph produces is always based on an initial set of data, which is then modified based on functions the user defines in the graph system. There are two major types of source nodes, to generate initial data sets, and associated modifier nodes, to alter these data sets: Map nodes, which can be seen as 2D grayscale textures, and Pose Set nodes, which represent containers of Position-Rotation tuples and serve as information for where to spawn objects. Other nodes such as Spawners will use the modified data sets to define how engine related content like game objects is created at runtime. Tip Every node in the Elastic Graph system can be renamed to your liking via a right-click context menu. Elastic Scene Definition The Elastic Scene Definition is the core node of every Elastic Graph. This is where all the data lines end. Ultimately it is used to communicate the output of the graph system towards the runtime pipeline of the Elastic Scene Generator component. Important The Elastic Scene Definition asset has to be referenced on the Elastic Scene Generator component. Using the Graph in the Scene The Elastic Scene Generator is the central component to execute an Elastic Graph at playtime. It will update the scene as the Generation Origin moves and is responsible for terrain generation. Terrain In order to keep things procedural, the terrain’s appearance can be modeled by using map nodes in contrast to traditional manual terrain painting. Maps can contain any float value and therefore be used to define the heights and texture weights (aka control texture) of a Unity Terrain. The Elastic SDK utilizes Unity’s default Terrain Layer assets referenced by Texture Layer nodes. The heightmap can also be used to determine the spawn height of objects that should spawn on the terrain surface. Settings The Graph Settings window can be accessed from the top-left corner of the graph window. It contains options related to the preview functionality and the processing state of the nodes, which is indicated by flashing when enabled. The WorldExtents, FilterResolution, and Location are independent from the scene the graph is used in. If an Elastic Scene Generator is using an opened graph, the previews will be replaced by the actual buffers that are used during play mode. ❮ The Elastic Graph Map Nodes ❯"
  },
  "learn/Getting-Started/The-Elastic-Graph/Map-Nodes.html": {
    "href": "learn/Getting-Started/The-Elastic-Graph/Map-Nodes.html",
    "title": "Map Nodes | ElasticSDK Documentation",
    "keywords": "❮ Graph Overview Pose Nodes ❯ Map Nodes With elastic content creation comes the need to introduce real world data to the virtual world. For this matter we provide a Map node type that renders certain real world data into a 2D greyscale texture-like data structure. The road a player is traveling on in the real world is a good example. As we do not want the player to collide with anything from the game world, we have to carefully arrange the experience content around the roads. Doing this in a dynamic, or rather elastic manner, for your environment is the ultimate goal you are looking for when assembling your graph. So as an example, to get data about the road around the player into an Elastic Graph, you can conveniently use the Road Network Mask node. This node fetches road data from a map service provider and presents it as a 2D texture that can be utilized in the graph system. It is important to understand that each pixel (or texel) of the generated 2D map represents a value that correlates to the real world area of the road. For the Road Network Mask these values are either 1 where there is road or 0 where there is none. Sources & Modifiers Map nodes are divided into Sources and Modifiers. While Sources generate an initial set of data, Modifiers are used to alter such data sets of the same type. An example on how to apply Modifiers on Sources can be seen below. We use two Sources, a Road Network Mask and a Perlin Noise node. The first Modifier we apply to the Road Network Mask is the Distance Transform, which in this use case computes the distance away from the road mask per pixel. We then multiply this result with the Perlin Noise output using the Multiply Modifier. So effectively we multiply each pixel from one map with the correlating pixel on the second map. Finally this produces a very hilly/noisy surface where there is no road and a flat surface for the road itself: Tip Each Map node renders a preview texture in the graph editor to get a general idea how map data is modified throughout the system. Note The resolution of the Map textures is determined by the ElasticSceneGenerator's Map Resolution setting. However, it is recommended to keep this value at its default for performance reasons. ❮ Graph Overview Pose Nodes ❯"
  },
  "learn/Getting-Started/The-Elastic-Graph/Pose-Nodes.html": {
    "href": "learn/Getting-Started/The-Elastic-Graph/Pose-Nodes.html",
    "title": "Pose Nodes | ElasticSDK Documentation",
    "keywords": "❮ Map Nodes Spawner Nodes ❯ Pose Nodes The Pose node type is a category that includes all Elastic Graph nodes that operate on Pose Sets. You can think of Poses as a 3D transform just without the scale component. The Elastic SDK implements Poses as a struct that holds a Position and a Rotation. Poses can be used for a multitude of operations but are especially important to spawn objects in an elastic manner. While service data rasterized to a Map is rather static in terms of its geo locational relation, Poses are much more dynamic and be can translated or rotated based on either fixed value ranges or procedural gradients. Keeping this idea in mind when designing an Elastic Graph system, it becomes inherently easier to spawn objects in a way that they take certain features of your elastic environment into account. Sources & Modifiers Pose nodes are divide into Sources and Modifiers. While Sources generate an initial set of poses, Modifiers are used to alter position and rotation of such sets. Besides basic transformational Modifiers like the Add Random Rotation or Add Random Translation node there are much more interesting Modifiers in terms of elastic content creation. When creating an elastic environment, you always have to keep in mind that the player drives along a real world road. So, how can you prevent the Poses from colliding with the various objects in the virtual world? To answer this the following example introduces a Pose Set Modifier called Remove By Map: Note how we start with a fairly dense grid of poses but then remove some wherever the map input has a value greater than zero, effectively stamping out the road. This simple setup will already provide a set of poses that enables you to spawn objects only where there is no road. So to finish this examples we connect the output of the Grid Poses node to a Pose Set Spawner and plug that into the Spawners output of the Elastic Scene Definition of the graph system. Tip Each Pose node renders a preview texture in the graph editor to get a general idea how Pose Sets are modified throughout the system. For each Pose the white square represents the position inside the generation bounds while the gizmo-like colored axes visualize the rotation. In addition, Pose Set nodes render the count of generated poses inside the preview bounds below the preview. ❮ Map Nodes Spawner Nodes ❯"
  },
  "learn/Getting-Started/The-Elastic-Graph/Spawner-Nodes.html": {
    "href": "learn/Getting-Started/The-Elastic-Graph/Spawner-Nodes.html",
    "title": "Spawner Nodes | ElasticSDK Documentation",
    "keywords": "❮ Pose Nodes Test Environment ❯ Spawner Nodes The Spawner node type is unique within the Elastic Graph system because unlike Map or Pose nodes, Spawner nodes do not introduce and modify new sets of data to the graph. Instead, they use parts of such data sets to instantiate objects in the virtual world, at runtime. The Elastic SDK ships with a variety of Spawner nodes that we will not cover in-depth here but rather give an introduction on how to use them for an elastic experience. The Moving Grid Before we start looking into individual Spawner nodes, there is an underlying principle that each Spawner inherits. To spawn objects in an elastic manner we have to be able to frame a space in the virtual world correlating to the real-world geolocation of the player. We call this principle the Moving Grid. Tip Select a Spawner node in the graph to visualize the Moving Grid in Unity's scene view. The grid visualization will also update at runtime. The Moving Grid is a data structure that provides a two-dimensional local grid of cells relative to the position of the generation origin. The grid position is intended to move when the player moves from a current cell to another inside this grid. Therefore, on each move, it will free instances that fall outside the grid and create new ones for the next row of cells. Grid Extents Since Spawners utilize the Moving Grid, they also expose an Extents field on their nodes. This setting determines the size of the Moving Grid and thus the area into which objects can be spawned. The basic idea here is that larger objects should be spawned in larger extents, since they are supposed to be seen at a distance, where smaller objects can be discarded. Important In general Spawners only work inside the generation bounds, since they can only access map data for this area. So if a Spawner's extents are exceeding the Elastic Scene Generator's extents, they will get clamped. One exception from this is the Unconstrained Spawner which can spawn beyond those bounds. Permitted Area Many Spawners will also provide a Map node input called Permitted Area. This input can be used to mask off area where no objects should get instantiated e.g. the road network. Prefab List & Data Provider Each Spawner of the Elastic SDK implements a Prefab List field that enables the user to link a node of type Data Provider. This effectively allows to references multiple Unity Prefab game objects that will then be selected for the spawning process, according to the Data Provider node implementation. This example uses the Pick Prefab Randomly node so that the two referenced Prefabs are picked based on a random value compared to their weights. Tip In case you do not want to reference multiple assets you can use the single Prefab selection field on the Spawner nodes. This field will automatically disappear when a Prefab List is connected. Pose Set Spawner As its name suggest the Pose Set Spawner is a spawner that operates on a set of Poses. The Pose Set is a mandatory input that the Spawner uses to derive spawning positions and rotations in the engine scene. In contrast to other Elastic SDK Spawners, the Pose Set Spawner is completely modular in a way, that you control how and where objects are spawned by modifying the set of poses that you provide as input. The following examples shows a setup that modifies a set of Poses so that the Pose Set Spawner will only spawn objects where there is no road as well as place these object at the correct height of the surrounding terrain. Note Here we use the Set Height By Map Modifier after the Remove By Map Modifier to save some computational cost, since the processed Pose Set will be smaller after the removal process. Due to the variety of available Pose Set Modifiers, the Pose Set Spawner is the most versatile Spawner in the Elastic SDK. There are much more complex setups for the Pose Set Spawner, including nodes like Translate Along Gradient , which allow spawn behavior to be customized to user-defined environmental features. While we will not cover these setups in this chapter, we do so in more advanced learning tracks. For a shortcut check out the Further Reading section of this page. Further Reading World Creation: Elastic Spawning - Learn how to use essential Spawner nodes of the Elastic SDK. ❮ Pose Nodes Test Environment ❯"
  },
  "learn/How-To-Guides.html": {
    "href": "learn/How-To-Guides.html",
    "title": "How-To Guides | ElasticSDK Documentation",
    "keywords": "How-To Guides The Elastic SDK How-To guides represent a curated collection of blog-like instructions on best practices of Elastic SDK features. Table of Content Graph Data Access Map Queries Pose Clusters"
  },
  "learn/How-To/Custom-Node.html": {
    "href": "learn/How-To/Custom-Node.html",
    "title": "How to create a Custom Node | ElasticSDK Documentation",
    "keywords": "How to create a Custom Node Intermediate | 30 mins | Programmers Introduction Goal In this tutorial we will learn how to create a custom node with inputs and outputs for the node graph. Prerequisite Familiarity with the node graph Learning Path How to create a Custom Node Introduction Goal Prerequisite Learning Path Content Creating a basic custom node Adding fields and input ports Data Processing Data Processing Lifecycle Accessing inputs and outputs Summary Content We start by defining our own node and add fields together with input ports. Later we show how this input data can be used to compute the output of the node by using a worker. Creating a basic custom node We create a new C# script using the name of our new node. In this example we will use MyCustomNode as the new node type. In order to appear in the node graph we need to inherit from Holoride.ElasticSDK.Graph.Node<T> where T is the returned data type which is by our convention the node type itself. public class MyCustomNode : Node<MyCustomNode> { } This snippet will create a new node category based on your new type. Note that to extend existing node types you can make your new class inherit either MapNode, SpawnerNode or PoseSetNode. (requires knowledge from later sections) Completing this step will allow you to create a new node from the context menu of the node graph. Adding fields and input ports Next, we will see how we can add ports and fields to the newly created node. [Input] public MyCustomNode MandatoryInput; [Input(optional:true)] public MapNode OptionalMapInput; public float Size; This snipped shows that we can declare input fields simply by adding a serialized field, in this case simply by making it public. In case our input should be another node we can declare a variable with the type of the node and add the Input attribute, even with some additional parameters. Well done, we now have a node that accepts other nodes and parameters as input. The next step is looking under the hood how data processing works. Data Processing To calculate the output from the incoming data and make it available to the connected node, we create a worker that performs the data processing. There are two steps involved: Implement a worker using the PipelineWorkerBase as a convenient base class, or for even more manual control, use the IPipelineWorker interface. Implement the IPipelineNode interface on the new custom node and generate a new worker in the GeneratePipelineWorker interface method. public class MyCustomNode : Node<MyCustomNode>, IPipelineNode { /// [...] Variables omitted for brevity public IPipelineWorker GeneratePipelineWorker() { return new MyCustomPipelineWorker(this); } } public class MyCustomPipelineWorker : PipelineWorkerBase { private MyCustomNode Node; public MyCustomPipelineWorker(MyCustomNode node) { Node = node; } // [...] PipelineWorkerBase methods omitted for brevity } The snippet above shows the implementation of the IPipelineNode interface and the creation of the worker based on this node. We pass the node to its worker in the constructor to make the node data accessible. The worker itself is based on the PipelineWorkerBase which already provides a lot of the world information. This information includes the current world boundaries which, for example, is needed when generating terrain or spawning objects. Data Processing Lifecycle Now that we have an overview on how the node and worker interact we can have a deeper look into the worker. public class MyCustomPipelineWorker : PipelineWorkerBase { // [...] Omitted public float OutputField; public override void CallInitResources() {} public override void CallInit() {} public override UniTask<LoadResourceResult> CallGatherResourcesAsync(GenerationContext context, Action<float> onProgressUpdate = null, CancellationToken cancellationToken = default) { return null; } public override UniTask CallProcessAsync(GenerationContext context, Action<float> onProgressUpdate = null, CancellationToken cancellationToken = default) { return null; } public override void CallCleanUp() {} } The snippet above shows methods originating from the PipelineWorkerBase and will be executed during the generation process based on the following order: CallInitResources 🔗 CallInit 🔗 Generation Loop: CallGatherResourcesAsync 🔗 CallProcessAsync 🔗 CallCleanUp 🔗 As probably expected we offer initialization and clean up methods before and after the update loop. In the update loop we acquire the required data for the current area of the world and then process it based on the node functionality. One interesting separation can be seen in the resource and non resource based methods. The InitResources and GatherResources methods should be able to run on their own, for example generate a cache by downloading the necessary data. This is conceptually different from the non resource based methods that use the data the resource methods provide during gameplay. An example for this would be to spawn objects or generate terrain from maps. With our new understanding of the methods the worker provides, we can now have a look at reading data from other nodes and calculating our own output data. Accessing inputs and outputs Since the initialization and gathering of resources is very node specific we can focus more on the interaction between nodes. Generally speaking we can use the GetInput method in the worker of this node together with the name of the port as the parameter to access connected workers. For our MyCustomNode we can get the map data from the OptionalMapInput port or the MyCustomNode connected to the MandatoryInput port using this method. var myCustomWorker = this.GetInput<MyCustomPipelineWorker>(nameof(MyCustomNode.MandatoryInput)); var mapWorker = this.GetInput<MapWorker>(nameof(MyCustomNode.OptionalMapInput)); This example shows that we can get a reference to the connected workers, by calling the GetInput method. MyWorkerOutput = myCustomWorker.MyWorkerOutput * 2; var myPosition = new GlobalPosition(Vector3.zero); mapWorker.GetCPUReadBufferValueInterpolated(myPosition); We can now access the methods and fields of the connected workers. For example, reading the value from a map similar to the snippet above, is used by spawners to set the y position for the newly spawned objects. Summary We started this journey by creating our custom node for the graph editor together with different input ports and a field. We then explored the inner workings of the node by looking at its worker, which performs the gathering of data and processing for each area that needs to be generated. In the end we also learned how to access data from other nodes and the need to store our result in a public field so other nodes can access it once processing is done."
  },
  "learn/How-To/Graph-Data-Access.html": {
    "href": "learn/How-To/Graph-Data-Access.html",
    "title": "How-To: Access Graph Data | ElasticSDK Documentation",
    "keywords": "How-To: Access Graph Data Advanced | 1 hour | Programmers Introduction Goal In this tutorial we learn how we can access node data in scripts from outside the elastic node graph. Prerequisite Using the access systems: Familiarity with the node graph Familiarity with Spawner nodes Familiarity with UniTask Proficiency in C# scripts Extending the access systems: Knowledge of the Worker system Learning Path Spawning objects with graph data Accessing graph data globally Writing custom mappers to access data Summary Content We start by passing data from graphs to spawned prefabs. Afterwards, we learn how we can make data accessible globally. In the end we take a deep dive into how the process of returning data from a node works. Note The graph data API of the Elastic SDK uses the UniTask framework to efficiently access available pipeline data. It is important to be familiar with this framework in order to fully understand the code flow and its implications. Spawning objects with graph data We start by creating a new C# script and attach it to a prefab in a spawner. The next step is to let the node graph know that we would like to fill one of our variables with data from the graph. For this we create a public variable and add the InjectGraphData attribute. The only missing piece is now the type of the variable. This is the most interesting part, because it describes both the node type that we want to access and the type that it returns. The ElasticSDK currently contains mappings for three output types, but we will later see how we can implement our own mappings and returned types. These output types are: FloatValueFromMapProvider.FloatValue Requiring a Map node and returning the value of the map at the spawned position IReadOnlyList<float> Requiring a Map node and returning all float values in the map IReadOnlyList<GlobalPose> Requiring a PoseSet node and returning all poses in the connected node With this knowledge we have everything to build our example: [InjectGraphData] public FloatValueFromMapProvider.FloatValue ParkMask; If we take a look into the graph, after adding this change, we can see the following: This shows that by simply using this variable type the ElasticSDK knows that we want to access a Map node and creates a port for us where we can plug in a Map node. What actually happens under the hood is that there are different mappers for the types outlined above. These mappers use the node that they require as an input and access the worker of the node for data to return the data. One specialty of the workers is that their access queries always contain the position of the prefab to be spawned. The mapper implementation that we used above, which returns a float, uses this position to query the map at this exact spot for a value. The other two return types simply ignore this position and return the full data available. In case we don't only need to have data ready in our spawned objects but query the world in general we can achieve this with the next approach. Accessing graph data globally A different approach to accessing graph data is to use the global graph output of the Elastic Scene Definition node. Here we can simply add and name new input ports to the node as shown above. With the two nodes connected we can then create a new script and access the node data from there. using System.Threading; using Cysharp.Threading.Tasks; using Holoride.ElasticSDK; using Holoride.ElasticSDK.Graph; using UnityEngine; public class MyMapDependingDynamicScaleScript : MonoBehaviour { private CancellationTokenSource CancellationTokenSource; [SerializeField] private ElasticSceneGenerator ESG; [SerializeField] private string GlobalGraphOutput; private void OnEnable() { CancellationTokenSource = new CancellationTokenSource(); ProcessGraphOutput().Forget(); } private async UniTaskVoid ProcessGraphOutput() { while (!this.CancellationTokenSource.IsCancellationRequested) { var position = GlobalPosition.FromShifted(transform.position); var output = await ESG.TryGetGlobalOutput<FloatValueFromMapProvider.FloatValue>(GlobalGraphOutput, position, CancellationTokenSource.Token); if (output.success) { transform.localScale = Vector3.one * output.result; } await UniTask.NextFrame(CancellationTokenSource.Token); } } private void OnDisable() { this.CancellationTokenSource?.Cancel(); this.CancellationTokenSource?.Dispose(); } } In the script, we first need to get a reference to the Elastic Scene Generator that uses this elastic scene definition. Now, we can query the current connected nodes using the TryGetGlobalOutput method on the Elastic Scene Generator and the entered name of the port as the first parameter. In our example above this could be either MapOutput or PosesOutput. An overload that takes in a second parameter allows us to pass the position where we want to query the node. While we might be interested in all of the poses that are currently available for the Map based nodes it is usually useful to sample a certain position. The GlobalPosition argument that the method requires, can be easily created using the GlobalPosition.FromShifted(Vector3) method. Lastly, we need to specify the generic type parameter. The possible types in this case, similar to the spawner example above, are the following: FloatValueFromMapProvider.FloatValue IReadOnlyList<float> IReadOnlyList<GlobalPose> It is important to note that not all generic types allow querying a specific position. While options 2 and 3 always return the full map or pose data connected, no matter if a position was passed to the mapper or not, option 1 is different. Since we can only return a single float value when using FloatValueFromMapProvider.FloatValue there is a way in which we need to decide which float needs to be picked from the map. When passing a position we can use this to sample the map at this exact location but when no position is passed we default to returning the first entry in the map. In case this behavior is not what we want we can create our own mapping behavior, which is what we will do in the next section. Writing custom mappers to access data We will now take a look under the hood on how we can create new mappings. This is done by IWorkerMapper interface. The generic type parameter T defines the type of the returned value of this mapper. As we have seen in the previous two chapters, we use this type when querying the Elastic Scene Generator or defining a variable in a script of a spawned prefabs. After deciding on a return type, we have to set the SourceNodeType property of the interface to the node we want to work with. The final step is to implement the mapping behavior between the node and the returned value type. With this overview over the interface we can use it in an example: For this example, our goal is to return the closest Pose of a Pose Set node. We create a class called ClosestPoseMapper and implement the IWorkerMapper<GlobalPose> interface. We chose GlobalPose since we want to return a Pose from the Pose Set. Small note here: It might make sense to not use existing types as the return type, but we will have a short discussion at the end of this chapter on this topic. public class ClosestPoseMapper : IWorkerMapper<GlobalPose> { public Type SourceNodeType { get; } = typeof(PoseSetNode); // [...] Omitted Map methods } In the snippet above, we can see the interesting property SourceNodeType that defines the type of the node this mapper requires. Next, we will see how we can access the data from the worker of the required node and use it to generate the desired output. async UniTask<object> IWorkerMapper.Map(IPipelineWorker worker, GlobalPosition position, CancellationToken cancellationToken) { return await Map(worker, position, cancellationToken); } async UniTask<object> IWorkerMapper.Map(IPipelineWorker worker, CancellationToken cancellationToken) { return await Map(worker, cancellationToken); } public UniTask<GlobalPose> Map(IPipelineWorker worker, GlobalPosition position, CancellationToken cancellationToken = default) { // TODO Implement } public UniTask<GlobalPose> Map(IPipelineWorker worker, CancellationToken cancellationToken = default) { // TODO Implement } The interface includes four map methods that can be split into two main groups. While generally the upper two methods would be sufficient, the lower two map methods are simply type safe variants of the same method. This is why we simply forward the calls of the non type safe variants to the type safe methods. public UniTask<GlobalPose> Map(IPipelineWorker worker, CancellationToken cancellationToken = default) { var poseSetWorker = (PoseSetWorker) worker; var poses = UniTask.FromResult(poseSetWorker.ReadPoses); // we don't have a position to compare against return poses[0]; } public UniTask<GlobalPose> Map(IPipelineWorker worker, GlobalPosition position, CancellationToken cancellationToken = default) { var poseSetWorker = (PoseSetWorker) worker; var poses = poseSetWorker.ReadPoses; // order the poses and return the smallest return UniTask.FromResult(poses.OrderBy(pose => (position - pose.Position).SquaredLength).First()); } Since we know that we will access the worker of a PoseSetNode, we can cast the incoming pipeline worker to a PoseSetWorker. We have now access to the ReadPoses property of the worker that stores a readonly list of GlobalPoses. The final step is to return a single pose from the list. Since the Map(IPipelineWorker) method doesn't pass a position we have to a agree on a selection method. For simplicity we can decide on simply returning the first Pose in the list. The second Map method is more interesting to us, because we sort the Poses and return the Pose that is closest to the passed position. The example above is technically complete, but we should consider that we might want to implement other mappers that return a GlobalPose. This would make it impossible for the system that needs to decide which mapper should be used since we decide this based on the returned variable. To sidestep this issue and make it more obvious which mapper is used we can simply create a wrapper class for our returned type. If we make this wrapper class a nested class inside the mapper, then we always see what mapper is used. We have already seen an example for this pattern: FloatValueFromMapProvider.FloatValue public class FloatValueFromMapProvider : IWorkerMapper<FloatValueFromMapProvider.FloatValue> { // Omitted methods and fields public struct FloatValue { public float Value; public static implicit operator float(FloatValue val) => val.Value; public static implicit operator FloatValue(float value) => new FloatValue { Value = value }; public override string ToString() => this.Value.ToString(CultureInfo.InvariantCulture); } } As we can see this is a wrapper around a float. To make it more convenient we implement the operator float and operator FloatValue to be able to convert to and from a float. Summary We have learned in this guide how we can use data from the graph inside C# scripts, either by letting the spawners inject data or by querying the Elastic Scene Definition node. For more advanced use cases this tutorial also covered, how we can build our own mapper, allowing us to access the data of the node in a different way. The example above can be a little inspiration on what we can now do with this. If we want to know, whether the spawned prefab is inside a park, we can simply pass this information and alter our gameplay with this piece of information."
  },
  "learn/How-To/Map-Queries.html": {
    "href": "learn/How-To/Map-Queries.html",
    "title": "How-To: Write Map Queries | ElasticSDK Documentation",
    "keywords": "How-To: Write Map Queries Beginner | 30 mins | Everyone Introduction Goal In this guide we will learn how to write simple queries to retrieve real world object information. Prerequisite Familiarity with the node graph Learning Path Where this knowledge is used Intro to OverpassQL Writing queries in the ElasticSDK Summary Content Where this knowledge is used To build more diverse and interesting environments we can use OpenStreetMap (OSM) nodes that allow us to fetch real world information. Using this information we can alter the world and add variation to it. Every node type can interact with the OSM in their own way. For example, the map node can display areas or outlines of areas that are tagged with specific keywords. Alternatively, we can simply use poses or a spawner to add some variation. Intro to OverpassQL To understand how OSM based nodes and their queries work we have a quick peek behind the curtain. The server is queried using a language called OverpassQL which can get fairly complex. Luckily the ElasticSDK simplifies this to reduce writing queries to the important parts. The following example shows how a full query might look like: node [highway=traffic_signals] ({{bbox}}); out; To explore such queries we can use the website overpass-turbo and get a feeling for what they return and iterate faster to our desired result. Going back to the query example, we have a look at the central elements of the query which we will later see in our OSM-based nodes. The keyword node means that the query will return objects that only have a single position. Other returned objects, such as buildings or parks, are generally represented using multiple points and are thus queried using the word way instead of node. When unsure which keyword a certain feature uses we can always check the OpenStreetMap wiki pages to see what we can expect. The wiki page contains a small information box, that shows that traffic lights should be used only on nodes. In the taginfo box below we see that this is mostly correct and only a few entries are tagged incorrectly, which we can ignore. We are now querying for single positions but still need to define what exactly we are looking for. This is done using tag filters. In this example we have a tag filter, denoted by square brackets, and the term highway=traffic_signals. This tag marks nodes on OpenStreetMap that are traffic signals such as traffic lights, traffic signals or stop lights ( see here). We can explore existing tags using a taginfo word cloud or find something more specific by directly searching in the OpenStreetMap wiki. In the wiki we also get the information on what data (node, way) we can expect from this tag. After the tag filter we see a filter, denoted by round brackets, that restricts the output. Generally we don't want to return data from the whole world but only the current area. The ElasticSDK will automatically do this for us which is why we can continue directly to the last part of the query. Lastly, we define what the query will return. In this case we want to use the positions of the nodes without additional steps. We can do this by using the out keyword. But in the case of buildings, they are usually described using ways, which includes multiple points instead of a single one. We need to collapse this group of points into a single point for example by calculating the center point of a building. OverpassQL offers this functionality by using the return type out center. After learning all this we can see the applications of this knowledge. Writing queries in the ElasticSDK In this section we will take a look at the different OSM nodes in the ElasticSDK. We start with the OSM Poses node that offers us to return poses from a map query. Since poses are represented using position (and rotation) which means that our query has to return either the nodes directly or the center point of a way. Depending on the query we have to select the correct return type below the text field containing the query. In case we want to combine the results of different queries we can also do that by simply adding more entries to the list. Similar to the OSM Poses node we can use the OSM Spawner to place prefabs at positions defined by OSM queries. As we have learned in the previous node we need to make sure our returned queries return positions either directly using nodes or indirectly by mapping it to the center of a way. Eventually, we have a look at a node that doesn't make use of poses but displays areas. Thus we make sure that our queries don't return single positions but ways that represent areas. In this example we display the shape of the buildings or the outline of a cemetery. As an inspiration, we can use queries like leisure=park or landuse=forest to query for parks or forests in the real world. Summary In this guide we have learned how OpenStreetMap nodes work and peeked into their underlying query system. We understand how queries are written and what data they need to return to be used in the ElasticSDK. In the end we have seen some of the currently available OSM based nodes and explored a few example queries that we can use as inspiration to add more variation to the game world. Further Reading Toying around with overpass-turbo is a great way to explore queries and their tagged elements The OpenStreetMap wiki pages are also a great help when trying to find the best tags or learn what you can expect from certain tagged objects or areas."
  },
  "learn/How-To/Pose-Clusters.html": {
    "href": "learn/How-To/Pose-Clusters.html",
    "title": "How-To: Pose Clusters | ElasticSDK Documentation",
    "keywords": "How-To: Pose Clusters Beginner | 30 mins | Everyone Introduction Goal In this guide we will learn how to us Pose Cluster Modifiers to generated new Poses from an initial set. Prerequisite Familiarity with the node graph Learning Path What are Pose Clusters? Pose Cluster Poisson Disc Pose Cluster Regular Poylgon Summary Content What are Pose Clusters? The key concept of Pose Cluster nodes is to create synthetic data based on an initial set of Poses and a set of user-defined parameters rather than depending on real-world locations. In short, Pose Clusters create many Poses from a few. World composition often requires that objects are placed in a pre-defined way, so that they arrange in an aesthetic manner. For procedural generation this becomes inherently more difficult, since we cannot estimate the vast possibilities of terrain shapes and spawning objects. To achieve this, we introduce the Pose Cluster Pose Set Modifiers. Pose Cluster nodes of the Elastic SDK implement dedicated algorithms, to create natural as well as artificial cluster shapes. These algorithms are then parametrized by the user, to adapt to certain situations. A special property of such clusters is the minimum distance that the generated Poses have to keep from each other. It enables the user to parametrize cluster generation in a way that they create consistent shapes without overlaps. An example for this could be trees or houses that should be distributed across an area. Two prominent Pose Cluster nodes are the Pose Cluster Poisson Disc and Pose Cluster Regular Polygon nodes. Pose Cluster Poisson Disc A Poisson Disc Sampling algorithm at its heart uses a uniform random function to sample candidates for a cluster but implements an additional constraint, that is, a minimum distance that each candidate has to keep to its neighbors. Using the minimum distance constraint we can still take advantage of the randomly generated candidates but reject the ones that are too close to each other. This will ultimately result in a natural distribution. In the following example use case we want to spawn a bunch of cactus Prefabs in a cluster. To keep the setup simple we generate an initial set of Poses from a Grid Poses node and use the output as input for the Pose Cluster Poisson Disc node to sample our clusters from. Next we set the Min Distance parameter. This distance should not be smaller than the extents of our spawned objects, so that they do not overlap. After that we can change the Cluster Radius parameter and observe how the Poses distribute over the changing area of the cluster. Note Since clusters have a certain radius, it is important to either choose a Grid Poses Spacing that is equal or greater than 2 * Cluster Radius or alternatively use a Remove Close Neighbours Modifier after the Pose Cluster node. Before we plug the resulting Pose Set into a Pose Set Spawner node, we have to remove the ones that ended up on the road as well as setting the height of the remaining Poses to the height of the terrain. We do this by using a Remove By Map node and a Set Heights By Map node. Tip In case you want to modify the uniformity of the random sampling, there is an additional Distribution curve parameter. This curve was implemented to extend the basic Poisson Disc Sampling algorithm with a user-defined density function. While the x-axis displays the normalized distance [0..1] from the cluster's center to its edge, the y-axis shows the relative density at that distance. Pose Cluster Regular Polygon For the Pose Cluster Regular Polygon node the shape that the cluster takes is restricted by the properties of a regular polygon, so equal sides and inner angles. These properties are adjusted by the parameters the user sets. Note that the initial set of poses is discarded. Imagine you want to spawn objects in a distinct formation that better reflects man-made structures. A perfect use case for the Pose Cluster Regular Polygon node. We start again with a Grid Poses node, to create an initial set of Poses but this time we use a Remove By Map node right after. Set the Threshold to the same value as your cluster radii are supposed to be large. This will ensure that we only create full cluster shapes without road intersections. Continuing with the Regular Polygon cluster node, we also have a Min Distance parameter. We set it in the same way as for the Poisson Disc clusters, which means it should not be lower than the radius of the spawned objects. Next there is a Corner parameter. This will determine the regular polygon shape. In this case, we set it to 5 which means that the resulting shape will be a pentagon. For the Cluster Radius we can choose the threshold that we set on the Remove By Map node. Optionally you can then hit the Fit Cluster button, which will find the next closest radius that exactly fits our Poses with respect to the Min Distance parameter. Uncheck Edge Poses to get rid of the shape's edges. Lastly, we are setting the height of the Poses to the terrain's height and then rotate them by 180 degrees, since the generated Poses will face the cluster's center by default. Summary In this guide we have learned how to generate procedural Pose clusters from an initial set of Poses. We have implemented use-cases for both the Pose Cluster Poisson Disc node as well as the Pose Cluster Regular Polygon node. While the core concept of clustering Poses is the same for both nodes, we have also learned the different use-cases that each node might fit best. Further Reading Pose Cluster Poisson Disc - Pose Cluster Poisson Disc node overview page. Pose Cluster Regular Polygon - Pose Cluster Regular Polygon node overview page."
  },
  "learn/Project-Setup/Best-Practices.html": {
    "href": "learn/Project-Setup/Best-Practices.html",
    "title": "Best Practices | ElasticSDK Documentation",
    "keywords": "Best Practices Graph size (re-use instead of rewrite) Every node (except portal nodes) consumes memory and at least one frame of the traversion coroutine on every generator’s update step. Therefore, creators should not duplicate nodes with identical parameters and sources but rather re-use them and modify their output. Portal nodes help to untangle the graph. Elastic SDK terrain resolution / buffer resolution The buffer resolution strongly depends on the capabilities of the target device. Since they increase by four times with every resolution step, the technical limits converge around 2048x2048 for desktop and 512x512 for mobile applications. Note that every Map node currently consumes that amount of memory, computation effort and the terrain’s update and rendering complexity. Terrain Layer count (shader based) Every terrain layer adds an even share of GPU upload time during the generation process. The uploaded amount (chunk size) per frame can be chosen from the Quality and Performance menu of the ElasticSceneGenerator. Furthermore, the terrain layer count has some impact on the render performance depending on the render pipeline. For more information on this topic, please refer to the official documentation: https://docs.unity3d.com/Manual/class-TerrainLayer.html#Performance Open Street Maps Best Practices The graph nodes OSMPositions, RoadNetworkPoses and RoadNetworkSpawner receive their data from our Open Street Map based map service. Every node adds an additional request that takes time to be sent and to download and decode the result. It’s a good idea to only have one or two of them in the graph that’s being processed and in order to get variety, use a prefab that changes its appearance instead. Zoom Level for Map data The zoom level option, e.g. available for the RoadNetworkMask, is a measure for the details a downloaded map tile provides. With increasing zoom levels multiple parameters change: Roads get narrower and the covered area decreases by four with each level. If the zoom level is set too high with respect to the filter resolution and extents, the computed maps suffer from undersampling. We therefore restrict the zoom level to 16. In most cases, a zoom level of 14 is sufficient and leads to better results with low filter resolutions like 128x128 that cover more than one square kilometer. Geocoding / Usage of the Nominatim Webservice Geocoding on route requests for simulations of your content might be affected by limited server resources. Retry requesting the route later if you encounter problems and don't hesitate to give us feedback. Generation Extents / Internet Speed Fast travelling with small generation extents and/or a slow internet connection causes pop-up effects, floating game objects and eventually entering avoid. Make sure your generation extents (e.g. in the Elastic Scene Generator game object) are sufficient. In the case the terrain update takes too long, e.g. due to a slow internet connection, it is best practice to transition into a simpler environment independent from online resources. Elastic Scene Generator -> Draw Instanced The \"Draw Instanced\" option in the ElasticSceneGenerator is not supported by some devices and might either crash the terrain generation or cause visual garbage. Physics In some rare cases physics dependent objects like raycast hits or rigidbodies that are attached to the vehicle tend to stutter at high driving speed. Enabling the option Project Settings > Physics > Auto Sync Transforms helps to solve inaccuracies."
  },
  "learn/Project-Setup/Build-Setup-for-Android-HMDs.html": {
    "href": "learn/Project-Setup/Build-Setup-for-Android-HMDs.html",
    "title": "Build Setup for Android HMDs | ElasticSDK Documentation",
    "keywords": "Build Setup for Android HMDs Holoride currently supports devices that run Android. This step will walk you through additional setup steps required when building with the Elastic SDK for Android. Changing the build target In Unity's File > Build Settings window, under Platform select Android, hit the Switch Platform button and wait until the switch to Android is complete. Afterwards, the holoride validation window will notify you about further required setup steps. XR Platform setup Install the XR Plugin Management by pressing the button under Project Settings > XR Plugin Management. If the Plug-in provider is not listed, add the corresponding SDK as described by the respective HMD vendor's user manual. If no SDK exists, choose Unity Mock HMD instead. Adjust Project Settings and Scene Setup Further adjustments regarding the compile process have to be applied by pressing the corresponding Fix buttons in the validation window, or by changing them manually under Project Settings > Player > Other Settings. There may also be some changes that have to be made in the scene, such as on the XR Camera Rig. These may also be applied by pressing the corresponding Fix buttons in the validation window, or by changing them manually on the respective components. Setup the XRRig If necessary move the Main Camera to the root of the hierarchy and select it. Navigate to and click GameObject > XR > Convert Main Camera To XR Rig. Move the converted XRRig to the Holoride Player > GlobalRotation child. Change the Requested Tracking of the Camera Offset component into Floor. Note that the name of this component and field might have changed with later XR Plugin versions into Tracking Origin. Search for the Tracking Pose Driver component on the camera child and change the *Tracking Type to Rotation Only."
  },
  "learn/Project-Setup/Testing.html": {
    "href": "learn/Project-Setup/Testing.html",
    "title": "Elastic SDK Testing | ElasticSDK Documentation",
    "keywords": "Elastic SDK Testing You’ve built your first holoride graph, things are spawning, or terrain is being generated—great! Now let’s look at how to test an experience. You have several options: Testing artificial routes based on routing information provided by Nominatim Webservice (using the Elastic SDK Route Traveler component) Route Traveler, which can be used to simulate every route on the planet Playing back recorded drives provided by holoride or recorded by yourself using Vehicle Data Recordings (.holo files) Hopping into a car and trying it out in the real world. Vehicle Data Recordings : Playback and record .holo files To give you the chance to directly test your game before your car is holoride-ready, we pre-recorded a variety of drives for you that you can easily play back with the Elastic SDK. The files can be downloaded from the holoride Creator Space. Learn more about how to record and play back .holo files here. Route Traveler: Simulate Every Route on the Planet At a certain point during development, the exact motion of the vehicle might not be relevant for you, but you want to be able to check how your holoride graph performs on all kinds of routes around the globe. For this scenario we provide a tool called Route Traveler. It outputs all kinds of routes on the planet. Please note that your user will always travel this route at a constant speed and that Route Traveler does not simulate accelerations. Learn more about how to use Route Traveler here. Switch Between Desk and Vehicle Testing When you want to switch between desk testing and real-world in-vehicle testing, you have to make sure your Main Camera is parented correctly to the fitting scenario in the holoride Player prefab. You also have to switch between the corresponding state receivers. You can read more here. (If you want to learn more about the technical reason behind this, you can find out more here)"
  },
  "learn/Project-Setup/Vehicle-Motion.html": {
    "href": "learn/Project-Setup/Vehicle-Motion.html",
    "title": "Vehicle Motion | ElasticSDK Documentation",
    "keywords": "Vehicle Motion When the user puts on their headset they enter a virtual reality, but the forces applied to them persist. It is therefore essential to provide adequate visual feedback by depicting what the user feels. Knowing that the virtual camera rig is controlled by both user head motion and car sensors, we’re able to create a virtual vehicle around the camera rig while also utilizing the cockpit for the application at hand. The interface can consist of 3D objects and 2D layers and can either be rigidly controlled by the car’s sensors or float around it in a playful manner. HoloridePlayer Prefab For easy integration, the Elastic SDK provides a HoloridePlayer Prefab for Unity3D that is controlled by the car’s sensors and moved through the elastic experience. As a child transform, the camera rig is carried on top, adding the current head rotation to the mix. Decorating objects or user interfaces can be attached to either of them. In addition, the sensor data can be accessed at any time. It can serve as a constantly updating parameter to emphasize the visual feedback to velocity, acceleration, and rotation provided by affecting particles, loose objects, or moving characters. It’s even possible to exaggerate the whole vehicle’s motion to imitate a jet that leans into the bend, or a sailboat that is dragged in the opposite direction—an effect that can be achieved using our Floating Platform component. It can be instantiated from a prefab via the Create menu holoride > Player. The prefab provides three child objects - FloatingPlatform, LocalRotation, and GlobalRotation - each with different rotation behavior. FloatingPlatform The FloatingPlatform uses movement and all rotation axes of the vehicle. Placing a cockpit model here and adjusting the associated curves in the editor will give the feeling of banking, when the real-world vehicle turns. With these curves, we can also emphasize acceleration or braking forces of the vehicle. LocalRotation In contrast to the FloatingPlatform, it only consists of movement and yaw rotation of the vehicle, but no roll and pitch rotation. Content moves as if attached to the vehicle. This means that the content uses the local coordinate system of the vehicle. Note: For testing at your desk, place the main camera or camera rig here. GlobalRotation Content is aligned to the global coordinate system (i.e. relative to the world reference frame in Unity). This means that, when the vehicle turns the content does not turn with it. Place any persistent background objects here, such as mountains or hills. Note: For testing in a moving vehicle, place the main camera or camera rig here. Changing between “Desk” and “Vehicle” Configurations When switching between testing at your desk and testing in the vehicle, the configuration of the HoloridePlayer object must be changed depending on the testing scenario. It must be made sure that the configuration of the parenting inside the HoloridePlayer object is set correctly. The two child game objects within the HoloridePlayer that impact how the camera rotates in relation to world space and vehicle changes are LocalRotation and GlobalRotation. Put your MainCamera into GlobalRotation before you hop into a car and try it out. Putting the MainCamera into LocalRotation is a convenience feature for testing at your desk. Childing the MainCamera under the GlobalRotation object prevents “rotating away” as the vehicle travels in real-world space when the real-world vehicle turns. Vehicle Data Sources / State Receiver There are three ways to move the holoride Player object within the scene that differ depending on the source of the vehicle's motion path. Sources may be a live data stream of a car's sensors, a file that is a recording of such a stream, and a simulation based on a calculated route chosen by the developer. Depending on the testing stage of your development efforts, choosing the right testing setup is a matter of using the correct corresponding component. Data sources are made available by State Receiver Backends through the singular StateReceiver. This auto-generated ScriptableObject asset contains all configuration for available sources. Here you can also configure which source to use in the editor and in builds (standalone). This can be useful when testing with replays, but using live data in builds. You can configure the StateReceiver either by selecting the asset or in the holoride Project Settings category. Replays The ReplayStateReceiverBackend plays back recorded or implicit playback data. Replays are typically based on recorded .holo and .holo2 files. These file types contain the recorded motion data of real-world travel in a car. You can download a pack of files recorded by holoride here. A default replay over the full length of the recording will be automatically created for each imported .holo and .holo2 file. It is possible to create further replays representing different time slices of the recordings. You can also record your own drives using the StateRecorder component (detailed description further below). Alternatively, Route assets can be used as a source for synthetic rides, with a subset of possible sensory data. A common source for such routes are .kml files and the RouteFromAddresses component. This is similar to using the RouteTraveller component (see below). As with .holo and .holo2 files, multiple replays over varying time slices can be created based on the same route. To use the ReplayStateReceiverBackend: select it in the StateReceiver for the context to use it in (editor and/or standalone). add a replay, e.g. of a .holo recording (holofile) to the Replay field in the inspector. Service The ServiceStateReceiverBackend receives live data from the holoride DevKit or a supported vehicle. To use the ServiceStateReceiverBackend: select it in the StateReceiver for the standalone context. unless requiring the extra control to connect via script at a custom point during initialization, keep the checkboxes for automatic initialization ticked. RouteTraveller The RouteTraveller is an alternative to using the Player (which uses the StateReceiver). It does not use or provide real motion data, but simply moves a GameObject along a predefined route with constant velocity. It also does not simulate any pitch and roll forces which can tilt/bank the virtual cockpit when accelerating, braking, or turning. The big advantage is that you can simulate any kind of route on the planet. To use the RouteTraveller setup, you need to do the following: Create a route object in your hierarchy. (Right click in the Hierarchy and select Holoride->Route) Add the addresses for desired use in the Addresses field of the RouteFromAddresses component within the inspector menu of the newly generated route object. Please note we are using the external Nominatim web service for this functionality. Alternatively, it is also possible to use latitude/longitude coordinates. Click on “Request Route” on the RouteFromAddresses component. This will generate a route spline in the scene. Now you can add the RouteTraveller Script wherever you want in the scene and link the generated route as well as the GameObject to move along the route. Please make sure that MoveGameObject is set to true. This will enable RouteTraveller to move the GameObject. The speed at which the GameObject object travels through 3D space can be adjusted by increasing the value within the Speed field. When using the RouteTraveller, be sure to reference its SharedGeoCoordinate in the ElasticSceneGenerator and avoid using a Player component (e.g. the HoloridePlayer prefab) at the same time. StateRecorder (Recording data in the moving vehicle) In order to record your data at runtime, add the StateRecorder component and link the StateReceiver being used. The recording is automatically stopped when the component is disabled or the game stops. The recording is stored in a file located in persistent data path /Holoride/Recordings and may be replayed using the FileStateReceiver. More regarding the persistent data path in the Unity documentation: https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html Recent Changes Starting with version 0.16.0, the way State Receivers are presented has changed to more closely match their actual behavior and typically desired use. In earlier versions, State Receivers were presented as Unity components. This architecture was chosen to allow scene-specific event listeners via the inspector. However, State Receivers typically should not reset between scene changes. This required some potentially fragile workarounds internally. More importantly, it made setup more complicated for users than necessary. To ease configuration and reinforce the singular existence of State Receivers, they are now presented as a single ScriptableObject. Here all available State Receivers can be configured in one place. An additional quality of life improvement is the added option to select which receiver to use in the editor as opposed to in builds. This allows users to use some kind of replay in the editor and real data in builds, without needing to change their setup. State Receiver implementations have also been renamed slightly: the FileStateReceiver is now replaced by the ReplayStateReceiverBackend. Its scope has been broadened to support any kind of Replay, not just .holo and .holo2 files. the HolorideStateReceiver is now replaced by the ServiceStateReceiverBackend to be more specific. It receives data from our service when running on Android, for example. Recentering – Synchronizing the Headset “Forward” with Vehicle “Forward” Implementation To perform a vehicle recenter, the developer must call the Recenter() method on the holoride Player component. In code, using FindObjectOfType for demonstration purposes, this may look like this: UnityEngine.Object.FindObjectOfType<Holoride.ElasticSDK.Player>().Recenter(); At this time there exist only vendor-specific methods for detecting recenter events. In the future, we plan to provide a generic drop-in solution for this task. However, for now it is the responsibility of the developer to call this method when the headset is recentered. More information here. Shifting Algorithm / Floating-Point Precision Challenge in the Game Engine Floating-Point Challenge Explained The game engine’s coordinate space was initially not designed to be used with vast distances traveled by a vehicle (i.e., many kilometers/miles, ten thousands of units in the game engine). The x/y/z coordinates are float32 values and therefore have limited precision for smaller distances when large values are present (i.e., all the precision is consumed by the digits in front of the floating point, so that digits after the decimal point are limited). This causes position jittering when objects / the player is far away from the origin of the coordinate system. General Solutions First of all, the Elastic SDK is calculating every coordinate in double precision (64 bit) internally to ensure no errors are induced. Furthermore, the Elastic SDK provides a shifting algorithm to shift everything in the scene once the player traveled a certain distance from the origin of the coordinate system. WorldShiftManager In order to keep objects close to Unity’s origin, all objects need to be shifted from time to time. The WorldShiftManager is the central place to manage all individual shifts. It will fire automatically as soon as the attached Player’s distance gets larger than the ShiftThreshold. Disabling this component pauses the process, which might be helpful in computationally heavy situations or if certain game objects, tiled textures, or shaders don’t shift as expected. By default, the player itself is shifted. The ShiftParents list can contain any additional number of transforms that are parent to objects that should be shifted individually. Note that it is not sufficient to move only a parent transform if the individual child’s coordinates keep growing. Furthermore, an OnOriginShift callback is fired that passes the shift vector as an argument to be used by custom components or repeating textures."
  },
  "learn/System-Information.html": {
    "href": "learn/System-Information.html",
    "title": "System Information | ElasticSDK Documentation",
    "keywords": "System Information Architecture The holoride software stack is made up of different parts, which are visualized in the image below: Knowing how the key components work together helps understand the system holistically. holoride Backend The holoride backend manages credentials of end users. A user must be logged into their active user account in the holoride app to be able to play holoride experiences. The connection to the holoride backend is established by the holoride app. holoride App The holoride app acts as a central hub to enter the holoride ecosystem. The user has to be logged into the active holoride account in the holoride app to use holoride-enabled experiences. The holoride app also bundles the holoride service. holoride Service The holoride service handles connections to the holoride DevKit as well as to supported vehicle brands. It connects to games/experiences running the holoride Elastic SDK and provides all the necessary data from the holoride DevKit / the vehicle. Elastic SDK The Elastic SDK receives data from the holoride service and is our engine for elastic content generation. Equipped with an easy-to-use node graph, it is a powerful toolset that enables content creators to procedurally generate experiences based on vehicle and map data. It connects to the holoride maps service that provides map information on the go. holoride Map Server Our holoride map server provides map information based on the Open Street Maps database. It provides tile-based information as well as Overpass/POI information to the holoride Elastic SDK. holoride DevKit / Supported Vehicle The holoride DevKit and supported vehicle brands provide all necessary information to ensure smooth reflection of the vehicle movement in the holoride Elastic SDK."
  },
  "learn/System-Information/Legal-Information.html": {
    "href": "learn/System-Information/Legal-Information.html",
    "title": "Additional Legal Information Elastic SDK | ElasticSDK Documentation",
    "keywords": "Additional Legal Information Elastic SDK Open Source Components The Elastic SDK is using the following Open Source Components xNode MIT License Copyright (c) 2017 Thor Brigsted Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. NoiseShader Noise Shader Library for Unity - https://github.com/keijiro/NoiseShader Original work (webgl-noise) Copyright (C) 2011 Stefan Gustavson Translation and modification was made by Keijiro Takahashi. This shader is based on the webgl-noise GLSL shader. For further details of the original shader, please see the following description from the original source code. GLSL textureless classic 3D noise \"cnoise\", with an RSL-style periodic variant \"pnoise\". Author: Stefan Gustavson (stefan.gustavson@liu.se) Version: 2011-10-11 Many thanks to Ian McEwan of Ashima Arts for the ideas for permutation and gradient selection. Copyright (c) 2011 Stefan Gustavson. All rights reserved. Distributed under the MIT license. https://github.com/ashima/webgl-noise Copyright (C) 2011 by Ashima Arts (Simplex noise) Copyright (C) 2011-2016 by Stefan Gustavson (Classic noise and others) Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Newtonsoft.Json The MIT License (MIT) Copyright (c) 2007 James Newton-King Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Google.Protobuf Copyright 2008 Google Inc. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Google Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Code generated by the Protocol Buffer compiler is owned by the owner of the input file used when generating it. This code is not standalone and requires a support library to be linked with it. This support library is itself covered by the above license. BouncyCastle Please note this should be read in the same way as the MIT license. Please also note this licensing model is made possible through funding from donations and the sale of support contracts. LICENSE Copyright (c) 2000 - 2021 The Legion of the Bouncy Castle Inc. (https://www.bouncycastle.org) Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Jetbrains annotations 13.0, Kotlin Stdlib 1.5.30, kotlin-android-extensions-runtime 1.5.30, kotlin-stdlib-common 1.5.30 Apache License, Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: a. You must give any other recipients of the Work or Derivative Works a copy of this License; and b. You must cause any modified files to carry prominent notices stating that You changed the files; and c. You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and d. If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Protocol Buffer Java API 3.15.5 BSD 3-clause \"New\" or \"Revised\" License Copyright (c) , All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Microsoft/dotnet 1.0.0 The MIT License Copyright (c) Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Webservices The Elastic SDK is using the following Map Services: Nominatim The Elastic SDK is using the Nominatim Webservice for Geocoding. More on Nominatim here: https://nominatim.org/ Open Street Maps The Map Data Service provided by holoride is based on Open Street Maps. Please read the our Elastic SDK License Agreement to learn more about Open Street Maps usage. More information also here: https://wiki.openstreetmap.org/wiki/Legal_FAQ Third Party Tools & Open Source in the Tutorials Character-Template https://github.com/Will9371/Character-Template/blob/master/LICENSE MIT License Copyright (c) 2020 Will Petillo Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "learn/System-Information/Supported-XR-Devices.html": {
    "href": "learn/System-Information/Supported-XR-Devices.html",
    "title": "Supported XR Devices | ElasticSDK Documentation",
    "keywords": "Supported XR Devices In order to work with holoride technology, mobile VR headsets have to fulfill certain criteria to be approved by holoride. This is why not every headset will be holoride-ready out of the box. To work in the challenging lighting environment of a moving vehicle, most headset tracking/pointing works only in 3 DoF mode with limited controller tracking. Please use gaze-controlled interaction for all interactions. HTC Flow The Vive Flow utilizes the smartphone as a controller. Therefore the display is distributed into four touch areas, distributed like the Scottish flag. The top button is occupied by the system menu while the other three buttons can be mapped for the user input to control the experience. Long press as well as swipe gestures are supported as well. The performance of the XR1 processor is suitable to generate and render maps and terrains with a resolution of 256x256. Moreover, experiences should mainly use Forward Rendering to fulfill the native 75 Hz refresh rate of the display that comes with 1600x1600px per eye. Product Website API Documentation. Pico Neo 3 Pro Product Website API Documentation. Pico G2 4K Product Website API Documentation."
  },
  "learn/System-Information/Vehicle-Localization-and-Headset-Tracking.html": {
    "href": "learn/System-Information/Vehicle-Localization-and-Headset-Tracking.html",
    "title": "Vehicle Localization & Headset Tracking | ElasticSDK Documentation",
    "keywords": "Vehicle Localization & Headset Tracking This chapter explains a few fundamentals regarding headset tracking in a moving vehicle. It is beneficial to understand the concept behind our approach. In order to provide a holoride experience to the end user, two objects have to be tracked independently from each other: the user’s head and the vehicle they are traveling in. 3 DoF Headset Tracking for holorides The sensors on a VR HMD (head-mounted display) cannot distinguish between vehicle and head movement. In order to simplify this challenge, we have implemented 3 DoF tracking for the holoride platform. holoride experiences and the tech stack behind them do not use 6 DoF, because providing a consistent user experience is better achieved via the simplicity of 3 DoF. This is not a drawback. 3 DoF within a holoride experience is sufficient because the user traveling in a car is sitting in a fixed location within that car. The relatively confined space of a car seat does not require 6 DoF tracking for great experiences. Please note that, as we are still in the process of optimizing our technology, there might still be glitches in the headset tracking in certain driving situations. Aligning Vehicle Localization and Headset Tracking As we are introducing a second tracked object (the vehicle), we have to add a system to align the headset and the vehicle. The Elastic SDK includes a vehicle recenter functionality that handles this task. It aligns the “forward” direction of the user with the forward direction of the car. As we took camera-based headset tracking out of the equation for our launch, we have to ask the user to align both worlds by looking “forward” in the real world (i.e., look in the direction of the headrest in front of them) and trigger the vehicle recenter. This aligns both worlds. Getting people to actually look “forward” in the reference frame of the real world and not “forward” relative to their virtual world is a hard thing to do, as “forward” is not clearly defined for them. 3 DoF tracking comes with physically based drift; the users will have to do this vehicle recenter from time to time as soon as the accumulated drift starts to feel uncomfortable. Read more on this here."
  },
  "learn/World-Creation.html": {
    "href": "learn/World-Creation.html",
    "title": "World Creation | ElasticSDK Documentation",
    "keywords": "World Creation The World Creation Learning Track is an in-depth course on how to use a multitude of tools that the Elastic SDK provides. The ultimate goal of this track is to provide a holistic set of knowledge on how to create elastic content based on the intrinsic principles of the Elastic Graph system, such as: working with gradients and masks, map queries and the procedural generation of Poses. The last part of this Learning Track will do a quick dive into the trade off between visual fidelity and performance while introducing settings and additional features that will help you reaching your goal. Learning Modules This Learning Track consists of 4 modules. Each of the parts listed below will be covered in general detail and provide you with a solid understanding of how they work and relate to each other. Elastic Terrain: Introduction module introduces the most important principles and tools of the Elastic Graph system with special focus on elastic terrain modelling. Elastic Spawning module gives an in-depth view on spawning behaviors that depend on map data. Elastic Terrain Advanced module combines already introduced principles and tools with more complex ones into advanced elastic terrain modelling setups. Quality and Performance module outlines the trade off between visual fidelity and performance. Start ❯"
  },
  "learn/World-Creation/Elastic-Spawning.html": {
    "href": "learn/World-Creation/Elastic-Spawning.html",
    "title": "Elastic-Spawning | ElasticSDK Documentation",
    "keywords": "Elastic-Spawning Advanced | 60 minutes Goal Learn how to use essential Spawner nodes of the Elastic SDK to create runtime instances of game objects at procedurally generated locations. Prerequisite Elastic SDK Getting Started Learning Track. Content Pose Based Spawning How-to: OSM Queries Poses & Gradients How-to: Pose Clusters Grid Spawner & Permitted Area ❮ Elastic Terrain: Introduction Pose Based Spawning ❯"
  },
  "learn/World-Creation/Elastic-Spawning/Grid-Spawner-And-Permitted-Area.html": {
    "href": "learn/World-Creation/Elastic-Spawning/Grid-Spawner-And-Permitted-Area.html",
    "title": "Grid Spawner & Permitted Area | ElasticSDK Documentation",
    "keywords": "❮ How To: Pose Clusters Elastic Terrain: Advanced ❯ Grid Spawner & Permitted Area The Elastic SDK graph system comes with a variety of different Spawner nodes, some of which serve a specific purpose, while others can be used in a more general way. One of these general Spawners is the Grid Spawner node. Due to its easy setup and fast performance, it is specifically useful for large numbers of decoration objects such as trees, rocks and bushes. As the name suggests, the Grid Spawner is capable of spawning objects in a grid. Because there is no Pose pipeline, we have integrated the most important operations directly into this node. In short: The idea behind the Grid Spawner is to spawn many static objects in a performance-oriented way while allowing some basic randomization in size, position, and rotation. In the following guide we will take a deeper look at the Grid Spawner node. Grid Spawner We start by creating a Grid Spawner node in our graph. As we can see the node has several parameters. First, the Extents parameter which reflects the edge length of the Moving Grid. Next, the Heightmap parameter through which the Y-position of the Prefab instances are adjusted. This means that the instances always spawn with the height that was given by a heightmap. The initial X and Z-position of the instances result from the grid they are spawned in. Assuming the same Extents increasing the Cell Size value means less but bigger cells to spawn in, thus more space between instances, and vice versa. The Prefab to create instances from can be set from the single Prefab selection field or via the Prefab List input. With this setup we have a big square with regular placed Prefabs in it. In most cases this is not admirable. We would like to use only some areas for spawning the objects. This is where the Permitted Area comes into play. Permitted Area The Grid Spawner also provides a Map node input called Permitted Area. This input can be used to mask off areas where no game objects should get instantiated e.g. the road network. To mask off the road network we can easily create a negative of the Map by using the One Minus node. Furthermore, we decrease the Grid Cell Size to see the effect better. With the Permitted Area Threshold, which currently is 1, we can adjust the threshold when Prefabs are spawned. This is directly linked to the area where they are spawned. In this case, the value ranges from 0 (no effect) to 1 (roads fully masked off). Now we have a grid that excludes the roads but there is still some more to know about the Grid Spawner. Randomization of objects To include some randomization to the grid we added some functionality. The first one is Jittering which will slightly adjust the X and Z position of each game object to break out of the strict grid-structure. This will come in handy if you need a more natural distribution. The same goes with Scaling. The default value is 1 which translates to 100%. To have some differences we just change the upper value to 2 (200%). Effectively this means that, for each instance, a random scale between 1 and 2 will be multiplied with the original scale of the Prefab. This value is then set as the new scale on the spawned instance. To add even more variety it is also possible to change the range of the height of the Prefab via the Translate Y node. Although it is already done by the heightmap, in some cases it is desirable to adjust the value. Therefore, the Translate Y value is the number in meters that is added to the height of the game object. To visualize this difference we create a simple heightmap with the Distance Transform node and increase the Shadow Distance in the settings to clarify that the game objects are floating in the air. As well as we can change the position of the Prefab instances, we can also change their rotation. To do this, we change the values of Rotation X/Y/Z which give the range of degrees added to the rotation of the instances. Both negative and positive values are allowed. ❮ How To: Pose Clusters Elastic Terrain: Advanced ❯"
  },
  "learn/World-Creation/Elastic-Spawning/How-To-Pose-Clusters.html": {
    "href": "learn/World-Creation/Elastic-Spawning/How-To-Pose-Clusters.html",
    "title": "How-To: Pose Clusters | ElasticSDK Documentation",
    "keywords": "❮ Poses & Gradients Grid Spawner & Permitted Area ❯ How-To: Pose Clusters Beginner | 30 mins | Everyone Introduction Goal In this guide we will learn how to us Pose Cluster Modifiers to generated new Poses from an initial set. Prerequisite Familiarity with the node graph Learning Path What are Pose Clusters? Pose Cluster Poisson Disc Pose Cluster Regular Poylgon Summary Content What are Pose Clusters? The key concept of Pose Cluster nodes is to create synthetic data based on an initial set of Poses and a set of user-defined parameters rather than depending on real-world locations. In short, Pose Clusters create many Poses from a few. World composition often requires that objects are placed in a pre-defined way, so that they arrange in an aesthetic manner. For procedural generation this becomes inherently more difficult, since we cannot estimate the vast possibilities of terrain shapes and spawning objects. To achieve this, we introduce the Pose Cluster Pose Set Modifiers. Pose Cluster nodes of the Elastic SDK implement dedicated algorithms, to create natural as well as artificial cluster shapes. These algorithms are then parametrized by the user, to adapt to certain situations. A special property of such clusters is the minimum distance that the generated Poses have to keep from each other. It enables the user to parametrize cluster generation in a way that they create consistent shapes without overlaps. An example for this could be trees or houses that should be distributed across an area. Two prominent Pose Cluster nodes are the Pose Cluster Poisson Disc and Pose Cluster Regular Polygon nodes. Pose Cluster Poisson Disc A Poisson Disc Sampling algorithm at its heart uses a uniform random function to sample candidates for a cluster but implements an additional constraint, that is, a minimum distance that each candidate has to keep to its neighbors. Using the minimum distance constraint we can still take advantage of the randomly generated candidates but reject the ones that are too close to each other. This will ultimately result in a natural distribution. In the following example use case we want to spawn a bunch of cactus Prefabs in a cluster. To keep the setup simple we generate an initial set of Poses from a Grid Poses node and use the output as input for the Pose Cluster Poisson Disc node to sample our clusters from. Next we set the Min Distance parameter. This distance should not be smaller than the extents of our spawned objects, so that they do not overlap. After that we can change the Cluster Radius parameter and observe how the Poses distribute over the changing area of the cluster. Note Since clusters have a certain radius, it is important to either choose a Grid Poses Spacing that is equal or greater than 2 * Cluster Radius or alternatively use a Remove Close Neighbours Modifier after the Pose Cluster node. Before we plug the resulting Pose Set into a Pose Set Spawner node, we have to remove the ones that ended up on the road as well as setting the height of the remaining Poses to the height of the terrain. We do this by using a Remove By Map node and a Set Heights By Map node. Tip In case you want to modify the uniformity of the random sampling, there is an additional Distribution curve parameter. This curve was implemented to extend the basic Poisson Disc Sampling algorithm with a user-defined density function. While the x-axis displays the normalized distance [0..1] from the cluster's center to its edge, the y-axis shows the relative density at that distance. Pose Cluster Regular Polygon For the Pose Cluster Regular Polygon node the shape that the cluster takes is restricted by the properties of a regular polygon, so equal sides and inner angles. These properties are adjusted by the parameters the user sets. Note that the initial set of poses is discarded. Imagine you want to spawn objects in a distinct formation that better reflects man-made structures. A perfect use case for the Pose Cluster Regular Polygon node. We start again with a Grid Poses node, to create an initial set of Poses but this time we use a Remove By Map node right after. Set the Threshold to the same value as your cluster radii are supposed to be large. This will ensure that we only create full cluster shapes without road intersections. Continuing with the Regular Polygon cluster node, we also have a Min Distance parameter. We set it in the same way as for the Poisson Disc clusters, which means it should not be lower than the radius of the spawned objects. Next there is a Corner parameter. This will determine the regular polygon shape. In this case, we set it to 5 which means that the resulting shape will be a pentagon. For the Cluster Radius we can choose the threshold that we set on the Remove By Map node. Optionally you can then hit the Fit Cluster button, which will find the next closest radius that exactly fits our Poses with respect to the Min Distance parameter. Uncheck Edge Poses to get rid of the shape's edges. Lastly, we are setting the height of the Poses to the terrain's height and then rotate them by 180 degrees, since the generated Poses will face the cluster's center by default. Summary In this guide we have learned how to generate procedural Pose clusters from an initial set of Poses. We have implemented use-cases for both the Pose Cluster Poisson Disc node as well as the Pose Cluster Regular Polygon node. While the core concept of clustering Poses is the same for both nodes, we have also learned the different use-cases that each node might fit best. Further Reading Pose Cluster Poisson Disc - Pose Cluster Poisson Disc node overview page. Pose Cluster Regular Polygon - Pose Cluster Regular Polygon node overview page. ❮ Poses & Gradients Grid Spawner & Permitted Area ❯"
  },
  "learn/World-Creation/Elastic-Spawning/How-To-Queries.html": {
    "href": "learn/World-Creation/Elastic-Spawning/How-To-Queries.html",
    "title": "How-To: Write Map Queries | ElasticSDK Documentation",
    "keywords": "❮ Pose Based Spawning Poses & Gradients ❯ How-To: Write Map Queries Beginner | 30 mins | Everyone Introduction Goal In this guide we will learn how to write simple queries to retrieve real world object information. Prerequisite Familiarity with the node graph Learning Path Where this knowledge is used Intro to OverpassQL Writing queries in the ElasticSDK Summary Content Where this knowledge is used To build more diverse and interesting environments we can use OpenStreetMap (OSM) nodes that allow us to fetch real world information. Using this information we can alter the world and add variation to it. Every node type can interact with the OSM in their own way. For example, the map node can display areas or outlines of areas that are tagged with specific keywords. Alternatively, we can simply use poses or a spawner to add some variation. Intro to OverpassQL To understand how OSM based nodes and their queries work we have a quick peek behind the curtain. The server is queried using a language called OverpassQL which can get fairly complex. Luckily the ElasticSDK simplifies this to reduce writing queries to the important parts. The following example shows how a full query might look like: node [highway=traffic_signals] ({{bbox}}); out; To explore such queries we can use the website overpass-turbo and get a feeling for what they return and iterate faster to our desired result. Going back to the query example, we have a look at the central elements of the query which we will later see in our OSM-based nodes. The keyword node means that the query will return objects that only have a single position. Other returned objects, such as buildings or parks, are generally represented using multiple points and are thus queried using the word way instead of node. When unsure which keyword a certain feature uses we can always check the OpenStreetMap wiki pages to see what we can expect. The wiki page contains a small information box, that shows that traffic lights should be used only on nodes. In the taginfo box below we see that this is mostly correct and only a few entries are tagged incorrectly, which we can ignore. We are now querying for single positions but still need to define what exactly we are looking for. This is done using tag filters. In this example we have a tag filter, denoted by square brackets, and the term highway=traffic_signals. This tag marks nodes on OpenStreetMap that are traffic signals such as traffic lights, traffic signals or stop lights ( see here). We can explore existing tags using a taginfo word cloud or find something more specific by directly searching in the OpenStreetMap wiki. In the wiki we also get the information on what data (node, way) we can expect from this tag. After the tag filter we see a filter, denoted by round brackets, that restricts the output. Generally we don't want to return data from the whole world but only the current area. The ElasticSDK will automatically do this for us which is why we can continue directly to the last part of the query. Lastly, we define what the query will return. In this case we want to use the positions of the nodes without additional steps. We can do this by using the out keyword. But in the case of buildings, they are usually described using ways, which includes multiple points instead of a single one. We need to collapse this group of points into a single point for example by calculating the center point of a building. OverpassQL offers this functionality by using the return type out center. After learning all this we can see the applications of this knowledge. Writing queries in the ElasticSDK In this section we will take a look at the different OSM nodes in the ElasticSDK. We start with the OSM Poses node that offers us to return poses from a map query. Since poses are represented using position (and rotation) which means that our query has to return either the nodes directly or the center point of a way. Depending on the query we have to select the correct return type below the text field containing the query. In case we want to combine the results of different queries we can also do that by simply adding more entries to the list. Similar to the OSM Poses node we can use the OSM Spawner to place prefabs at positions defined by OSM queries. As we have learned in the previous node we need to make sure our returned queries return positions either directly using nodes or indirectly by mapping it to the center of a way. Eventually, we have a look at a node that doesn't make use of poses but displays areas. Thus we make sure that our queries don't return single positions but ways that represent areas. In this example we display the shape of the buildings or the outline of a cemetery. As an inspiration, we can use queries like leisure=park or landuse=forest to query for parks or forests in the real world. Summary In this guide we have learned how OpenStreetMap nodes work and peeked into their underlying query system. We understand how queries are written and what data they need to return to be used in the ElasticSDK. In the end we have seen some of the currently available OSM based nodes and explored a few example queries that we can use as inspiration to add more variation to the game world. Further Reading Toying around with overpass-turbo is a great way to explore queries and their tagged elements The OpenStreetMap wiki pages are also a great help when trying to find the best tags or learn what you can expect from certain tagged objects or areas. ❮ Pose Based Spawning Poses & Gradients ❯"
  },
  "learn/World-Creation/Elastic-Spawning/Pose-Based-Spawning.html": {
    "href": "learn/World-Creation/Elastic-Spawning/Pose-Based-Spawning.html",
    "title": "Pose Based Spawning | ElasticSDK Documentation",
    "keywords": "❮ Elastic Spawning How To: OSM Queries ❯ Pose Based Spawning The graph system of the Elastic SDK ships with a variety of different Spawner nodes. Some of these fulfill a rather special purpose while others can be used in a more general manner. One of such general purpose Spawners is the Pose Set Spawner node. As its name suggests, the Pose Set Spawner utilizes the Pose Set node type to spawn game objects at runtime. In other words, you have to create a set of Poses and connect it to the Pose Set input, so that the Spawner is able to create instances inheriting the position and the rotation of the associated Poses. While this Spawner node also has an Extents parameter controlling the size of its Moving Grid (see Moving Grid), as well as a Prefab and Prefab List input (see Prefab List & Data Provider), the possible settings seem to be rather sparse compared to other Spawner nodes of the Elastic SDK. However, since all of the available Pose Set Sources and Modifiers can be applied to generate a set of Poses as input for the Spawner, it turns out to be the most versatile one in the Elastic SDK. The following guide will show you how to apply some basic Modifiers to generate a Pose Set ready to be used for a Pose Set Spawner. Initial Pose Set To create an initial Pose Set that works in an elastic environment the Elastic SDK ships with a variety of Pose Set Sources. Let us start with a Grid Poses node which will create a virtual grid where the distance between the Poses is equal to the node's Spacing parameter. You can leave the settings at their default values or play around with them to see how the grid reacts. Note The Pose Set nodes generate Poses inside the extents of the Elastic Scene Generator but only Poses inside the extents of the Moving Grid of the Pose Set Spawner will be spawned. From here on we can start modifying our Pose Set. Remove By Map Since a content creator usually doesn't want to spawn objects on the road to avoid collisions with the player, we add a Remove By Map node next. Based on a Map input this node will remove all Poses from our grid that fall inside the remove condition. This means we need a Map. So let us create a Road Network Mask node as well. Next, to make sure that everything on the road is removed, set the Threshold parameter to 0 and the Remove Condition to Greater. Effectively this means that every Pose that resides at a location where the Road Network Mask has a value greater than 0 will be removed from the set. Note Don't be confused if the result of the Remove By Map node looks wrong at first glance. The Pose gizmos take up more pixels than the actual position where they are located, so that you can see them better in the preview. A more advanced way of removing Poses on and near the road is to control the distance away from the road where Poses should be removed. To achieve this we apply the Distance Transform to the Road Network Mask and take the result as input for the Remove By Map node. Then we set the Remove Condition parameter to Less and change the Threshold to the minimum distance away from the road where Poses are allowed. This setup becomes important if we want to spawn larger object near the road, since the objects themselves have a certain size but their position is relative to their pivot. So with the generated Pose Set above, we can make sure that objects with a radius of up to 10 meters (assuming a centered pivot) can safely be spawned without intersecting the road. Note In some special cases where you want to spawn objects right on the edge of the terrain and you are not using the Elastic Scene Generator's Blend Margin, you might want to disable Border Distance on the Distance Transform node to get accurate results from the threshold based Pose removal. Keep in mind that this will have effects on the terrain if you use the same result for the terrain's height map. Set Height By Map To bring this setup to a usable state, we have to add one more Pose Set Modifier. This time the Set Heights By Map node uses a Map input to place the generated Poses at a height equal to the value the Map has at the location of said Poses. We use this to place objects at the same height the terrain has that we generate. Finally we can connect the generated and modified Pose Set to the Pose Set Spawner input and link its output the Elastic Scene Definition. Whatever prefab you chose will now automatically spawn at least 10 meters away from the road the player is driving on. ❮ Elastic Spawning How To: OSM Queries ❯"
  },
  "learn/World-Creation/Elastic-Spawning/Poses-and-Gradients.html": {
    "href": "learn/World-Creation/Elastic-Spawning/Poses-and-Gradients.html",
    "title": "Poses & Gradients | ElasticSDK Documentation",
    "keywords": "❮ How-to: Queries How To: Pose Clusters ❯ Poses & Gradients The Elastic SDK ships with a variety of nodes to create an initial Pose Set, such as OSM Poses. While working with such real-world Poses, can be an easy way to get good reference points for a spawning process, world compositions often require positions that are more flexible than fixed geo locations. We have already seen that the Elastic Graph System enables us to manipulate generated Pose Sets by using Pose Set Modifiers. However, when we want to manipulate the positions and rotations of an initial set of Poses, in most cases we want to do this in respect of our elastic environment. We introduce this principle with gradient based Pose Set Modifiers. Translate Along Gradient One very common use case for gradient based Pose Set modification is to move Poses along the direction of a gradient. The gradient itself can be derived from your terrain heightmap or even any other map. As an example, imagine you want to distribute your objects in a way so that they have a high probability to end up close to the hilltops of your terrain, so that the player may see them better throughout the experience. This is a perfect use case for the Translate Along Gradient node. The Translate Along Gradient node has 3 different node inputs. First the Gradient Map input. Here we connect the Map from which the gradient direction should be derived. The basic idea is, that we move Pose positions towards the brightest local area of this Map input along the increasing values of its gradient. The Step Size Map on the other hand determines the amount a Pose moves from its current position towards the gradient direction. The Pose Set input which represents the set of poses that we want to translate. Input Pre-Processing And Node Settings We start with an initial set of Poses using a Grid Poses node. This will be the Pose Set input. For the gradient, we take a Distance Transform of the Road Network Mask. Then we multiply with a Perlin Noise to introduce some variation. For the Distance Transform it is important that we check the Signed Distance parameter, so that we get non-zero values on the road as well. This will act as the Gradient Map input. The Step Size Map input can be derived from the result of the multiplication. The basic behavior we want from this example is that Poses farther away from the hilltops move larger steps towards them. As you can see in the example, we do this by remapping the Map values from an input range of 0..100 to 20..0. This translates to clamping the Map values to the input range and projecting it to the output range. So the results will be that Poses located on the road will move with the biggest steps towards the hilltops, since the signed (negative) road values from the Distance Transform get clamped to 0 and then mapped to 20. The Step Count parameter on the Translate Along Gradient node represents the number of iteration the underlying algorithm runs. So for each run, Poses move one \"step\" further on the Gradient Map. The size of the step per run, is derived from the Step Size Map. Important It is important to understand that there is no guarantee for your Poses to actually end up at your desired location. This is due to the fact that the underlying gradient descent algorithm iteratively moves the Poses to the local minima of your Gradient Map. However, based on your Step Size Map and Step Count, they might very well not move far enough or overshoot. So the general rule is, that a higher Step Count will give you more accurate results but comes at a higher performance cost. This wraps up the input for the Translate Along Gradient node and it is ready to generate the proper output. Output Post-Processing The output of the Translate Along Gradient node is not always accurate. As stated above, depending on your Step Size Map and Step Count, Poses might overshoot the area where you want them to end up in. That also means that they might end up on the road again. Knowing this, we have to further process the node output a bit more. We basically want to eliminate all remaining Poses that did not end up where we wanted them to be. Thus we use a Remove By Map node to on the multiplication result to remove every Poses that ended up on the road i.e. overshot the hilltops to far in the translation process. For most objects that we spawn at the Pose positions it is also important that they have enough spacing towards neighbouring Poses. The Remove Close Neighbours nodes will enforce exactly this, by discarding Poses that are too close to neighbouring Poses. The final step for the generated Pose Set is to place them at the height of our terrain. First the final terrain heightmap is generated by clamping the negative values of the multiplication result back to 0, using a Maximum node, since the road should be flat. The resulting Map is the Heightmap of our graph output, as well as the _ Height Map_ input if the Set Heights By Map node. Finally this generates the output that we use as the Pose Set for the the Pose Set Spawner, to instantiate cacti only around hilltop areas. Rotate Towards Gradient Another common use case for gradient base Pose Set modification is to rotate object towards the direction of a terrain slope. To achieve this, we can use the Rotate Towards Gradient node. What this node will do is rotate the Poses towards the direction of the gradient that is derived from the Gradient Map input. The following example shows how some rock faces are rotated towards the hilltops of the terrain. The Rotate Towards Gradient node has 2 node inputs. First the Gradient Map input. Here we connect the Map from which the gradient direction should be derived. The basic idea is, that we rotate Poses towards the brightest local area of this Map input along the increasing values of its gradient. The Pose Set input which represents the set of poses that we want to rotate. The Rotation Mode parameter tells the node around which axes it should rotate the Poses. Input Pre-Processing And Node Settings We start with an initial set of Poses from a Grid Poses node. This will be the Pose Set input. This time we can remove Pose that are located on the road before we use the Pose Set for the gradient rotation, since we are not moving anything. This will save some performance cost for subsequent nodes. For the gradient, we take a Distance Transform of the Road Network Mask. Then we multiply with a Perlin Noise to introduce some variation. On the Rotate Towards Gradient node itself, we set the Rotation Mode parameter to \"Y Rotation\" Output Post-Processing The new Pose rotations that the output of the node generates are now oriented towards the hilltops of the terrain on their y-axis. This means that the objects that are spawned, will face the hill side. Maybe it is more interesting to let them face the opposite direction. To achieve this, a Add Random Rotation node can be added with the Rotate Y parameter set to 180 on both ends. Tip This is an example where good Prefab composition can safe some performance cost in the Elastic Graph. Instead of using the Add Random Rotation node, the game object itself could be rotated inside the Prefab. The last thing to do is setting the Poses' height to the height of the terrain so they are ready for spawning. Tip If you want the game objects to face the road directly, instead of the direction of the terrain slope, you can use the Distance Transform of the Road Network Mask for the Gradient Map input instead. ❮ How-to: Queries How To: Pose Clusters ❯"
  },
  "learn/World-Creation/Elastic-Terrain-Advanced.html": {
    "href": "learn/World-Creation/Elastic-Terrain-Advanced.html",
    "title": "Elastic Terrain: Advanced | ElasticSDK Documentation",
    "keywords": "Elastic Terrain: Advanced Advanced | 60 minutes Goal Learn how to apply advanced principles and tools of the Elastic Graph system with special focus on elastic terrain modelling. Prerequisite Elastic SDK Getting Started Learning Track. Content Pose Based Maps ❮ Grid Spawner And Permitted Area Pose Based Maps ❯"
  },
  "learn/World-Creation/Elastic-Terrain-Advanced/Pose-Based-Maps.html": {
    "href": "learn/World-Creation/Elastic-Terrain-Advanced/Pose-Based-Maps.html",
    "title": "Pose Based Maps | ElasticSDK Documentation",
    "keywords": "❮ Elastic Terrain: Advanced Texture Based Maps ❯ Pose Based Maps An advanced way to design your procedural terrain is to use Poses that are rasterized into Maps. The idea is to use the position of a Pose as a reference point on a Map to create a heightmap. Rasterizing Pose positions into Maps can be achieved by using the Pose Set Rasterizer node. Imagine the case where you want to generate special shapes at distinct locations of an ever-changing terrain. While the basic workflow of using a Distance Transform from a Road Network Mask, is sufficient to derive an overall look for the terrain, we are unable to place shapes at certain location. However, by replacing the Road Network Mask as Distance Transform input with rasterized Pose positions, we enable ourselves to place special shapes with only a local influence on the terrain, relative to the Pose position. These Pose positions, and thus the derived shapes as well, can then be manipulated further using all of the available Pose Set Modifiers. The following guide will show you how to use a modified Pose Set, rasterized to a Map, to generate local shapes on the terrain which reflect the presence of spawned objects at the same location. Pose Set Modification Starting with a Grid Poses node we generate an initial set of Poses. We can further modify this Pose Set, to generate more distinct positions. While all of the Pose Set Modifier nodes are applicable here, for this example we simply add a random translation to the Poses to break up the rigid grid structure. Since we do not want the player to collide with our terrain shapes and spawned object, we use a Remove By Map node to only process Poses further that are not located too close to the street. Choosing the proper Threshold value here is important. It should reflect at least the radius of the shape that you plan to generate per Pose, to prevent the shapes from intersecting with the road network. The subsequent Remove Close Neighbours node will make sure that the shapes we generate will not overlap with neighbouring shapes. Here the Minimum Distance should at least be equal to twice the radius (the diameter) of the final shape but in most cases a bit larger to give them enough spacing and to prevent blending inaccuracies. Pose Rasterization & Shape Generation Having generated and modified a Pose Set that reflects proper positions, we can now move on to the actual shape generation. Using the Pose Set Rasterizer node we can compute a Map that has a white pixel where each of the input Poses would be located. Taking the Distance Transform of such a Map will result in a new Map that displays pixel values correlating to the distances away from each of the original Poses' positions. This process creates a very distinct pattern, usually referred to as Voronoi Diagram. While the center of each cell if the pattern is the location of a original Pose position, the borders of the cells (the brightest pixels) are the largest distance between each cell's center. Knowing this, we can use a Remap node that will project the distance values into a range, which will ultimately describe the shapes we want to generate. Distance Remapping The input range of the Remap node comes from the Distance Transform of the rasterized Pose Set. This means whatever we set here will be the distance across which our shape will generated. The output range on the other hand will determine the height gradient of the shape. So setting the input range to 0..25 and the output range to 0..10, effectively translates to a shape that evolves over 25 meters away from its origin with a minimum height of 0 and a maximum height of 10 meters. Important Whatever value you set for the output range's maximum value, will be the radius of the resulting shape. This is the value that you should base the earlier mentioned Remove By Map node's Threshold and the Remove Close Neighbours node's Minimum Distance on. To determine the very look of the shape, we have to use the curve parameter of the Remap node. Imagine the curve being a half-section of the vertical cut of your shape. Where in this example the origin of the curve correlates to the origin of the shape. Changing the keys of the curve will have a direct impact on the final shape that is generated on the terrain. The output of the Remap node can now be used as the Heightmap graph output for this example. Note More complex setup require some sort of blending between the generated local Pose shapes and the overall global terrain look. A Lerp node using an alpha mask to blend between the overall terrain and the Pose shapes suites this situation best in most cases. The alpha mask can be derive from the Map holding the Pose shapes using a Remap node. Spawner Setup Since we originally planned to reflect the presence of spawned object at their location on the terrain, we still have to setup a Spawner. Doing this will be rather simple, since we have generated the require Pose Set already. The only thing we have to do is setting the height of the Poses (i.e. the y-value of the Poses' positions). This way we make sure that our objects will always spawn on top of the generated shape. ❮ Elastic Terrain: Advanced Texture Based Maps ❯"
  },
  "learn/World-Creation/Elastic-Terrain-Advanced/Texture-Based-Maps.html": {
    "href": "learn/World-Creation/Elastic-Terrain-Advanced/Texture-Based-Maps.html",
    "title": "Texture Based Maps | ElasticSDK Documentation",
    "keywords": "❮ Pose Based Maps Quality & Performance ❯ Texture Based Maps Textures are a straight forward way to add sample based predictable structures into Maps. For example, a particular mountain shape can be stamped into the height map of a terrain or a particular noise texture can be used as a replacement for any Perlin Noise to achieve distinctive results. Since textures are created with 3rd party tools, they are a powerful way to connect existing elaborated workflows to the Elastic SDK's world creation pipeline. The Elastic SDK provides two texture nodes. One that repeats the texture infinitely called Constant Texture and one that stamps a texture based on the positions and rotations of a Pose Set called Blend Texture At Pose Heights. RGBA to Float Conversion For both nodes, the channel conversion from the texture's RGBA color space into the Map's float values can be determined: Name Description R The red channel of the texture. G The green channel of the texture. B The blue channel of the texture. A The alpha channel of the texture. RGBAverage The average of red, green and blue computed as (r+g+b)/3. RGBToLuminance The brightness according to the color perception of the human eye. Tiling Textures Using the Constant Texture node, all output pixels are set according to the selected channel conversion. The texture is infinitely repeating (tiling) and therefore covers the entire Map. The UV space determines whether the texture is fixed or moves with the origin geo coordinate of the Map. The scale parameter defines the size of the texture depending on the chosen UV space. Tip The World UV space is far more common than the GenerationOrigin UV space. The latter causes popup effects with every ElasticSceneGenerator update because of its jumping offset to the generation origin and should not be used if connected to the moving player transform. Similar to Perlin Noise, the output can directly be used as a height map or can be incorporated into Maps flagged as Modifiers. Most commonly, the textured Map is added, multiplied or lerped with the output of an existing arrangement of nodes. A Remap node can be employed to widen the range or obtain negative Map values. Stamping Textures A Blend Texture At Pose Heights node stamps a given texture at every Pose. As described in earlier chapters, poses can either be synthetically created via Pose Source nodes or be obtained from OpenStreetMap in order to mark particular places of interest. Maps define the environment around the objects. A clever scene generation strategy is to utilize Pose positions for both Maps and Spawners: If an object needs to be placed on top of a mountain, a mountain is placed at the exact same spot as the object. Likewise, if an object requires flat ground underneath, the Map needs to incorporate the space around the Pose before the object gets spawned at that Pose's position. The same counts for the rotation of Poses: The rotation of a foundation texture that is blended into the terrain can match the rotation of an object spawned with the same Pose. The BlendTextureAtPoseHeights node can flatten and elevate the ground precisely to the height obtained from a Pose while smoothly fading into the surrounding landscape by using its blending capabilities. ❮ Pose Based Maps Quality & Performance ❯"
  },
  "learn/World-Creation/Elastic-Terrain-Introduction.html": {
    "href": "learn/World-Creation/Elastic-Terrain-Introduction.html",
    "title": "Elastic Terrain: Introduction | ElasticSDK Documentation",
    "keywords": "Elastic Terrain: Introduction Beginner | 60 minutes Goal Learn how to apply important principles and tools of the Elastic Graph system with special focus on elastic terrain modelling. Prerequisite Elastic SDK Getting Started Learning Track. Content Distances & Heights Remap - The Multi-Purpose Tool Masks & Texture Layers ❮ World Creation Distances & Heights ❯"
  },
  "learn/World-Creation/Elastic-Terrain-Introduction/Distances-and-Heights.html": {
    "href": "learn/World-Creation/Elastic-Terrain-Introduction/Distances-and-Heights.html",
    "title": "Distances & Heights | ElasticSDK Documentation",
    "keywords": "❮ Elastic Terrain: Introduction Remap - The Multi-Purpose Tool ❯ Distances & Heights For elastic content creation it is important that you assemble a proper correlation between real-world localization data and environment features of the virtual world. While there are many ways to design such environment features, there are a handful of principles in the Elastic Graph system that will make it inherently easier to assemble said correlations towards real-world data. Two major properties of every elastic environment is the distance towards the road a player is driving on and a height that can be derived from such a distance. The essential principle behind this idea is that an elastic environment should evolve around the road network, so that the player does not collide with anything, and it should do this in a way so that the content creator has a certain amount of control over the procedural composition, i.e. the heightmap, of the environment. In other words, we compute a heightmap over a certain distance. Now, to incorporate this principle we introduce the Distance Transform node. As seen in the image above, applying a Distance Transform to a Road Network Mask results in a terrain with a lot of pyramid-like shapes. That's due to how the Distance Transform works. Per output pixel, it effectively computes the distance to the closest non-zero pixel that belongs to the input map, which in this case is the road mask. And since the input map has a bunch of square areas that are enclosed by roads, the distance increases towards the center of these areas, ultimately resulting in these pyramid-like shapes. Note Generally speaking, the value of each pixel is the distance measured between its position and the closest pixel over a threshold in the input image. That is, the two dimensional euclidean distance measured in meters. This is obviously a rather boring composition for a terrain, so let's see what happens when we multiply these distances with a Perlin Noise node. Already the resulting terrain has a much more natural appearance with great variation. Hill shapes are defined by the noise while their height increases with the distance to the road. Noise So what did we actually do to the values of the Distance Transform? To understand this, it is important to understand the idea of Noise as well. In the case above, values from a 2D Perlin noise are sampled along the generation bounds. Noise, as any other signal, is always defined by three properties: Frequency, amplitude and time. Since a Map is effectively an area constrained by the generation bounds, a noise value for each point (or pixel) in this area is needed. This is achieved by sampling the 2D noise signal along the vertical and horizontal coordinates of the map. The coordinates are in this case a point in time of the noise signal. The frequency of the noise signal is defined as 1 / Size, while the Size parameter, in a scientific context, would be referred to as the period of the signal. Tip Use the Size parameter to adjust the frequency of the noise signal. Effectively this will capture a broader area of the 2D Perlin noise function. Finally, the output the Perlin Noise node generates are the amplitudes of the noise signal. These are the values that we multiply with the output of the Distance Transform node to introduce more detail, more variation to the terrain shapes. Data Modifiers Node types of the Elastic SDK that are used to generate and introduce synthetic or real-world data, such as Map or Pose nodes, are divided into Sources and Modifiers. <br> While Sources represent an initial set of data, Modifiers are used to alter this data. For Map nodes, two basic Modifiers are the Add and Multiply nodes. In general, Modifiers will execute a sequence of operations on each data point of the input maps. For Add and Multiply, it is a simple addition and a multiplication. This means for example every point of data at a specific location on one Map will be added to a value at the same location on the second Map. The result is then output in a new Map. As we did for the noise example, we can also assume for each Map that we are working with signals. It might be helpful to first think in terms of 1D signals similar to audio, that represent a slice of our map. To visualize an example of the effects of a Multiply or Add operation on such a signal, we have an interactive graph below. The two input curves represent the initial signals (or map slices). Use the knobs on these curves to alter the values the operations execute on. You can observe how the amplitudes of the output signals, i.e. the knobs on the output curves, change. Add Data Remove Data Randomize Input Tip The top chart is interactive! Use the knobs on each curve to adjust the input values for the operations rendered in the bottom chart and observe the resulting curve shapes. Note The vertical axis range has changed on the output chart to put the maximum values into perspective. While these curves are a visual representation of a 1D signal, it should give a good indication how shapes evolve from your 2D Maps as well. Remember the Map slice metaphor. Understanding the principle of combining Maps with one another is essential for the usage of the Elastic Graph system, so make sure to play around with different input values. ❮ Elastic Terrain: Introduction Remap - The Multi-Purpose Tool ❯"
  },
  "learn/World-Creation/Elastic-Terrain-Introduction/Masks-and-Texture-Layers.html": {
    "href": "learn/World-Creation/Elastic-Terrain-Introduction/Masks-and-Texture-Layers.html",
    "title": "Masks & Texture Layers | ElasticSDK Documentation",
    "keywords": "❮ Remap - The Multi Purpose Tool Elastic Spawning ❯ Masks & Texture Layers In Unity, the terrain surface color is usually defined by multiple blended textures. For every place on the terrain, a weight Map defines which texture is dominant. We utilize the same Maps to define the texture weights as we do for heightmaps. Doing so requires four additional setup steps: The Elastic Scene Generator requires a reference to a material that supports Unity's Terrain Layer system. Unity's Terrain Layer assets have to be created and set up with texture files and material properties. In the Elastic Graph, Texture Layer nodes need to be added, linked to a Terrain Layer asset and connected to the Elastic Scene Definition node. Maps need to be defined to mask the weights of the terrain textures. Terrain Material Setup A material supported by the active render pipeline needs to be selected. Every official render pipeline comes with its own terrain shader. If your project uses the Standard Render Pipeline, the recommended asset is the pre-defined material called Default-Terrain-Diffuse. If your project is set up with the Universal Render Pipeline, create a new material in your asset folder first and from its Inspector's drop-down menu choose the shader Universal Render Pipeline/Terrain/Lit. Link the respective material in the Terrain Material field on the Elastic Scene Generator component. Alternatively, any surface shader will work as a terrain material to achieve more individual looks. However, they rarely support terrain layers out-of-the-box and won't benefit from the techniques described in this tutorial. Tip Custom Terrain Layer support requires a deeper understanding of Unity's shader system since the naming conventions of the shader properties have to be followed. With some effort, they can even be used by shader graphs in combination with the Universal Render Pipeline. Unfortunately, we don't know of any official documentation and therefore refer to independent examples on code based Terrain Shaders and Terrain Layer enabled Shader Graphs. Terrain Layer Setup Create a new Terrain Layer asset by right-clicking your asset folder and choosing Create > Terrain Layer (mind that this is not a holoride asset). A minimal setup requires only a Diffuse texture to be linked. To follow up on this tutorial, repeat the process twice with different textures. Tip Further Terrain Layer settings are described in the official documentation. Mind that setting a Normal Map and Mask Map might be costly on mobile VR headsets. For the sake of tuning the Terrain Layer properties, we recommend you to temporarily add a Unity terrain to the scene, add the Texture Layers and paint a sample terrain. Texture Layer Nodes In your Elastic Graph, add three Texture Layer nodes and connect their outputs to the Elastic Scene Definition (make sure it's the one referenced in your scene). For every Texture Layer choose a different Terrain Layer asset. Tip You should not connect more than four Texture Layers to avoid additional render passes. Texture Masks (Respecting the Sum-of-1-Rule) Let us add two simple Map Sources, a Perlin Noise and a Road Network Mask node and connect them to two of our Texture Layers. Texture Layers are more predictive if the map values are kept between 0 and 1. Therefore, we set the max value of the Perlin Noise node to 1. We add a One Minus node with the Perlin Noise node as input and connect its output to the third Texture Layer. As the terrain is generated, you will notice how the Perlin Noise blends between two alternating textures. The One Minus node ensures that the sum of both masks is 1 at every position, which, as a rule-of-thumb, is the ideal state for predictive texture blending. At places where the noise map is close to the defined min and max values, only one texture is visible. That is, because here one masks measures up to 1 while the other approximates 0. The weight of the road mask however is added to the other texture weights, producing a total value of 2 at all road pixels (which violates our sum-of-1-rule). As a result, the texture weights are normalized and the road texture has 50% impact while the other two textures share the other 50% determined by the noise. Our goal however is to carve the road into the noise weights and avoid them to shine through. To fix this, we need to create the inverted Road Mask by plugging it into another One Minus node. Everything we multiply with this output will set the output at road pixels to 0. We do so with both the noise and the inverted noise respectively and therefore retrieve the sum-of-1-rule at every position. Tip The written min and max values under every preview image help us to ensure all values stay between 0 and 1. Furthermore he sum-of-1-rule can be validated using Add nodes. Slope Depending Textures A particularly useful Node for terrain texture weights is the Normal Projection Evaluator. It makes the slope of the terrain accessible if we connect the same input as for the Heightmap port of the Elastic Scene Definition. With its default settings, the node's output is almost 1 at very steep cliffs and 0 where the surface is level. Therefore, the masks it generates are not only in the desired 0 to 1 range, they also contribute to a particularly authentic terrain look. The slope has impact on numerous physical phenomenons of real world terrains such as landslip, gravity, erosion, exposure to sunlight and plant cover. By remapping the node's output, the influence of the slope can be further refined. In this example, we replace the noise texture by the remapped Normal Projection Evaluator. ❮ Remap - The Multi Purpose Tool Elastic Spawning ❯"
  },
  "learn/World-Creation/Elastic-Terrain-Introduction/Remap-The-Multi-Purpose-Tool.html": {
    "href": "learn/World-Creation/Elastic-Terrain-Introduction/Remap-The-Multi-Purpose-Tool.html",
    "title": "Remap - The Multi-Purpose Tool | ElasticSDK Documentation",
    "keywords": "❮ Distances & Heights Masks & Texture Layers ❯ Remap - The Multi-Purpose Tool The Remap node is one of the most versatile Map Modifiers that, with some practice, will soon evolve to your Swiss Army Knife in terms of elastic terrain modelling. It is used to bring an input value from one range to another while keeping it's relative position inside these ranges. By default, this means that if your input value is 80% of the size of your input range then, after the remap, it will be 80% of the size of the output range. Note It is possible to change this behavior utilizing the Curve parameter. The same behavior translates one-by-one to Maps and is executed for each each pixel value of the input Map. Important Values of the input Map are clamped to the Input range parameter. Basic Implementation The concept of value remapping can be confusing in certain scenarios. It might be helpful to go through the underlying math to better understand what actually happens to the input values. The basic remapping algorithm is as follows: outputMapValue = outputRangeStart + (outputRangeEnd - outputRangeStart) * ((inputMapValue - inputRangeStart) / (inputRangeEnd - inputRangeStart)) Curve Modulation The Remap node is using an additional Curve parameter enabling the user to customize the distribution of the input values inside the output range. This parameter is what makes this node so useful. For elastic terrain modelling it is often required to form shapes over a certain distance away from the road the player is driving on. Imagine a case where you want to create plateau-like shapes across your environment. This is a perfect use case for the Remap node: What is happening here is that by using the Distance Transform of the Road Network Mask as input, we can remap the distances away from the road to certain heights of our plateau-like shape. By setting the Input range to 0..50 and the output range to 0..25, we basically say that over a distance of 50 meters away from the road we want to get height values ranging from 0 to 25. Therefore, the Curve parameter defines how these distances map from the input range to the output range, ultimately driving the plateau shape. Note The Curve's axes values are normalized to a 0..1 range. If this was not the case, the x-axis would show the input range and the y-axis the output range. Implementation Wrap Up On a code level the curve is doing nothing more than evaluating the values of the second part of the multiplcation, clamped between 0 and 1, that was presented above already. The ouput value of the curve is then used as alpha input for a linear interpolation between Output range's start and end value. To reflect the additional Curve parameter in the pseudo code implementation: curveInput = clamp01((inputMapValue - inputRangeStart) / (inputRangeEnd - inputRangeStart)); curveOutput = clamp01(Curve(curveInput)); outputMapValue = lerp(outputRangeStart, outputRangeEnd, curveOutput); Further Reading Remap node - Node detail page. The simple yet powerful math we don't talk about! - A lovely take on lerp, inverse lerp and remap by Freya Holmér. ❮ Distances & Heights Masks & Texture Layers ❯"
  },
  "learn/World-Creation/Quality-and-Performance.html": {
    "href": "learn/World-Creation/Quality-and-Performance.html",
    "title": "Quality & Performance | ElasticSDK Documentation",
    "keywords": "Quality & Performance Advanced | 60 minutes Goal The smaller the device's form factor and the larger the field-of-view, the more difficult it gets to provide a pleasing experience that does both provide state-of-the-art visuals and run flawlessly with a good performance. We can distinguish between three measures when talking about performance: The time it takes to generate/update a scene at runtime The probability and length of display freezes, also known as framedrops The framerate in general Depending on which measure you want to optimize, different tweaks or strategies can be applied. However, in many cases the optimization isn't lossless but comes with a trade-off. In this chapter you will learn how to optimize your experience. Prerequisite Elastic SDK Getting Started Tracks and previous World Creation Tracks. Content Scene Generation and Update Time Framerate Optimization Object Pooling ❮ Texture Based Maps Scene Generation & Update Time ❯"
  },
  "learn/World-Creation/Quality-and-Performance/Framerate-Optimization.html": {
    "href": "learn/World-Creation/Quality-and-Performance/Framerate-Optimization.html",
    "title": "Framerate Optimization | ElasticSDK Documentation",
    "keywords": "❮ Scene Generation & Update Time Object Pooling ❯ Framerate Optimization Visual Range There are some considerations to be taken into account when optimizing an elastic scene with respect to the framerate. The most important setting is the extents parameter every Spawner provides. Decreasing the extents by 50% leads to about a quarter the amount of objects, but the smaller the extents, the more obviously objects will popup from nowhere. However, popups can be concealed using techniques such as fade-in (from fog), fly-in, scale-in, etc.. Also the terrain can be spawned with reduced extents by using the quarter size terrain option on the ElasticSceneGenerator. Note that this option does not quarter the data that is processed underneath so you still maintain control over Poses, Spawners and Map data of the ElasticSceneGenerator's full extents. Decrease the extents of Spawners and find other methods to conceal popup-effects. Try the quarter size terrain option on the ElasticSceneGenerator. Spawner Tweaks There are strategies to optimize more Spawners more specifically. Using the distance transform on the road mask gives you an idea how close objects can potentially appear as the vehicle drives by. If the potential minimum distance to the road is large enough, objects don't need to be as detailed. Even billboards do a great job in the distance. Avoid spawning too many objects in general. Combining objects in one single prefab is a good idea to avoid unnecessary operations. To wrap it up, the framerate benefits from the following best practices: Spawn extra simple objects like billboards at places the vehicle cannot get close to. Combine objects and spawn multiple objects with a single Spawner if possible. Furthermore, If the objects to spawn are very dense (i.e. less than 20 meters apart), like rocks, grass, trees or other scene decoration, it makes sense to use the GridSpawner instead of a PoseSetSpawner which is less versatile but way faster in processing. The GridSpawner still provides options to randomize object transforms, set the height by a Map, mask permitted regions and select from different prefabs by using a PickPrefab* node. For dense decoration objects, replace PoseSetSpawners by GridSpawners. Further general optimizations on objects to be spawned are: Make good use of Unity's LOD system for GameObjects. If you have to spawn many objects using the same mesh data, activate GPU instancing. Avoid scripts with heavy update methods. Revisit the physics settings of the objects. Can unnecessary rigidbodies and colliders be removed? Overdraw Mitigation Overdraw is another big topic. Rasterized geometry should overlap as rarely as possible. Even an early z-test of opaque objects has impact on the performance - especially if the triangles cannot be sorted and end up being rendered back-to-front, overdrawing the depth buffer multiple times. Therefore, all objects should be optimized to not contain hidden geometry under the opaque surface. This also counts for the generated terrain. The more hills and valleys are generated between the camera and the horizon the more overdraw happens. Using the distance transform on the road mask lets you determine regions that are rather far away from the road. Those regions should be as smooth as possible without alternating heights if you won't see them anyway behind the rows of hills next to the road. To mitigate the workload needed for the rasterization process/step mind the following: Refine every object geometry by eliminating hidden surfaces that are't visible but will still be rasterized. When using a terrain, avoid hills that are never visible. Rendering Optimizations The Elastic SDK is independent from the actual render pipeline and therefore doesn't add any options beside the selection of the terrain shader. Still, the biggest impact on the framerate in most VR applications has the render pipeline with shader operations in particular. Fragment operations have the largest computational share and are the first address to start optimizing. Especially on mobile VR devices that usually come with large pixel resolutions, the fragment shader should be as lightweight as possible. Hence, when choosing your art style, you should mind the following guidelines: Reduce dynamic lighting effects to a minimum by baking shadows and highlights into textures. Choose an art style that is not depending on too many texture layers (including normal or gloss textures). Use as few terrain layers as possible with 4 as the maximum number. Only use the diffuse texture for terrain layers. Reduce texture sizes to a bearable minimum. Avoid transparency. Don't make use of post-processing effects. Don't use shaders with multiple render passes. Resolution Trade-Offs There are other strategies to decrease the global fragment output such as using a lower resolution render target. While decreasing the render resolution and up-scaling the render buffer is an effective solution to generally reduce the fragment count and therefore drastically speed up the framerate, it leads to unwanted pixelization. The quality loss is particularly noticeable with fine lines such as display text. Anti-aliasing is a good way to conceal some of the low resolution artifacts and some art styles even benefit from a lower output resolution with therefore anti-aliased edges. However, since anti-aliasing isn't cheap either, this trade-off should be carefully decided. Foveated rendering, as often provided by the HMD's SDK, is a technique to reduce the pixel resolution in the peripheral view only and is therefore a recommended trade-off for VR experiences you definitely should consider activating. As a summary, mind the following guidelines: Find a trade-off between decreased output resolution and increased anti-aliasing. Make use of foveated rendering if provided by the HMD. Other Savings Last but not least, some global options have impact on the performance as well. Double check the following settings for maxing the framerate: Revisit Unity's physics settings. Disable Auto Sync Transforms if it doesn't induce collision accuracy problems as the car moves fast (it may also disturb UI interaction). The build should not be a debug build and no profiler should be attached. The stack trace should be disabled when logging. ❮ Scene Generation & Update Time Object Pooling ❯"
  },
  "learn/World-Creation/Quality-and-Performance/Object-Pooling.html": {
    "href": "learn/World-Creation/Quality-and-Performance/Object-Pooling.html",
    "title": "Object Pooling | ElasticSDK Documentation",
    "keywords": "❮ Scene Generation & Update Time Code ❯ Object Pooling Preceding chapters showed the intrinsic importance of Spawner setups to introduce game object data into an elastic experience. This page is going to introduce the idea of Object Pooling as a way to optimize these setups further, making it possible to handle large amounts of objects while mitigating the cost for object instantiation. Pooling & Instantiation The basic idea behind Object Pooling is to manage an amount of objects in pools that are associated with the object type. Instead of creating and destroying, objects are then retrieved from and returned back to the associated pools. In most cases this results in a much lower workload on the CPU for large object amounts, because of the pooling process saving the cost for frequent memory allocation. In an elastic environment Object Pooling is not as straight forward as in a static environment. This is due to the fact that there is no sane way to estimate a fixed amount of objects that will be sufficient for all the features of an ever changing procedural environment. With respect to this situation the Elastic Object Pools of the Elastic SDK will dynamically grow as additional objects are required. Pooled Object Setup Most of the pooling process in the Elastic SDK is automated, which means that the user only has to determine which game objects are supposed to be pooled. This is done via the Pooled Object component that has to be added to the Unity Prefabs that should be part of the pooling process. This is already enough to enable the pooling process for game objects that are created using Spawners of the Elastic SDK. However, for more complex Prefabs one must understand that their instances' life-cycle is different when they live in pooling system. Most importantly, after the initial creation of the instance, they are not destroyed or re-created. But instead they will be enabled and disabled. On a script level, this mean every functionality that is supposed to execute when a game object appears or disappears should be called in Unity's OnEnable() and OnDisable() life-cycle calls. To provide a no-code workflow, the Pooled Object component ships with 3 events that are exposed to the Unity editor. These events allow the user to add functionality that is executed whenever these events are invoked. Name Type Description Init UnityEvent Invoked when object has been instantiated and initially added to the pool. This event can be used to invoke behavior that should exclusively happen when an instance of the poolable object is created. Retrieved From Pool UnityEvent Invoked when object has been taken from pool. This event can be used to execute spawning behavior before the game object instance is set to its prefab's active state. Before Return To Pool UnityEvent Invoked right before game object returns to pool. This event can be used to execute despawning behavior like animations or in general behavior that should happen outside of Unity's life cycle calls. Important When retrieved from the associated pool, a game object's active state is automatically set to the active state of its prefab. Furthermore, when a game object has return to its pool, its active state is always set to false. Additionally, the component has a Auto Return To Pool checkbox to disable the automated return process of the game objects that fall outside of a Spawner's Moving Grid. This becomes important in cases where you want to fully execute an exit process (e.g. an animation) before the game object returns to the pool and thus is disabled. If this checkbox is disabled, the public API PooledObject.ReturnToPool() has to be called manually when the exit process concludes. An example script to trigger entrance and exit animation via the Before Return To Pool event could look as follows: using System.Collections; using Holoride.ElasticSDK; using UnityEngine; public class PoolingAnimTester : MonoBehaviour { public float animTimer = 0.0f; public float animDuration = 5.0f; public PooledObject poolingComponent; private void Start() { this.poolingComponent = this.GetComponent<PooledObject>(); } public void StartAnimOut() { this.StopAllCoroutines(); this.StartCoroutine(this.AnimOut()); } public void StartAnimIn() { this.StopAllCoroutines(); this.StartCoroutine(this.AnimIn()); } private IEnumerator AnimOut() { var startPosition = this.transform.localPosition; while (this.animTimer < this.animDuration) { this.animTimer += Time.deltaTime; var animProgress = this.animTimer / this.animDuration; this.transform.localPosition = Vector3.Lerp(startPosition, startPosition + Vector3.down * 3.0f, animProgress); yield return null; } this.animTimer = 0.0f; var returnStatus = this.poolingComponent.ReturnToPool(); } private IEnumerator AnimIn() { var startPosition = this.transform.localPosition; this.transform.localPosition = new Vector3(startPosition.x, -1.0f * 3.0f, startPosition.z); while (this.animTimer < this.animDuration) { this.animTimer += Time.deltaTime; var animProgress = this.animTimer / this.animDuration; this.transform.localPosition = Vector3.Lerp(startPosition + Vector3.down * 3.0f, startPosition, animProgress); yield return null; } this.animTimer = 0.0f; } } Warning Disabling the automated return process for pooled game objects can have a direct impact on the size of the associated pool. This is because pools in the Elastic SDK grow dynamically when more game objects are needed than are available. Depending on the duration of the delay until game objects return, the number of cells in the Moving Grid and the speed of the player, the pools can grow rapidly. Eventually, however, the size of the pool will converge to the player's maximum speed. A suitable value for the Max Pool Size setting can be assigned to the individual pools to prevent excessive growth. Elastic Object Pool Manager Setup Besides the Pooled Object component that has to be added to the game object the user wants to be part of the pooling process, there is also the Elastic Object Pool Manager component. By default, this component resides on the Elastic Scene Generator Prefab and works out-of-the-box. However, when someone where to remove it without removing the Pooled Object components from the Prefabs that are referenced on the Spawners of the Elastic Graph system, the runtime environment of the Elastic SDK will throw a warning that these objects will not be end up in a pool. Note We do not throw an exception here, so that a user can quickly test scenarios with and without pooling enabled without having to remove every Pooled Object component. Only one Elastic Object Pool Manager component is required. This component will act as a provider for all Prefab pools. Internally the pool objects are stored in a dictionary with the associated Prefab objects as keys. In the scene hierarchy the pool game objects will be located at top-level and be name after the pattern: Pool_<Prefab name>. Note It is not recommended to move the pool game objects into lower levels of the hierarchy. This is likely to cause an increasing amount of updating Pooled Object transforms messaging children and parents, whenever the Elastic SDK's world shift happens. For more information visit: Optimizing the Hierarchy On the Elastic Object Pool Manager component you will also find 2 settings: Pool Settings and Default Settings. While the Default Settings expose values that are used as fallback, the Pool Settings associate specific for individual pools to enable more granular control over the pooling behavior. Pool Settings are linked to the individual Prefab via a mandatory reference on the settings asset itself. Adjustable settings are as follows: Setting Type Description MaxPoolSize int The maximum amount of instances the spawning pool is going to create. Supports runtime change. Where 0 means unlimited. InitPoolSize int The initial amount of instances the spawning pool is going to be instantiated with. MaxInitFrames int The maximum amount of frames taken to instantiate initial spawning pool. Where 0 equals 1 frame to initialize all instances. Moving On Congratulations, you have completed the World Creation learning track! For deeper insights into the ElasticSDK environment and its features consider proceeding with the following tracks: Code Learn how to integrate and extend the Elastic SDK API ❮ Scene Generation & Update Time Code ❯"
  },
  "learn/World-Creation/Quality-and-Performance/Scene-Generation-and-Update-Time.html": {
    "href": "learn/World-Creation/Quality-and-Performance/Scene-Generation-and-Update-Time.html",
    "title": "Scene Generation and Update Time | ElasticSDK Documentation",
    "keywords": "❮ Quality & Performance Framerate Optimization ❯ Scene Generation and Update Time One measure for performance is the time it takes to generate an elastic scene. This includes 1. downloading all resources such as maps and loading all scene resources from the storage, 2. preprocessing internal data structures and 3. processing all node outputs that contribute to an ElasticSceneDefinition. The same operations are called whenever a scene generation catches-up with the player. Hence, a slow scene update may even cause the player to leave the generated scene and fly into the void. The ElasticSceneGenerator extents determine the amount of data that has to be downloaded and preprocessed. Cutting the extents in half almost quarters the number of operations of every pose set node as well as the open street map depending nodes such as the RoadNetworkMask. On the other hand, reducing the ElasticSceneGenerator resolution to half the size almost quarters the number of operations of every map node. This leads to the following checklist: Set the smallest bearable ElasticSceneGenerator extents with respect to popup effects. Set the smallest bearable ElasticSceneGenerator resolution with respect to the degree of detail of maps and terrain. The most important handle for reasonable generation times is to keep the generation graph slim. It's technically easy to re-use nodes by linking the same output port to multiple input ports of different consumer nodes. This also means to avoid similar nodes and subtrees with slightly different output (such as multiple PerlinNoise nodes with almost identical parameters). Instead, try to unify them up to a degree where a different parameter set really matters. In order to keep your graph clean, make use of portals which are computationally for free. Let us summarize: Re-use nodes to avoid redundant operations. Use portals to emphasize re-usability. Furthermore, think about how to avoid expensive operations if the output is almost identical. As an example, a pose set should first be masked with RemoveByMap before the objects are rotated using RotateTowardsGradientDirection because the rotation has to be applied to fewer nodes. Be aware though, that there are situations in which the order of the nodes doesn't only affect the performance but also the output. In the aforementioned example, applying TranslateAlongGradient after the masking will most likely lead to poses outside of the masked area. Consider these steps to make sure to use the most performant node setup: Review the order of your nodes. Swap the order if the output is identical but fever operations can be achieved. Use a single spawner with a PickPrefabByMap node rather than individual spawners with masked areas. For dense decoration objects, replace PoseSetSpawners by more performant but less flexible GridSpawners. (See framerate Optimizations) Additionally, it is important to think of a worst case scenario when dealing with map data. OSM dependent spawners may download large files that require heavy preprocessing. Additionally it is a good idea to transition to an alternative scene setup that generates a internet independent scene replacement if the vehicle gets too close to the edge of the ElasticSceneGenerator. This can be a flight over a perlin noise terrain or an equally simple graph. Be aware of the potential size of your OSM query. Transition to simple internet independent graph if the ElasticSceneGenerator cannot catch up. ❮ Quality & Performance Framerate Optimization ❯"
  },
  "manual/Experience-Design.html": {
    "href": "manual/Experience-Design.html",
    "title": "Experience Design | ElasticSDK Documentation",
    "keywords": "Experience Design Creating immersive experiences for VR is already an exciting journey, but being able to travel through them while driving in the real world adds a totally new dimension! Creating with holoride means creating immersive experiences designed for travel and exploration. With immersive technology, it is possible to create a variety of unique experiences. Elastic Content is reactive to the environment that the user travels through while in a car. It means that the experience will change based on the vehicle’s motion and location. There are three factors that influence the experience and will adapt to the user’s individual journey: The way the driver navigates the car Real-world traffic conditions The definition of the environment based on actual roads and the real world around the user In this chapter, we will introduce some rules and concepts that will help you create amazing experiences that are also comfortable to use. Next Step: holoride Design Principles"
  },
  "manual/Experience-Design/Design-Principles.html": {
    "href": "manual/Experience-Design/Design-Principles.html",
    "title": "holoride Design Principles | ElasticSDK Documentation",
    "keywords": "holoride Design Principles As mentioned in the previous chapter, you should avoid creating discomfort, loss of orientation, etc. for the user. Therefore, the following holoride Design Principles apply. World references Points of reference within the virtual world such as a sense of the horizon, a “ground” or “floor” that the user passes over as they travel, the virtual world helps with orientation and a sense of place. Placing landmark objects like trees, stones, or monoliths in the world will help users perceive movement and parallax. Make sure size references are consistent. Motion Flow Never leave users in the dark void or let them lose orientation. Keep reference points clear and easy to perceive even subconsciously. Don’t add cognitive load by mixing spatial references. Small motion reference points are very important (e.g., dust particles). Don’t add cognitive load by mixing vertical and horizontal motion that is not clearly distinguishable from the vehicle’s motion. Technical You should pay attention to performance and always aim to hit the headset’s target frame rate. Real-world travel and virtual content must not collide - don’t allow the user to pass through unexpected virtual objects. Next Step: User Interaction"
  },
  "manual/Experience-Design/Experience-Layers.html": {
    "href": "manual/Experience-Design/Experience-Layers.html",
    "title": "Experience Layers | ElasticSDK Documentation",
    "keywords": "Experience Layers In a moving space, we separate the virtual world into different Experience Layers. This makes sense because certain aspects of the experience are driven by different real-world anchors and therefore have a different impact on the user’s perception of motion and orientation. Even though they are distinct layers they all follow the same holoride Design Principles. In short, those principles cover world references, general motion flow, and technical rules. You can read more about the holoride Design Principles here. Some layers are mandatory, others are optional. Mandatory Layers Elastic Environment Vehicle Floor and Vehicle Console (part of the vehicle volume) Optional Layers 2D Canvas Vehicle (part of the vehicle volume) In this section, we explain each of these layers. Next Step: Elastic Environment"
  },
  "manual/Experience-Design/Experience-Layers/2D-Canvas.html": {
    "href": "manual/Experience-Design/Experience-Layers/2D-Canvas.html",
    "title": "2D Canvas | ElasticSDK Documentation",
    "keywords": "2D Canvas The 2D Canvas is connected to the Vehicle Volume. They follow the same vehicle motion. Here you can place any 2D content (video, 2D gaming, texts, graphics, menus, etc.). We offer some sample tools to get your content quickly integrated. This 2D Canvas is anchored to the motion of the vehicle. There are also a variety of values to adjust certain behaviors of the 2D panel in relation to the motion of the vehicle. When designing for a 2D Canvas, it is important to keep in mind specific road conditions like extreme bumpiness and sharp turns or acceleration and deceleration of the car. It affects how efficiently users will be able interact with UI elements or 2D content on this layer. Next Step: Vehicle Volume"
  },
  "manual/Experience-Design/Experience-Layers/Centre-Point-Of-Motion.html": {
    "href": "manual/Experience-Design/Experience-Layers/Centre-Point-Of-Motion.html",
    "title": "Center Point of Motion | ElasticSDK Documentation",
    "keywords": "Center Point of Motion The center point of the Vehicle Volume, which is used by the transform matrix (rotation/translation), and the actual center point of location tracing of the vehicle are not the same, but in the virtual environment the perception is that they are and any difference in this distance is negligible. So any physical position of the user in the car will be a center position in the holoride experience. Motion in any of these content layers will be calculated from this center point. Next Step: UI Guidelines"
  },
  "manual/Experience-Design/Experience-Layers/Elastic-Environment.html": {
    "href": "manual/Experience-Design/Experience-Layers/Elastic-Environment.html",
    "title": "Elastic Environment | ElasticSDK Documentation",
    "keywords": "Elastic Environment Traveling through an elastic environment creates a certain complexity, but this can be avoided by separating the experience into Experience Layers. This is based on the perception of VR experiences in a moving vehicle, tethered to a motion-synchronized environment. The world you travel through is not only visually appealing and can tell a story, it’s also crucial to avoiding motion sickness and discomfort due to confusion. You can read more about elastic environment and elastic ambient environment creation with the Elastic SDK. Next Step: 2D Canvas"
  },
  "manual/Experience-Design/Experience-Layers/Vehicle-Volume.html": {
    "href": "manual/Experience-Design/Experience-Layers/Vehicle-Volume.html",
    "title": "Vehicle Volume | ElasticSDK Documentation",
    "keywords": "Vehicle Volume The Vehicle Volume is a combination of several components that provide comfort for users and give creators space for customization. The Vehicle Volume is a close-proximity content layer for the user. It is suitable for visualizing any type of a vehicle interior and/or placing UI elements or smaller menus. The Vehicle Volume also visualizes the motion of the real-world vehicle and is a great place to store important UI elements. Furthermore, the vehicle is unconstrained when it comes to scale. In numerous tests, we elaborated specific recommendations and samples described in the following section. Note: As the Vehicle Volume is a close-proximity content layer for the user, we do not recommend overcrowding this area with functionality, animations, or design details. Next Step: Recommended Minimal Vehicle"
  },
  "manual/Experience-Design/Experience-Layers/Vehicle-Volume/Maximum-vehicle-customization.html": {
    "href": "manual/Experience-Design/Experience-Layers/Vehicle-Volume/Maximum-vehicle-customization.html",
    "title": "Maximum Vehicle Customization | ElasticSDK Documentation",
    "keywords": "Maximum Vehicle Customization The Vehicle Volume can be completely customized. Whether the vehicle depicts a small capsule that barely fits a seat, or whether it’s the command bridge of a giant ship—the key thing is to ensure it fits the minimum requirements (vehicle floor and vehicle console). It’s a great place to store scoreboards, levels, XP, lives, etc. We recommend placing them in a specified area, between 1.30 and 2.50 meters away from the user (as a general rule, not closer than the default vehicle prefab of 1.30). These text fields and menus can be placed as far as 4 meters away, utilizing users’ comfortable FOV zone. We also advise you not to visually overwhelm the user (flashing lights, overload of details) or include too much of the outside world in order to avoid discomfort. Note: The Vehicle Volume is a close-proximity content layer for the user. We don’t recommend overcrowding this area with functionality, animations, or design details. Next Step: Center Point of Motion"
  },
  "manual/Experience-Design/Experience-Layers/Vehicle-Volume/Recommended-minimal-vehicle.html": {
    "href": "manual/Experience-Design/Experience-Layers/Vehicle-Volume/Recommended-minimal-vehicle.html",
    "title": "Recommended Minimal Vehicle | ElasticSDK Documentation",
    "keywords": "Recommended Minimal Vehicle holoride requires a minimal setup of the Vehicle Volume in order to avoid motion sickness caused by too much movement too close to the user. This includes the vehicle floor and the vehicle console. Vehicle floor – This is a safety feature giving the user a feeling of being grounded. It can be opaque or semi-transparent. Vehicle console – This acts as a “guardrail” defining the user’s safe space that no outside object can enter or intersect. Its other purpose is to help users identify the direction of movement. Note: The vehicle console is also a place where important functionalities like the “restart localization” should be placed. Next Step: Maximum Vehicle customization"
  },
  "manual/Experience-Design/UI-Guidelines.html": {
    "href": "manual/Experience-Design/UI-Guidelines.html",
    "title": "UI Guidelines | ElasticSDK Documentation",
    "keywords": "UI Guidelines These guidelines are focused on ensuring ease of readability while in a moving vehicle and using elastic content. The goal is to give some guidelines to create a compelling user interface that does not generate cognitive load or discomfort. We advise you not to add too many motion animations to UI elements as these break orientation and counteract vehicle motion references in the surrounding environment or the vehicle visualization. As you can read in the Experience Layers chapter, holoride experiences offer you a variety of safe locations to place User Interfaces in order to avoid motion sickness. World Space UI When placing UI elements in world space, it is important to consider the ever changing user’s proximity to those UI elements. We recommend setting minimum and maximum bounds as you would for world space UI in a regular VR experience. UI orientation – It is possible to place UI elements anywhere in the world. However, you must decide if the UI element automatically faces the user or stays correctly assigned to its initial orientation. The first option will make the UI easier to read, the second option will avoid breaking the physical reference. Next Step: 2D Canvas UI"
  },
  "manual/Experience-Design/UI-Guidelines/2D-Canvas-UI.html": {
    "href": "manual/Experience-Design/UI-Guidelines/2D-Canvas-UI.html",
    "title": "2D Canvas UI | ElasticSDK Documentation",
    "keywords": "2D Canvas UI This layer is suitable for placing not only 2D games and video players but also larger menus. It can also be a place for more conventional UI designs. In this section, we will look at some specific values that will give you a better idea of where to start. Optimal viewing distance – we recommend using a comfortable field-of-view (FOV) that is known from regular VR as your guide. In our experience, a viewing distance between 3.05 and 6.5 meters away from the user achieves the best readability and interaction comfort. Screen size/proportion – you are free to experiment and adjust sample planes to your specific needs, we recommend following the holoride design principles, while also being sure to stay within the recommended FOV zone. Curvature of the plane – curvature of the screen is highly dependent on size and distance from the user. For a standard 2D screen that comfortably fits in the FOV, we recommend using a relaxed curve with the center point of the sphere located behind the user. (see Z1) Next Step: UI Elements"
  },
  "manual/Experience-Design/UI-Guidelines/Accessibility-Guidelines.html": {
    "href": "manual/Experience-Design/UI-Guidelines/Accessibility-Guidelines.html",
    "title": "Accessibility Guidelines | ElasticSDK Documentation",
    "keywords": "Accessibility Guidelines Accessibility can be a challenging topic in regular VR, and adding a vehicle’s motion and an elastic environment adds complexity. To make sure the presented content is more inclusive and appeals to a wide audience, keep in mind that the general rules of accessibility apply. Input and Controls Ensure that all areas of the user interface can be accessed using the same input method. Include an option to adjust the sensitivity of controls. Ensure that all key actions can be carried out with a keyboard and/or by digital controls. Avoid repetetive input. Make sure the on-screen keyboard functions properly. Audio and Speech Provide separate volume controls and stop/pause or mute effects, for speech and background sound/music (independently from the overall system). Ensure that no essential information is conveyed by sound alone. Use distinct sound/music design for all objects and events. Use surround sound. Keep background noise to minimum during speech or better yet, avoid using altogether. UI Elements Ensure interactive elements/virtual controls are large and well spaced. Use an easily readable default font size and/or allow the text to be adjusted. Use simple clear text formatting. Ensure that no essential information is conveyed by text (or visuals) alone, reinforce with symbols, speech/audio or tactile information. Ensure that no essential information is conveyed by colour alone. Indicate which UI element is focused on. Avoid placing essential temporary information outside the player’s eye-line. Controller Ensure that the user can reset and calibrate their focus, zoom and orientation/view in a device-independent manner. Provide an option to select a dominant hand."
  },
  "manual/Experience-Design/UI-Guidelines/Motion-Sickness-Guidelines.html": {
    "href": "manual/Experience-Design/UI-Guidelines/Motion-Sickness-Guidelines.html",
    "title": "Motion Sickness Guidelines | ElasticSDK Documentation",
    "keywords": "Motion Sickness Guidelines The following are some basic considerations for avoiding motion sickness: Design for minimal user head movement inside VR. The main content should fit in to the field of view. If it is larger, use a scroll bar in both directions. Avoid positioning UI at the extreme top or bottom of the FOV. The main content should be placed along the users´ central line of sight, enabling comfortable viewing. However, ensure that the users can still gather information relating to the direction of travel in their peripheral vision. Make sure peripheral vision is aligned with the users’ motion (theoretically). Avoid too many simultaneously moving items/objects, however, peripheral vision is an exception to this. Provide settings to enable control of moving items/objects. Make sure that the UI does not incorporate contrasting colours. Do not design interactions that require 360 degrees of rotation for any reason. Avoid repetitive patterns on surfaces. Keep it simple. Make sure that the user feels grounded and safe. Avoid animations which involve elements moving across a large area. Quality of the content must be at least 60PFS. No blurry and pixelated UIs. Reading guidelines If the user needs to move within the virtual environment, use RSVP (rapid serial visual presentation) for small blocks of text, displayed either in the edge-fixed (2) or in the head-fixed (3) location. If reading is the primary task and the text is long and important, display text as a paragraph either in the world-fixed (1) or in the edge-fixed (2) location. Note (1) World-fixed - a static, in-situ text in the virtual environment. (2) Edge-fixed - a text with static position and dynamic orientation that vertically tilts to face the user while staying attached to the virtual environment with an edge. (3) Head-fixed - a text in a head-up display. Next Step: Accessibility Guidelines"
  },
  "manual/Experience-Design/UI-Guidelines/UI-Elements.html": {
    "href": "manual/Experience-Design/UI-Guidelines/UI-Elements.html",
    "title": "UI Elements | ElasticSDK Documentation",
    "keywords": "UI Elements Typography A moving environment brings many challenges for readability, similar to when reading in a car. We have collected some recommendations to help you avoid common mistakes. Designing for holoride’s 2D stage is similar to designing billboards or a poster, the same readability rules apply. Font styles should be minimal and comfortable for holoride and fit within the regular VR guidelines. We always recommend challenging and testing them for yourself. Sans serif fonts are generally more legible in a digital space. In addition, we recommend against using thin and lightweight fonts, as they cause a lot of antialiasing. In some cases, increasing kerning can also help improve legibility. Line length should be based on simple ergonomics and comfortably fit into the user’s FOV. If you have to use bigger blocks of text, we advise using shorter line lengths that don’t require the user to move their head in order to read everything. Button Specs Because of unpredictable driving conditions, designing and placing buttons or any other interactive UI elements could be a challenging task. Due to gaze-and-click interactions, we recommend making collider boxes of these elements at least 20% bigger than the element itself. To help give you some reference points to start from, here are some values that worked for holoride. These values are true for a screen that was 3.05 meters away. Minimum button size is 68x68 pixels (in this case we recommend adding a bigger collider box and some padding to prevent misclicks). Minimum padding is 15px (but in general we recommend using bigger spacings if possible). UI Animations (Interaction Animations) For UI motion design, we recommend a subtle approach. UI animations that have a lot of motion on the X and Y axes or the Z axis, which could intersect with the vehicle volume movement, can cause user discomfort and motion sickness. Next Step: Motion Sickness Guidelines"
  },
  "manual/Experience-Design/User-Interaction.html": {
    "href": "manual/Experience-Design/User-Interaction.html",
    "title": "User Interaction | ElasticSDK Documentation",
    "keywords": "User Interaction The current holoride supported HMDs offer 3DOF head motion tracking as well as button and thumb stick interaction. Unlike in stationary VR experiences, the motion of the car is much more impactful than motion in close proximity (centimeter motion). Also keep in mind that during a drive, sudden acceleration/deceleration can occur, as can vertical motion, which might make user interaction difficult. This impacts button sizes, selection states, etc., and we strongly recommend reading more about our findings in the UI Guidelines section. Due to limited physical space and the risk of injuries in a car, experiences cannot require the user to make sudden bodily movements of the VR controllers or headset while holoriding. Next Step: Experience Layers"
  },
  "manual/Extension-Packages.html": {
    "href": "manual/Extension-Packages.html",
    "title": "Extension Packages | ElasticSDK Documentation",
    "keywords": "Extension Packages The Elastic SDK comes with a bunch of extensions which can be included into the project via the Unity Package Manager after the Elastic SDK Setup. Some packages provide a sample scene that can be imported subsequently from below the package description in the Unity Package Manager."
  },
  "manual/Extension-Packages/Fade-to-Background-Built-In.html": {
    "href": "manual/Extension-Packages/Fade-to-Background-Built-In.html",
    "title": "Fade-To-Background Shaders (Built-In Render Pipeline) | ElasticSDK Documentation",
    "keywords": "Fade-To-Background Shaders (Built-In Render Pipeline) This support package comes with a set of shaders that fade objects into the skybox instead of a solid color fog. It is particularly useful to conceal popup effects in the distance. In contrast to real transparency, the performance impact is negligible. Tip This package comes with a sample scene you can install from the Unity Package Manager. The following setup steps are required to apply the Fade-To-Background technique to your scene: Use Fade-To-Background material shaders for all objects that should fade in the distance. Either by replacing all shaders on existing materials by Fade-To-Background shaders, or by creating new materials based on the provided Fade-To-Background shaders. Apply the FadeToBackground/Skybox|Cubemap shader to the scene's background material. Add the FadeToBackgroundManager component to the scene and provide the main camera as a dependency. Important Using the FadeToBackground/Skybox|Cubemap shader can cause smearing artifacts if no FadeToBackgroundManager has been attached to the scene. Setting up the Fade-To-Background Manager Dependencies Parameter Type Description Camera Camera The camera to draw the fading materials. View Distance Cutoff (optional) The FadeToBackgroundManager provides the option to cutoff the view distance adaptively depending on the generated content. The bounds of a given Elastic Scene Generator (and the camera position within) determine the maximum allowed view distance. Note Leave the ElasticSceneGenerator field empty if you don't want to use the View Distance Cutoff feature. Parameter Type Description ElasticSceneGenerator ElasticSceneGenerator The ElasticSceneGenerator to cutoff the maximum view distance depending on its bounds. Leave empty to disable cutoff. CutoffDistanceToBounds float The cutoff distance to the bounds of the ElasticSceneGenerator. CutoffApplySeconds float The time in seconds it takes to apply new bounds after an ElasticSceneGenerator update. Maximum Distances and Opacity The fading gradient can be determined and adjusted at runtime using the following parameters: Parameter Type Description MaxOpacity float The maximum opacity of all FadeToBackground materials. MaxOpaqueDistance float The maximum distance at which FadeToBackground materials start fading out. MaxTransparentDistance float The maximum distance at which FadeToBackground materials lose sight. Appear / Disappear Animation In order to let the scene appear or disappear in a smooth way, an animation can be applied and triggered by calling the PlayAppearAnimation() and PlayDisappearAnimation() functions or by pressing the corresponding button. Parameter Type Description BehaviorOnEnable BehaviorOnEnable The behavior on every OnEnable call when the FadeToBackgroundManager gets active. AnimationType AnimationType The kind of animation to reveal or hide all FadeToBackground materials. AnimationCurve AnimationCurve Maps the current animation time to a ratio of the fadeout effect. While the time can be scaled at will, values are clamped between 0 and 1 when evaluated. OnAppearAnimationFinished UnityEvent Gets invoked when the appear animation ends. OnDisappearAnimationFinished UnityEvent Gets invoked when the disappear animation ends. Note Since the AnimationCurve values are clamped between 0 and 1, the keyframes should begin with a value of 0 and end with a value of 1 to get the expected result. The following behaviors on enabling the FadeToBackgroundManager component can be selected: BehaviorOnEnable Description PlayAppearAnimation Plays the appear animation to reveal all FadeToBackground materials. Invisible FadeToBackground materials are invisible and are revealed when the PlayAppearAnimation() function is called. Visible FadeToBackground materials are visible. AppearAfterElasticSceneGenerationFinished Plays the appear animation after the ElasticSceneGenerator has finished its generation process. The following animations can be chosen from: AnimationType Description Swipe The render distance starts narrow and gets wider. Fade The render opacity starts transparent and gets more opaque."
  },
  "manual/Procedural-Generation.html": {
    "href": "manual/Procedural-Generation.html",
    "title": "Procedural Generation | ElasticSDK Documentation",
    "keywords": "Procedural Generation We must first understand the two types of content that are used in experience production: tailored and procedural. Tailored content grants creators the ability to precisely define all aspects of a scene. However, this also means doing so for every part of that scene—from very small spaces to large spaces. Procedural content passes this responsibility on to algorithms, with the artist indirectly influencing the result by defining rules and providing samples of data. Since there’s not enough time or money to manually tailor content for every road in the world, Elastic Content is procedural, meaning that it provides you with tools to easily define the rules. The Elastic SDK gives developers the ability to define patterns and generators rather than placing game objects by hand. These rules can be applied at runtime for any place on earth by accessing geo databases. At the core of this system is an Elastic Scene Definition component, incorporating a graph consisting of nodes that represent algorithms, data sources, operators, or modifiers. The holoride Graph Using the graph, it’s possible to incorporate real-world data into a digital in-vehicle VR experience—a holoride. For example, creating a virtual forest for a player to ride through in VR becomes a matter of connecting nodes. Some would distribute trees around the user, others mask those trees out of the holorider’s path while harnessing real-world map data. This is particularly important because the VR passenger should never collide with a virtual object. There are two major types of nodes. Map nodes can be thought of as 2D textures, while pose set nodes represent containers of Position-Rotation tuples and provide information on where to spawn objects. Both can either be generated synthetically or reference real-world data downloaded from our map server. Spawners instantiate game objects at runtime. Does that mean you have to learn content creation from scratch? No, elastic graph spawners can instantiate prefabs. So everything you can wrap into a prefab can be created exactly the way you are used to: renderers, animations, rigidbodies, scripts, audio sources, you name it. Creating content is no different than it would be for tailored experiences—the Elastic SDK helps you populate experience worlds. It’s also possible to define a terrain replacement by applying maps for the terrain's height and its texture weights. The terrain system within the Elastic SDK leverages Unity’s terrain system so that it defines the runtime generation of terrain using the aforementioned graph tools; for example, a real-world road could become a dirt track through endless meadows even though the player’s car is driving through a bustling city center."
  },
  "manual/Procedural-Generation/Best-Practices.html": {
    "href": "manual/Procedural-Generation/Best-Practices.html",
    "title": "Best Practices | ElasticSDK Documentation",
    "keywords": "Best Practices Graph size (re-use instead of rewrite) Every node (except portal nodes) consumes memory and at least one frame of the traversion coroutine on every generator’s update step. Therefore, creators should not duplicate nodes with identical parameters and sources but rather re-use them and modify their output. Portal nodes help to untangle the graph. Elastic SDK terrain resolution / buffer resolution The buffer resolution strongly depends on the capabilities of the target device. Since they increase by four times with every resolution step, the technical limits converge around 2048x2048 for desktop and 512x512 for mobile applications. Note that every Map node currently consumes that amount of memory, computation effort and the terrain’s update and rendering complexity. Terrain Layer count (shader based) Every terrain layer adds an even share of GPU upload time during the generation process. The uploaded amount (chunk size) per frame can be chosen from the Quality and Performance menu of the ElasticSceneGenerator. Furthermore, the terrain layer count has some impact on the render performance depending on the render pipeline. For more information on this topic, please refer to the official documentation: https://docs.unity3d.com/Manual/class-TerrainLayer.html#Performance Open Street Maps Best Practices The graph nodes OSMPositions, RoadNetworkPoses and RoadNetworkSpawner receive their data from our Open Street Map based map service. Every node adds an additional request that takes time to be sent and to download and decode the result. It’s a good idea to only have one or two of them in the graph that’s being processed and in order to get variety, use a prefab that changes its appearance instead. Zoom Level for Map data The zoom level option, e.g. available for the RoadNetworkMask, is a measure for the details a downloaded map tile provides. With increasing zoom levels multiple parameters change: Roads get narrower and the covered area decreases by four with each level. If the zoom level is set too high with respect to the filter resolution and extents, the computed maps suffer from undersampling. We therefore restrict the zoom level to 16. In most cases, a zoom level of 14 is sufficient and leads to better results with low filter resolutions like 128x128 that cover more than one square kilometer. Geocoding / Usage of the Nominatim Webservice Geocoding on route requests for simulations of your content might be affected by limited server resources. Retry requesting the route later if you encounter problems and don't hesitate to give us feedback. Generation Extents / Internet Speed Fast travelling with small generation extents and/or a slow internet connection causes pop-up effects, floating game objects and eventually entering avoid. Make sure your generation extents (e.g. in the Elastic Scene Generator game object) are sufficient. In the case the terrain update takes too long, e.g. due to a slow internet connection, it is best practice to transition into a simpler environment independent from online resources. Elastic Scene Generator -> Draw Instanced The \"Draw Instanced\" option in the ElasticSceneGenerator is not supported by some devices and might either crash the terrain generation or cause visual garbage. Physics In some rare cases physics dependent objects like raycast hits or rigidbodies that are attached to the vehicle tend to stutter at high driving speed. Enabling the option Project Settings > Physics > Auto Sync Transforms helps to solve inaccuracies."
  },
  "manual/Procedural-Generation/Graph-Node-Overview.html": {
    "href": "manual/Procedural-Generation/Graph-Node-Overview.html",
    "title": "Graph Node Overview | ElasticSDK Documentation",
    "keywords": "Graph Node Overview Map Sources Creates a map (of float values) of the environment. It can be used to generate terrain if used as a height map, to filter spawned objects, or as an input for several other nodes. Info: The maps are visualized in a black/white/blue manner. White is always the maximum value (does not have to be “1”), and black always represents the minimum value (does not have to be “0”). Shades of blue are used for negative values. All these nodes generate “Map” data types: Constant Value Outputs a map with a constant value. Constant One Outputs a map with only “1”s. Constant Texture Outputs a defined texture as a map. Constant Zero Outputs a map with only “0”s. Terrain Elevation The height map of the earth surface retrieved from satellite images. Note that neither tunnels nor bridges are contained. Additionally, the map is not detailed enough to foresee the vehicle’s altitude. Perlin Noise Outputs a perlin noise. Example Use Case: Adding synthetic variety by either adding or multiplying perlin noise to another image. Pose Set Rasterizer This node transforms a “pose set” into a map. This node is very helpful for visualization/preview purposes in the graph. Example Use Case: Using the distance transform to get the distances to the closest pose. OSM Geometry Rasterizer Returns a “black and white” image of where the queried entities are. The results can either be drawn filled or as an outline. Info: Geometry that is not closed (roads) but drawn with the filled style will result in odd looking shapes. Example Use Case: Using the park query to only allow spawning of trees in this permitted area and feeding it into a grass texture layer. Road Network Mask ➞ Visit the in depth page Blend Texture At Pose Heights Blends a given texture at the positions of a set of poses with the input map and returns the blended map. Height and Alpha channel can be chosen from the source texture. A scale factor is multiplied with the xz-scale as well the height of the blended pattern. Note: The Height channel is added to the poses' y-positions and then blended with the input map's height data. Example Use Case: Used to blend patterns from a texture with an existing terrain map. The texture can incorporate a channel for actual height values as well as a channel for alpha blending values. Map Modifiers Map operators are a set of nodes used to modify “Maps” in different ways. Blur Adds blur to the “black and white” image. Example Use Case: Smoothing edges to let values fade into each other. Convolute A custom convolution. https://en.wikipedia.org/wiki/Convolution Example Use Case: Using a Sobel filter kernel to highlight edges. https://en.wikipedia.org/wiki/Sobel_operator Distance Transform ➞ Visit the in depth page Math Feel free to explore the possibilities! Remap ➞ Visit the in depth page Normal Projection Evaluator Computes the dot-product between the given normal and the derived input image at every position. Example Use Case: Evaluating how steep the slope of a hill is in order to, say, put trees on top and stones at the side of the hill. Scale Scales the map values by a given factor. Pose Set Sources Pose sets define a group of positions. They are usually used as a preprocessing step to spawners as there are several nodes to modify the poses before spawning objects based on a pose set. All these nodes generate “PoseSet” data types: Grid Poses The Grid Poses node generates an even grid of poses. OSM Poses ➞ Visit the in depth page Road Network Poses ➞ Visit the in depth page Pose Set Modifiers There are a variety of nodes to process the generated pose sets. Add Random Rotation Randomly rotates the generated poses. Add Random Translation Randomly translates/shifts the generated poses. Remove By Map Uses a map to remove/mask certain poses. Example Use Case: You want to spawn coins on the road, but based on the road width, you want to have more of them. Then you can combine it with the Grid Positions node like in the example above. Remove Close Neighbours Removes poses that are closer than the defined distance. Example Use Case: Cleaning up your poses to make them less dense. RotateTowardsGradientDirection Rotates poses depending on the gradient. Example Use Case: Rotating spawned objects toward a road. Translate Along Gradient Move poses in the direction provided by a gradient. Example Use Case: Moving spawned objects away from the road. Set Heights By Map ➞ Visit the in depth page Unify Poses The Unify Poses node fuses multiple pose sets to one. Example Use Case: Cleaning up / simplifying your graph. Portals ➞ Visit the in depth page Spawners As the name indicates, spawners are the node type to spawn prefabs and game objects in your scene based on different rules. OSM Building Spawner This spawner is dedicated to spawning buildings on places where buildings also exist in the real world. It uses the outline of a building and creates a 3D mesh with the chosen material applied. Pose Set Spawner ➞ Visit the in depth page Road Network Spawner This spawner spawns objects on all roads (note: roads can also be pedestrian walkways or similar). Speciality for Road Network Spawner – Geometry Bending By adding the component RouteGeometryBender to a prefab, it is possible to bend the geometry with the route spline. As the bending target, a MeshCollider and/or MeshFilter can be added to the component. The bending resolution determines the sample count on the spline. In order to get a satisfying result, an evenly tessellated mesh with a sufficient resolution should be provided. Example Use Case: Generating tunnels or trenches to drive or fly through spaces in VR. Grid Spawner ➞ Visit the in depth page Unconstrained Grid Spawner Allows spawning objects in a grid, like the Grid Spawner, but is not restricted by the Extents of the Elastic Scene Generator. Note Due to the Spawner being able to spawn objects in areas without Map data, the Spawner does not allow graph data injection. OSM Spawner The OSMSpawner spawns objects based on OSM/Overpass queries. Collision Solver To keep objects from intersecting with each other, you can add a CollisionSolver component to the prefab of the game object that you want to place. Note that intersections can be detected only with game objects that have some sort of collider attached to them. The terrain itself is excluded from all intersections. The physics engine then takes care of shifting objects over a certain number of iterations. Elastic Scene Definition ➞ Visit the in depth page Texture Layer ➞ Visit the in depth page Data Provider Nodes Data Provider nodes allow the user to select one element of a list using different approaches. Currently the ElasticSDK offers the following nodes. Pick Prefab Randomly ➞ Visit the in depth page Pick Prefab by Map ➞ Visit the in depth page"
  },
  "manual/Procedural-Generation/Nodes/BlendTextureAtPoseHeights.html": {
    "href": "manual/Procedural-Generation/Nodes/BlendTextureAtPoseHeights.html",
    "title": "Blend Texture at Pose Heights | ElasticSDK Documentation",
    "keywords": "Blend Texture at Pose Heights Overview A Blend Texture At Pose Heights node stamps a given texture at every passed Pose. The texture defines both the height that is written into the Map and how it blends with the Input Map height. An additional offset is added according to the Pose height. Detailed Explanation Every Pose within the given Pose Set defines a place and rotation where to stamp the defined Texture. The Scale parameter defines the size of the stamp area (in x and z direction) centered around the Pose. The texture channels are split into two semantics, a Height semantic to define the texture's height values and a Blending semantic to define the texture's blend values according to the chosen Channel Semantics. The Input Map is then set to the texture's height value multiplied by Scale.y. That is, if Scale.y is set to 50, the whole range of the texture's height value is remapped to values between 0 and 50 height units, i.e. [0, 50]. The Pose's y-component adds another offset to the height. For example, a Pose p1 from the Pose Set with a p1.Position.Y value of 100 lifts the range to [100, 150] while a second Pose p2 with p2.Position.Y value of -200 drops the range down to [-200, -150]. The Blending semantic eventually defines how the resulting height is lerped with the Input Map value: At places where the blend value is 0, the Input Map's height is remained while a value of 1 overwrites the Input Map value all-out. A blend value of 0.5 sets the resulting height to the exact middle height between the remapped texture sample and the Input Map's height. The GrayScaleConversion enum defines how float values between 0 and 1 are derived from the texture for each Channel Semantic. The options to choose from are: Name Description R The red channel of the texture. G The green channel of the texture. B The blue channel of the texture. A The alpha channel of the texture. RGBAverage The average of red, green and blue computed as (r+g+b)/3. RGBToLuminance The brightness according to the color perception of the human eye. ConstantOne The value 1 at every pixel. ConstantZero The value 0 at every pixel. Parameters Inputs Name Type Description Input Map The Map to blend with the texture stamps. Pose Set PoseSet The initial set of poses to define place, rotation and height offset of the stamp. Controls Name Type Description Texture Texture The texture to stamp at every pose. Scale Vector3 The scale of the stamped texture. X and Z component scale the extents of the texture while the Y component scales the Height value. Height GrayScaleConversion Defines how the Height is retrieved in the texture. Blending GrayScaleConversion Defines how the Blending factor is retrieved in the texture. Use Cases Pre-Defined Mountain Shapes Although mountains can easily be generated with Distance Transform and Perlin Noise nodes, distinctive mountain shapes can rather be achieved by using a heightmap sample via a Blend Texture At Pose Heights node. The poses to define the place should have a sufficient distance to the road. Therefore, we move Grid Poses using Translate Along Gradient and Remove Close Neighbors of those that appear too close to each other. Object Foundation The same poses can be used for both spawning prefabs via a Pose Set Spawner and flattening the ground underneath using Blend Texture At Pose Heights. A foundation texture that resembles the silhouette of the prefab makes a good foundation for the object. With the pose height snapped to the height map using Set Heights By Map, it is also possible to carve plateaus into mountains - a perfect place for a fortress."
  },
  "manual/Procedural-Generation/Nodes/DistanceTransform.html": {
    "href": "manual/Procedural-Generation/Nodes/DistanceTransform.html",
    "title": "Distance Transform | ElasticSDK Documentation",
    "keywords": "Distance Transform Overview The Distance Transform node generates a map where each value represents a distance. Detailed Explanation The value of each pixel is the distance measured between its position and the closest pixel over a threshold in the input image. That is, the two dimensional euclidean distance measured in meters. Parameters Inputs Name Type Description Input Map Input map that is used together with the threshold for the mask to which the distance is calculated. Controls Name Type Description Threshold float Values below or equal to this threshold are used for the mask. The values above this threshold are set to the closest distance to the masked area. Invert bool Checking this box will only generate the distances for the pixels inside the masked area. Signed Distance bool Generates negative distances when inside the masked area (or outside when inverted is selected). Border Distance bool Additionally to the masked area use the distance to the borders when calculating the values. Fade With Previous Input bool When generating new areas generate smoother transitions but with incorrect distance values. Use Cases Distance transform for spawning This example shows how the Distance Transform node can assist in spawning objects. Imagine having a prefab with a radius of 10 meters and we want to make sure it is not overlapping with the road to avoid collisions with the player. We can achieve this, by first performing a distance transform with the road network as the input. Then, we plug the output of the Distance Transform into the Grid Spawners permitted area field. Using the permitted area threshold of 15, we make sure that our object is spawned at least 10 meters away from the road and leaves and add an additional 5 meters for potential localization inaccuracies. Further Reading Wikipedia - Distance Transform"
  },
  "manual/Procedural-Generation/Nodes/ElasticSceneDefinition.html": {
    "href": "manual/Procedural-Generation/Nodes/ElasticSceneDefinition.html",
    "title": "Elastic Scene Definition | ElasticSDK Documentation",
    "keywords": "Elastic Scene Definition Overview The Elastic Scene Definition node functions as the output node of the graph and will be evaluated to fill the world. Detailed Explanation This node is evaluated by the Elastic Scene Generator and can be used to generate textured terrain using the heightmap and texture layer input but also to spawn objects. Additionally the global graph output offers named ports that can be queried from the Elastic Scene Generator. For more details on this read the how-to guide on graph data access. Parameters Inputs Name Type Description Heightmap Map One map texture whose values are interpreted as height of the terrain. Texture Layers TextureLayer Multiple texture layers that will be painted onto the terrain. Spawners Spawner Multiple spawners that spawn their objects based on their configuration. Global Graph Output - Node output that can be queried from scripts outside the graph. Use Cases This example shows a simple scene with a flat and textured terrain, how objects can be spawned and exposes the information on whether a certain world position contains a building in the real world. Further Reading Unity's Terrain Layer System Graph Data Access"
  },
  "manual/Procedural-Generation/Nodes/GridSpawner.html": {
    "href": "manual/Procedural-Generation/Nodes/GridSpawner.html",
    "title": "Grid Spawner | ElasticSDK Documentation",
    "keywords": "Grid Spawner Overview The Grid Spawner offers to spawn prefabs in a grid. Detailed Explanation The Grid Spawner is a powerful spawner that allows spawning objects in a grid with additional customization. We can choose where to spawn objects using the permitted area threshold, or add randomness to the transform of the spawned prefab. The difference between using this node and a Pose Set Spawner with the Grid Poses node is, that this node can perform some optimizations. This makes it the better choice when the objects are spawned in a grid and other pose based features are not needed. Parameters Inputs Name Type Description Heightmap Map Provides the heights for the spawned prefabs. Permitted Area Map Provides the values for the permitted area threshold. Controls Name Type Description Extents float The extents of the square region around the player in which objects will be spawned. Permitted Area Threshold float Spawn positions will be discarded if the value in the permitted area map is below this threshold. Grid Cell Size float The size of the individual square cells inside the Extents. Prefab GameObject The prefab that will be spawned at the input poses. Jittering bool Add jittering to the spawn position to break the pattern. Scale Interval Set the scale of the spawned object to a random value inside the interval. Translate Y Interval Additionally translate the spawned object with a random value inside the interval along the Y axis. Rotate X Interval Rotate the spawned object with a random value inside the interval around the X axis. Rotate Y Interval Rotate the spawned object with a random value inside the interval around the Y axis. Rotate Z Interval Rotate the spawned object with a random value inside the interval around the Z axis. Use Cases Spawning with permitted area and a heightmap This spawner will set the positions of the spawned prefab to the height of the Perlin noise. Since we use the permitted area feature we only allow objects to be spawned inside the area of real world buildings. Further Reading Learn how spawners can pass data to prefabs."
  },
  "manual/Procedural-Generation/Nodes/OSMPoses.html": {
    "href": "manual/Procedural-Generation/Nodes/OSMPoses.html",
    "title": "OSM Poses | ElasticSDK Documentation",
    "keywords": "OSM Poses Overview The OSM Poses node provides the poses returned by an OSM query. Detailed Explanation This node allows to obtain information about the surrounding world based on OpenStreetMap data. To find out how objects are tagged we can start by exploring the tag cloud or get more general information on tags here. The queries in this node need to return positions. For elements that return an area we can calculate the center by selecting Way Center. Otherwise the returned type is a node, whose position can be used directly. An in-depth look on this topic can be found in the How-To section on OSM Queries. Parameters Controls Name Type Description Queries OSM Query Queries that return positions for this node. All Queries will be combined. Max Poses Per Tile int The maximum number of poses this node will add to a tile. Use Cases Spawning objects at certain real world positions This example shows how we can use the real world information of cafes and use it to place objects in the game world. A quick lookup on cafes on the OpenStreetMap wiki page shows that even though most cafes are tagged as nodes, there is also the option to tag them using an area. This is why this example uses two queries: one with node and the other way center as the return value of the query. Further Reading Overpass-Turbo for query exploration OpenStreetMap Wiki on Tags Overpass API Basics"
  },
  "manual/Procedural-Generation/Nodes/PerlinNoise.html": {
    "href": "manual/Procedural-Generation/Nodes/PerlinNoise.html",
    "title": "Perlin Noise | ElasticSDK Documentation",
    "keywords": "Perlin Noise Overview The Perlin Noise node generates a Map where each value represents a sample from a smooth, continuous gradient noise. It is a good candidate to visual natural phenomena, like mountains. Detailed Explanation Technically speaking, the Perlin noise function computes amplitudes of a random but also smooth noise signal. The most important properties of this function are its smooth, interpolated values and its self-similarity which make it a good candidate to visual natural phenomena. The value of each pixel on the resulting Map is a sampled amplitude from the continuous Perlin noise function. The noise signal is sampled along the vertical and horizontal coordinates of the Map. The coordinates represent a point in time of the noise signal. The frequency of the noise signal is defined as 1 / Size, while the Size parameter, in a scientific context, would be referred to as the period of the signal. Tip Use the Size parameter to adjust the frequency of the noise signal. Effectively this will capture a broader area of the 2D Perlin noise function. Note The 2D noise output is seamlessly tileable. Parameters Controls Name Type Description Min float The global minimum amplitude value of the generated noise signal. Local minimum values can be bigger. Max float The global maximum amplitude value of the generated noise signal. Local maximum values can be smaller. Size float The size of the perlin noise grid in meters. Use Cases Shaping Terrain This example shows how the Perlin Noise node can be multiplied with a Distance Transform node to generate a terrain that already provides a rather natural look. Finding the right Min, Max and Size values for the Perlin noise, is essential to generate a variety of convincing procedural terrain shapes. Further Reading Wikipedia - Perlin noise"
  },
  "manual/Procedural-Generation/Nodes/PickPrefabByMap.html": {
    "href": "manual/Procedural-Generation/Nodes/PickPrefabByMap.html",
    "title": "Pick Prefab by Map | ElasticSDK Documentation",
    "keywords": "Pick Prefab by Map Overview The Pick Prefab by Map node selects the prefab from the list with the highest map value. Detailed Explanation The idea of this node is to provide Prefabs to other nodes. Which Prefab of the list will be returned is determined by the Map with the highest value at the location where the node is queried. This node could be used in cases where different regions should spawn different objects. For objects with the same map value an option is selected at random. Parameters Controls Name Type Description Provider Data List of elements with Prefab and Map The list of Prefabs and their associated Maps from which an element will be selected. Use Cases Basic terrain texturing This example shows a simple Spawner setup that spawns different object variants on a grid. Using different object variations can help to break up the repetition and thus improve the feel of the game. In this example we use the output of the OSM Geometry Rasterizer to define a special region and depending on whether we are in the area we select the special object."
  },
  "manual/Procedural-Generation/Nodes/PickPrefabRandomly.html": {
    "href": "manual/Procedural-Generation/Nodes/PickPrefabRandomly.html",
    "title": "Pick Prefab Randomly | ElasticSDK Documentation",
    "keywords": "Pick Prefab Randomly Overview The Pick Prefab Randomly node selects a prefab from the list based on chance, with elements having a higher weight being more likely to be selected. Detailed Explanation The idea of this node is to provide Prefabs to other nodes. Which Prefab of the list will be returned is generally random but the chance can be influenced by the weight a Prefab is given. The higher the weight, the likelier the Prefab is getting selected. To be precise, the chance is equal to the weight of the Prefab divided by the sum of all weights. While the selection process is using weighted randomness, the same position will return the same Prefab to keep the scene consistent. This can be used in cases where some elements should be spawned more often than others or simply to spawn different variations with the same chance. Parameters Controls Name Type Description Provider Data List of elements with Prefab and Weight The list of Prefabs and their associated weights from which an element will be selected. Use Cases Spawning Object Variants This example shows a simple spawner setup that spawns different object variants on a grid. Using different object variations can help to break up the repetition and thus improve the feel of the game. In this example we made the first three options equally likely to be spawned and the last option more rare by giving it a lower weight."
  },
  "manual/Procedural-Generation/Nodes/Portals.html": {
    "href": "manual/Procedural-Generation/Nodes/Portals.html",
    "title": "Portals | ElasticSDK Documentation",
    "keywords": "Portals Overview The Portal nodes enable re-use and improve structuring of graph nodes. Detailed Explanation When using Portal nodes, we always need an input and output node. The Input Portal accepts a node as input, which we can name and use in an Output Portal of the same type. We can even have multiple Output Portals that reference the same Input Portal. Additionally these Portal nodes can also be used across different graphs to enable reusability. Parameters (Input Portal) Inputs Name Type Description Input Type of the Portal Provides the values to operate on. Controls Name Type Description Name string The name that this Portal will be referenced by. Parameters (Output Portal) Controls Name Type Description Elastic Node Graph ElasticNodeGraph The Input Portal's graph. Input Enum The name of the input portal in the referenced graph. Use Cases Re-use of previously generated output This example shows that multiple Output Portal nodes can be created from the same Input Portal."
  },
  "manual/Procedural-Generation/Nodes/PoseClusterPoissonDisc.html": {
    "href": "manual/Procedural-Generation/Nodes/PoseClusterPoissonDisc.html",
    "title": "Pose Cluster Poisson Disc | ElasticSDK Documentation",
    "keywords": "Pose Cluster Poisson Disc Overview The Pose Cluster Poisson Disc node samples a cluster of poses around an initial pose so that they are tightly packed but not closer than a minimum distance. Detailed Explanation Procedural generation often requires that we place objects at certain minimum distances from each other to prevent overlaps. An example for this could be trees or houses that should be distributed across an area in a natural manner. To achieve this, we introduce Poisson Disc Sampling. A Poisson Disc Sampling algorithm at its heart uses a uniform random function to sample candidates for a cluster but implements an additional constraint, that is, a minimum distance that each candidate has to keep to its neighbors. Using the minimum distance constraint we can still take advantage of the randomly generated candidates but reject the ones that are too close to each other. This ultimately gives the natural distribution we want to achieve. This unique property of our sampling function can be summarized as a blue noise distribution. It is important to note here that the underlying random generator is seeded with hashed geographical coordinates to provide a deterministic behavior (i.e. passing the same position with the same set of parameters will always result in the same cluster). The Distribution curve parameter was additionally implemented to extend the basic Poisson Disc Sampling algorithm with a user-defined density function. While the x-axis displays the normalized distance [0..1] from the cluster's center to its edge, the y-axis shows the relative density at that distance. Using this parameter the user can break up the uniform shape of the cluster and introduce more variance. Overlapping clusters will not fulfill the minimum distance constraint. Parameters Inputs Name Type Description Input PoseSet The initial set of poses to sample the cluster poses from. Controls Name Type Description Min Distance float The minimum distance that clustered poses will have towards one another. Cluster Radius float The radius of the generated pose cluster (i.e the max. distance of a pose towards the center). Distribution AnimationCurve Curve that determines the distribution of the poses over the normalized distance inside of the generated cluster. Together with the MinDistance parameter, this will determine the cluster's local densities. KeepInitialPose bool Whether the initial pose the cluster was created from will not be removed and stay at the origin. LookAtCenter bool Whether the newly generated cluster poses will be rotated towards the cluster's origin. Use Cases Tree Cluster For this example use case we want to spawn a bunch of tree prefabs in a cluster. To keep the setup simple we generate an initial set of poses from a Grid Poses node and use the output as input for the Pose Cluster Poisson Disc node to sample our clusters from. Next we set the Min Distance parameter. This distance should not be smaller than the extents of our spawned objects, so that they do not overlap. After that we can change the Radius and observe how the poses distribute over the changing area of the cluster. Lastly changing the Distribution curve parameter, with respect to the Min Distance, will determine the local densities of our cluster. Note how in the image above we effectively create a center cluster of trees and a ring shaped outer cluster all in one go. Further Reading Fast Poisson Disk Sampling by Robert Bridson Supersampling Wikipedia page Jason Davie's Poisson-Disc Sampling interactive examples and further experiments"
  },
  "manual/Procedural-Generation/Nodes/PoseClusterRegularPolygon.html": {
    "href": "manual/Procedural-Generation/Nodes/PoseClusterRegularPolygon.html",
    "title": "Pose Cluster Regular Polygon | ElasticSDK Documentation",
    "keywords": "Pose Cluster Regular Polygon Overview The Pose Cluster Regular Polygon node samples a cluster of poses around an initial pose in the shape of a regular polygon. Detailed Explanation The basic idea behind this node is to procedurally sample a cluster of newly generated poses around an initial set of poses. The shape that the cluster takes is restricted by the properties of a regular polygon, so equal sides and inner angles. These properties are adjusted by the parameters the user sets. Note that the initial set of poses is discarded. An arbitrary set of initial poses can be used to sample clusters from. Because of this and the fact that we will most likely use the newly generated poses to spawn game objects that should not overlap, we curated the Min Distance parameter as the first one. This parameter defines the minimum distance that the clustered poses will have towards their neighbors. Min Distance has a direct influence on the cluster density. The Corners parameter is used to control the very shape of the regular polygon (e.g. 3 corners result in a triangle, 4 in a square..). To control the size of the cluster, that is, the distance that each corner pose will have towards the center, we set a Cluster Radius. Note here, that we will find a button at the bottom of the node's parameter stack called Fit Radius. The button is used to find the next closest radius that results in each pose's distance towards its neighbors being equal to the set Min Distance parameter. This can come in handy if you want pack spawned objects tightly together. Overlapping clusters will not fulfill the minimum distance constraint. Parameters Inputs Name Type Description Input PoseSet The initial set of poses to sample the cluster poses from. Controls Name Type Description Min Distance float The minimum distance that clustered poses will have towards one another. Corners int The number of corners of the regular polygon. Cluster Radius float The distance between the corners and the cluster center. Corner Poses bool States whether to generate poses at the corners. Use Cases Spawning Objects In Clusters In this example we use the Pose Cluster Regular Polygon node twice to spawn pentagonal shapes that are made out of wall pieces and corner pieces. The first step for the proper parameterization of the node is to set the Min Distance according to the extents and the pivot of the mesh that we want to spawn at the generated pose positions. Our wall pieces are 20 meters wide and the pivot is in the center, so we set the minimum distance to 10 meters. Corners set to 5 will create the pentagon shape. To realize a wall without any gaps we choose a rough estimate of how large the Cluster Radius is supposed to be and then hit the Fit Cluster button. Uncheck Corner Poses to get rid of the shape's corners. For the second instance of the node we choose the same Corners and Cluster Radius parameter, keep the corner poses and finally increase the Min Distance parameter until we only see corner poses left. We do not want to click the button this time. Further Reading Regular Polygon properties"
  },
  "manual/Procedural-Generation/Nodes/PoseSetSpawner.html": {
    "href": "manual/Procedural-Generation/Nodes/PoseSetSpawner.html",
    "title": "Pose Set Spawner | ElasticSDK Documentation",
    "keywords": "Pose Set Spawner Overview The Pose Set Spawner node offers spawning at input poses. Detailed Explanation In comparison to other spawners, this very simple spawner only expects a set of poses. These poses can be generated and modified using other pose nodes and thus offer a lot of flexibility. Similar to other spawners we can customize the range in which the spawner will operate. Parameters Inputs Name Type Description Pose Set PoseSet Provides the poses with which to spawn the prefabs. Controls Name Type Description Extents float The extents of the square region around the player in which objects will be spawned. Prefab GameObject The prefab that will be spawned at the input poses. Use Cases Spawning away from roads and on top of the terrain A common set-up for the Pose Set Spawner is to spawn prefabs that are not on the road and use the height from the heightmap. To ensure a minimum distance to the road we use the Road Network Mask and a Distance Transform node in combination with the Remove By Map node and feed it into the Pose Set Spawner. To make sure that the spawned objects are always on top of the terrain, we can use the Set Heights By Map node to push them up depending on the heightmap."
  },
  "manual/Procedural-Generation/Nodes/Remap.html": {
    "href": "manual/Procedural-Generation/Nodes/Remap.html",
    "title": "Remap | ElasticSDK Documentation",
    "keywords": "Remap Overview The Remap node converts map values within the input range into corresponding values in the output range. Detailed Explanation First, the value of each pixel is set in relation to the input range, where 0% is the minimum input value and 100% is the maximum input value. By default, the resulting percentage is the proportion within the input range. Each pixel's percentage is then applied to the output range, where 0% is the minimum output value and 100% is the maximum output value. The exact output value corresponds to the output range at that ratio. Values outside of the input and output range are clamped. As mentioned, the mapping from the input to the output range is proportional by default. This can be changed by defining a mapping curve. Here, the x-axis between 0 and 1 corresponds to the input range while the y-axis between 0 and 1 corresponds to the output range. Using the curve, various artistic effects can be achieved like smooth gradients, hard cuts, ripple effects or combinations thereof. Parameters Inputs Name Type Description Input Map Provides the values that will be remapped. Controls Name Type Description Input Min float The minimum input value smaller values are clamped to. Input Max float The maximum input value larger values are clamped to. Output Min float The minimum output result to which values at y = 0 on the curve are scaled and clamped to. Output Max float The maximum output result to which values at y = 1 on the curve are scaled and clamped to. Curve AnimationCurve The mapping curve between the input and output values. The min-max-ranges are scaled to values between 0 and 1. Use Cases Remapping Terrain The Remap node is very versatile. For example, it can be used to remap the result of a Distance Transform in order to generate a plateau to spawn objects on."
  },
  "manual/Procedural-Generation/Nodes/RoadNetworkMask.html": {
    "href": "manual/Procedural-Generation/Nodes/RoadNetworkMask.html",
    "title": "Road Network Mask | ElasticSDK Documentation",
    "keywords": "Road Network Mask Overview The Road Network Mask node generates a map where all white pixels represent either a street or a parking lot. Detailed Explanation We use OpenStreetMap data to generate this mask containing the roads and parking lots. We generally do not include small service ways. However, to avoid gaps between the road network and parking lots we do add service ways connected to parking lots to the road network. Being on a road or parking lot means that the mask contains a 1 at this location and the opposite is represented by a 0. Settings While the node itself doesn't feature any parameters we can still configure this node in the global settings: Project Settings > holoride > Road Network Mask. Name Type Description Lane Width float The default width of each road lane. Road Side Width float The default width added to both sides of the road. Default Lane Count int The default lane count if not provided by the map service. Use Map Tiles bool Use downloaded map tile images instead of offline rendered images that have higher quality. Tile Zoom Level int When using the map tiles this defines the size/zoom of the map tiles. Use Cases Distance Transform Example One common use case for this node is in combination with the Distance Transform node. This can be used in a lot of cases including feeding it into Texture Layers for texturing or spawning objects a certain distance away from the road network."
  },
  "manual/Procedural-Generation/Nodes/RoadNetworkPoses.html": {
    "href": "manual/Procedural-Generation/Nodes/RoadNetworkPoses.html",
    "title": "Road Network Poses | ElasticSDK Documentation",
    "keywords": "Road Network Poses Overview The Road Network Poses node can spawn poses at intersections and on the road at specified intervals. Parameters Inputs Name Type Description Height Map Map Provides the height map used for looking up the height for the poses. Controls Name Type Description Create Road Poses bool Whether to enable pose generation on roads. Create Junction Poses bool Whether to enable pose generation at junctions. Road Pose Distance float Distance between poses on the road. Junction Offset Range Interval Defines the minimum and maximum distance between the junction center and the next attached road piece. The smaller an angle between two roads is, the further away the first pose is pushed along the road in order to avoid collapsing geometry. Place At Edges bool States whether to create poses at both road edges instead of a single line at the center. Road Width Scale float In the case Place At Edges is selected the Road Width Scale is the factor the road width is multiplied with. Use Cases Area around intersections An interesting application of this node could be to texture intersections in the real world differently to other parts of the world. For this we get the poses only at the intersections, rasterize them and use the Distance Transform node to define the area we want to highlight."
  },
  "manual/Procedural-Generation/Nodes/SetHeightsByMap.html": {
    "href": "manual/Procedural-Generation/Nodes/SetHeightsByMap.html",
    "title": "Set Heights by Map | ElasticSDK Documentation",
    "keywords": "Set Heights by Map Overview The Set Heights by Map node returns the input poses with the height set to the value of the heightmap input. Parameters Inputs Name Type Description Height Map Map Provides the heightmap used for looking up the height for the poses. Pose Set PoseSet Provides the poses that will have their height updated. Use Cases Moving the poses on top of the terrain This example shows how we can use this node to spawn object on a grid, making sure the objects are on top of the terrain represented by the Perlin noise node."
  },
  "manual/Procedural-Generation/Nodes/TextureLayer.html": {
    "href": "manual/Procedural-Generation/Nodes/TextureLayer.html",
    "title": "Texture Layer | ElasticSDK Documentation",
    "keywords": "Texture Layer Overview The Texture Layer node defines the textures and weights used when painting the terrain. Detailed Explanation To paint the terrain we need to provide the textures. Under the hood we use Unity's terrain system which uses terrain layers that make use of these textures. Additionally we need to define how much each texture layer contributes at each location which is defined by the weight parameter of the node. Parameters Inputs Name Type Description Texture Weight Map The weight for the terrain layer painting. Controls Name Type Description Terrain Layer Terrain Layer The terrain layer to paint onto the terrain. Use Cases Basic terrain texturing This example shows a good starting point for texturing the game world. We see that we create a smooth transition from road to the environment by remapping a Distance Transform from the Road Network Mask. We make sure this result is between 0 and 1 and feed this and the opposite into two different Texture Layers to texture the game world. Further Reading Unity Documentation on Terrain Layers"
  },
  "manual/Quick-Start.html": {
    "href": "manual/Quick-Start.html",
    "title": "Elastic SDK Setup | ElasticSDK Documentation",
    "keywords": "Elastic SDK Setup System Requirements Tested Unity versions: 6000.0.25f1 Stable internet connection Get the Elastic SDK To download the Elastic SDK, you have to use Unity’s built-in package manager (UPM). You will need to add our registry for this, as described below. As a quick start you can skip these steps by using our Unity Template Project on GitHub. Step 1 Add the necessary registries as a scoped registry in the Unity Package Manager. To do this, open Unity and navigate to Project Settings > Package Manager and add the following scoped registry: Label Entry Name holoride URL https://npm.pkg.holoride.com/ Scope(s) com.holoride Add a new line with 'plus' button to insert the scopes separately Be sure there is no white spaces at the end of any of the fields Since we have a dependency to xNode and Unitask we also need to add these dependencies. We can do this via OpenUPM which is another scoped registry: Label Entry Name OpenUPM URL https://package.openupm.com Scope(s) com.github.siccity.xnode com.cysharp.unitask Step 2 Now you can install the Elastic SDK from the Package Manager window. Choose Packages: My Registries in the top bar. The Elastic SDK can now be selected in the list and be installed by clicking the button on the bottom. Enable your Unity project To enable your Unity Project to be used with the Elastic SDK, you need to link a holoride manifest file (HMF) specifically created for your project. Please contact us at esdk-support@holoride.com to get in touch. Validate Your Project After successfully importing the ElasticSDK package with all its dependencies, see the holoride Project Validation window to set up your project and fix all points on the list that show an exclamation mark (Check the Inspector when clicking Select). You can also find it the main menu under holoride > Project Validation, if you accidentally closed it. You can update the Elastic SDK from the Unity Package Manager window whenever a new version is available."
  },
  "manual/Quick-Start/Build-Setup.html": {
    "href": "manual/Quick-Start/Build-Setup.html",
    "title": "Build Setup | ElasticSDK Documentation",
    "keywords": "Build Setup Holoride currently supports devices that run Android. This step will walk you through additional setup steps required when building with the Elastic SDK for Android. Changing the build target In Unity's File > Build Settings window, under Platform select Android, hit the Switch Platform button and wait until the switch to Android is complete. Afterwards, the holoride validation window will notify you about further required setup steps. XR Platform setup Install the XR Plugin Management by pressing the button under Project Settings > XR Plugin Management. If the Plug-in provider is not listed, add the corresponding SDK as described by the respective HMD vendor's user manual. If no SDK exists, choose Unity Mock HMD instead. Adjust Project Settings and Scene Setup Further adjustments regarding the compile process have to be applied by pressing the corresponding Fix buttons in the validation window, or by changing them manually under Project Settings > Player > Other Settings. There may also be some changes that have to be made in the scene, such as on the XR Camera Rig. These may also be applied by pressing the corresponding Fix buttons in the validation window, or by changing them manually on the respective components. Setup the XRRig If necessary move the Main Camera to the root of the hierarchy and select it. Navigate to and click GameObject > XR > Convert Main Camera To XR Rig. Move the converted XRRig to the Holoride Player > GlobalRotation child. Change the Requested Tracking of the Camera Offset component into Floor. Note that the name of this component and field might have changed with later XR Plugin versions into Tracking Origin. Search for the Tracking Pose Driver component on the camera child and change the *Tracking Type to Rotation Only."
  },
  "manual/Quick-Start/Creating-a-Simple-Scene.html": {
    "href": "manual/Quick-Start/Creating-a-Simple-Scene.html",
    "title": "Creating a Simple Scene | ElasticSDK Documentation",
    "keywords": "Creating a Simple Scene Create a new scene and name it as you wish Add a holoride Player game object by right clicking in the hierarchy and navigating to holoride > Player Place the Main Camera into the LocalRotation object within the Holoride Player and zero out the camera transforms except for the scale. If the sample scene comes with a Simple Camera Controller component attached to the camera, remove it. Add an Elastic Scene Generator game object by right clicking in the scene hierarchy and selecting holoride > Elastic Scene Generator Create a Elastic Graph asset in the assets folder where you like by right clicking in the assets folder and selecting Create > holoride > Elastic Graph Right click on the graph and rename it as you like Double click the Elastic Graph asset just created to open the Elastic Graph window Within the Elastic Graph window, press the spacebar or right-click and add the following nodes and connect them in the order shown with the same parameters Select the Elastic Scene Generator and fill in the Scene Definition reference by expanding the Elastic Graph asset and dragging the Elastic Scene Definition into the Scene Definition field Enter play mode to see a simple terrain in the game view"
  },
  "manual/Quick-Start/Graph-Overview.html": {
    "href": "manual/Quick-Start/Graph-Overview.html",
    "title": "Graph Overview | ElasticSDK Documentation",
    "keywords": "Graph Overview Using the project folder’s context menu (Create > holoride > Elastic Graph), a new graph can be instantiated. Nodes can be added by pressing the space bar or using the right-click context menu on the graph window’s background. Same-colored ports can be connected by dragging the mouse from the output to the input port. Small exclamation marks next to node ports depict a missing mandatory input. It is important to understand that the environment the Elastic Graph produces is always based on an initial set of data, which is then modified based on functions the user defines in the graph system. There are two major types of source nodes, to generate initial data sets, and associated modifier nodes, to alter these data sets: Map nodes, which can be seen as 2D grayscale textures, and Pose Set nodes, which represent containers of Position-Rotation tuples and serve as information for where to spawn objects. Other nodes such as Spawners will use the modified data sets to define how engine related content like game objects is created at runtime. Tip Every node in the Elastic Graph system can be renamed to your liking via a right-click context menu. Elastic Scene Definition The Elastic Scene Definition is the core node of every Elastic Graph. This is where all the data lines end. Ultimately it is used to communicate the output of the graph system towards the runtime pipeline of the Elastic Scene Generator component. Important The Elastic Scene Definition asset has to be referenced on the Elastic Scene Generator component. Using the Graph in the Scene The Elastic Scene Generator is the central component to execute an Elastic Graph at playtime. It will update the scene as the Generation Origin moves and is responsible for terrain generation. Terrain In order to keep things procedural, the terrain’s appearance can be modeled by using map nodes in contrast to traditional manual terrain painting. Maps can contain any float value and therefore be used to define the heights and texture weights (aka control texture) of a Unity Terrain. The Elastic SDK utilizes Unity’s default Terrain Layer assets referenced by Texture Layer nodes. The heightmap can also be used to determine the spawn height of objects that should spawn on the terrain surface. Settings The Graph Settings window can be accessed from the top-left corner of the graph window. It contains options related to the preview functionality and the processing state of the nodes, which is indicated by flashing when enabled. The WorldExtents, FilterResolution, and Location are independent from the scene the graph is used in. If an Elastic Scene Generator is using an opened graph, the previews will be replaced by the actual buffers that are used during play mode."
  },
  "manual/System-Information.html": {
    "href": "manual/System-Information.html",
    "title": "System Information | ElasticSDK Documentation",
    "keywords": "System Information Architecture The holoride software stack is made up of different parts, which are visualized in the image below: Knowing how the key components work together helps understand the system holistically. holoride Backend The holoride backend manages credentials of end users. A user must be logged into their active user account in the holoride app to be able to play holoride experiences. The connection to the holoride backend is established by the holoride app. holoride App The holoride app acts as a central hub to enter the holoride ecosystem. The user has to be logged into the active holoride account in the holoride app to use holoride-enabled experiences. The holoride app also bundles the holoride service. holoride Service The holoride service handles connections to the holoride DevKit as well as to supported vehicle brands. It connects to games/experiences running the holoride Elastic SDK and provides all the necessary data from the holoride DevKit / the vehicle. Elastic SDK The Elastic SDK receives data from the holoride service and is our engine for elastic content generation. Equipped with an easy-to-use node graph, it is a powerful toolset that enables content creators to procedurally generate experiences based on vehicle and map data. It connects to the holoride maps service that provides map information on the go. holoride Map Server Our holoride map server provides map information based on the Open Street Maps database. It provides tile-based information as well as Overpass/POI information to the holoride Elastic SDK. holoride DevKit / Supported Vehicle The holoride DevKit and supported vehicle brands provide all necessary information to ensure smooth reflection of the vehicle movement in the holoride Elastic SDK."
  },
  "manual/System-Information/Legal-Information.html": {
    "href": "manual/System-Information/Legal-Information.html",
    "title": "Additional Legal Information Elastic SDK | ElasticSDK Documentation",
    "keywords": "Additional Legal Information Elastic SDK Open Source Components The Elastic SDK is using the following Open Source Components xNode MIT License Copyright (c) 2017 Thor Brigsted Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. NoiseShader Noise Shader Library for Unity - https://github.com/keijiro/NoiseShader Original work (webgl-noise) Copyright (C) 2011 Stefan Gustavson Translation and modification was made by Keijiro Takahashi. This shader is based on the webgl-noise GLSL shader. For further details of the original shader, please see the following description from the original source code. GLSL textureless classic 3D noise \"cnoise\", with an RSL-style periodic variant \"pnoise\". Author: Stefan Gustavson (stefan.gustavson@liu.se) Version: 2011-10-11 Many thanks to Ian McEwan of Ashima Arts for the ideas for permutation and gradient selection. Copyright (c) 2011 Stefan Gustavson. All rights reserved. Distributed under the MIT license. https://github.com/ashima/webgl-noise Copyright (C) 2011 by Ashima Arts (Simplex noise) Copyright (C) 2011-2016 by Stefan Gustavson (Classic noise and others) Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Newtonsoft.Json The MIT License (MIT) Copyright (c) 2007 James Newton-King Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Google.Protobuf Copyright 2008 Google Inc. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Google Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Code generated by the Protocol Buffer compiler is owned by the owner of the input file used when generating it. This code is not standalone and requires a support library to be linked with it. This support library is itself covered by the above license. BouncyCastle Please note this should be read in the same way as the MIT license. Please also note this licensing model is made possible through funding from donations and the sale of support contracts. LICENSE Copyright (c) 2000 - 2021 The Legion of the Bouncy Castle Inc. (https://www.bouncycastle.org) Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Jetbrains annotations 13.0, Kotlin Stdlib 1.5.30, kotlin-android-extensions-runtime 1.5.30, kotlin-stdlib-common 1.5.30 Apache License, Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: a. You must give any other recipients of the Work or Derivative Works a copy of this License; and b. You must cause any modified files to carry prominent notices stating that You changed the files; and c. You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and d. If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Protocol Buffer Java API 3.15.5 BSD 3-clause \"New\" or \"Revised\" License Copyright (c) , All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Microsoft/dotnet 1.0.0 The MIT License Copyright (c) Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Webservices The Elastic SDK is using the following Map Services: Nominatim The Elastic SDK is using the Nominatim Webservice for Geocoding. More on Nominatim here: https://nominatim.org/ Open Street Maps The Map Data Service provided by holoride is based on Open Street Maps. Please read the our Elastic SDK License Agreement to learn more about Open Street Maps usage. More information also here: https://wiki.openstreetmap.org/wiki/Legal_FAQ"
  },
  "manual/System-Information/Localization-Events-Content.html": {
    "href": "manual/System-Information/Localization-Events-Content.html",
    "title": "| ElasticSDK Documentation",
    "keywords": "Localization Events are located on a component with the same name in the Holoride Player prefab. These events are meant to be hooks where your program flow can execute different behavior based on the different states of the real-world localization data. Setting Description DistanceToStreetUntilOffRoad The distance in meters from the street until the player is considered to be too far away from the road and the OnOffRoadMode event is triggered. FireModeEventOnStart When enabled this component will fire the localization mode event for the current state when Unity's Start method is called on this component. Event Description OnLocalizationInitialized The event which is invoked when the localization becomes available and the pivot is set. OnLocalizationNormalMode The event which is invoked when the localization is available and we are on the street (up to the road distance threshold). OnOffRoadMode This event which is invoked when the localization is available but we are not on the road and the distance to the road is larger than the threshold configured in DistanceToStreetUntilOffRoad. OnLocalizationUnavailableMode This event which is invoked when the localization is unavailable and thus the player won't move even though the vehicle in the real world might. OnErrorOccured This event which is invoked when any localization error occurs. This component handles different localization quality events and reduces them to three distinct states: Normal: This state represents good localization where everything works as expected. Off-road: This state is active when the localization is available but due to inaccuracies in localization or outdated Map data, the Player might not be on the road which the content should handle accordingly. The distance to the road until the player is considered to be \"off-road\" is adjustable and should reflect the requirements of the individual content. Unavailable: This state means that no localization information is available. Provisions should be made for the content of an experience to respond to different localization states: Since the Unavailable state does not show any movement at all, even though the vehicle may in fact be moving, it is suggested not to show any indication of false movement that occurs when the Player's localization is not present but the VR headset's IMU interprets a turning car as a head rotation. In many scenarios, this means that it is not even recommended to show the player a world . The experience should start in this mode until localization is available and Map data is ready. Caution Any experience must be designed to reflect this state at any point in time to comfort the user in those situations where valid data is not available to present an elastic environment. One suggestion is to fade out the world when this mode is activated and fade it in once another state becomes active. The other interesting state is the Off-road state where there appears to be normal localization but due to limited GPS reception (e.g. in a tunnel) the Player might be off the road. In this case the experience should make sure that the player is not colliding with any objects. How this is handled depends very much on the experience that is built and could range from unloading objects that are too close to loading a different scene. The Distance To Street Until Off Road setting for this mode makes it possible to tighten or loosen the constraints for this mode, depending on the individual content."
  },
  "manual/System-Information/Map-Services.html": {
    "href": "manual/System-Information/Map-Services.html",
    "title": "holoride Maps Service | ElasticSDK Documentation",
    "keywords": "holoride Maps Service The Elastic SDK comes with a complementary Maps Service to provide Map Tiles. These provide details of where roads are in the real world, as well as a service to provide POIs (buildings, sites, forests, etc.) using the Open Street Maps Overpass API. Open Street Maps holoride’s map service is based on Open Street Maps. When creating holoride experiences you must be aware of the limitations of the map database. Map Accuracy The map database available through the Elastic SDK has the same accuracy as maps found on standard navigation systems. This map data does not contain all the physical information known from the real world (number of lanes, the exact width of the road, etc.). This is something you have to be aware of. If you find yourself “off-road” in your VR experience, this is most likely not caused by incorrect positioning / GPS error, but by a road not being as wide as it is in the real world, for example. You must consider this when creating experiences - please plan in some spare space around the roads and choose your visual road representation carefully to provide passengers with a consistent/immersive experience. At a certain point, there’s no getting around real-world testing. It lets developers see how experiences take shape in VR while taking a holoride. Testing is simple with our DevKit and a driver, the passenger-developer can compare their efforts against real-world travel. Map Coverage Open Street Maps is a community-based database, which means it has good coverage. However, there is no guarantee that the database contains every road on the planet. Also, not every road that you will see might actually be drivable or accessible to the public. Altitude Information Our current map database does not contain altitude information. Extensive tests showed that this does not affect immersion in most cases if you design your experience on flat ground. One thing you still have to keep in mind is that the map representation of tunnels, bridges, and junctions will therefore be similar to the missing altitude information. The Elastic SDK sets the HoloridePlayer Prefab to ground level (altitude = 0 / y=0 in Unity), even though you might be driving on a high mountain or in a deep valley in the real world. **Note: The perception sensitivity of altitude changes is very low. ** POIs / Overpass API To make POIs usable in our SDK (i.e. all the point-based items like gas stations and famous sights to park benches) they are utilized in the Open Street Maps’ Overpass service, which contains a vast number of different POIs. Overpass comes with its own query language to specifically request detailed information on certain key value pairs in the Open Street Maps database. Nodes like OSMPositions, RoadNetworkPoses, BuildingSpawner, and RoadNetworkSpawner utilize Overpass queries to receive their underlying data. Example workflow to develop using Overpass This chapter gives you an overview over our recommended workflow using Overpass. For explanation purposes we’ll follow the following example use case: Your game should spawn objects on all positions, where traffic lights are in the real world. Overview on existing key value pairs First look what’s the key value pair of your desired POI (in our example case: traffic lights). We recommend using this website as a reference point: https://wiki.openstreetmap.org/wiki/Map_features For our example you can find out that key = “highway” and value = “traffic_signals”. Test your query using e.g. Overpass Turbo Next step is to test the key value pair using a visual tool We recommend using this website to test your query before using it in the Elastic SDK: https://overpass-turbo.eu/ Integrate your query in the Elastic SDK Last step - you can integrate your query using the OSM Node Positions node of the Elastic SDK. Simply type in the key value pair in brackets like in the step before (e.g. [highway=traffic_signals] Further information Overpass API - In detail documentation for the Overpass API How To: OSM Poses - In-depth article about OpenStreetMap queries"
  },
  "manual/System-Information/Quality-Events.html": {
    "href": "manual/System-Information/Quality-Events.html",
    "title": "Quality Events | ElasticSDK Documentation",
    "keywords": "Quality Events The holoride software stack consists of a variety of software that communicates with each other to provide localization and graph data. Data that is required for a truly elastic experience. Knowing how the key components work together helps to understand the system holistically. In case you have not already, make sure to read the System Information page to get an overview of the holoride software stack. The ElasticSDK Quality Events are our way to communicate the different states of localization and graph data towards the content creator. Quality Events: Generation Events The Elastic Scene Generator component has a dedicated Events section, that provides the user with a variety of UnityEvents. These events are meant to be hooks where your program flow can execute different behavior based on the different states of the generation process. Event Description OnGenerationStarted The event which is invoked when the initial generation process has started. OnGenerationFinished The event which is invoked when the initial generation process is finished. OnEnterGenerationOverdue The event which is invoked when the GenerationOrigin, i.e. the Player, got too close to the latest finished generation context's InnerBounds, based on the given BoundsDistanceThreshold. OnLeaveGenerationOverdue The event which is invoked when the current generation left the overdue state. OnUpdateStarted The event which is invoked every time a generation process has started, except the first time. OnUpdateFinished The event which is invoked every time a generation process has finished, except the first time. Important The OnEnterGenerationOverdue event is especially important. It will trigger whenever the Player approaches the bounds of the latest finished generation. It can be used to identify and compensate poor content states before they actually happen. There are various reasons why a generation can not finish in time and it is likely that there is more than one cause. A poor internet connection can cause excessive download times for areas where no cached map data exists in the user's application. This would ultimately stall the generation and the Player would approach the bounds because they cannot be updated. Same could happen when the graph is too complex overall, the vehicle drives very fast or the extents of the Elastic Scene Generator are too small. In general it is recommended that there is always a fallback solution, e.g. a separate graph independent scene transition, hooked up to this event. The BoundsDistanceThreshold is a user-defined value on the Elastic Scene Generator, that can be used to adjust the distance towards the bounds from where the Player will cause the event invokation. Quality Events: Localization Events Localization Events are located on a component with the same name in the Holoride Player prefab. These events are meant to be hooks where your program flow can execute different behavior based on the different states of the real-world localization data. Setting Description DistanceToStreetUntilOffRoad The distance in meters from the street until the player is considered to be too far away from the road and the OnOffRoadMode event is triggered. FireModeEventOnStart When enabled this component will fire the localization mode event for the current state when Unity's Start method is called on this component. Event Description OnLocalizationInitialized The event which is invoked when the localization becomes available and the pivot is set. OnLocalizationNormalMode The event which is invoked when the localization is available and we are on the street (up to the road distance threshold). OnOffRoadMode This event which is invoked when the localization is available but we are not on the road and the distance to the road is larger than the threshold configured in DistanceToStreetUntilOffRoad. OnLocalizationUnavailableMode This event which is invoked when the localization is unavailable and thus the player won't move even though the vehicle in the real world might. OnErrorOccured This event which is invoked when any localization error occurs. This component handles different localization quality events and reduces them to three distinct states: Normal: This state represents good localization where everything works as expected. Off-road: This state is active when the localization is available but due to inaccuracies in localization or outdated Map data, the Player might not be on the road which the content should handle accordingly. The distance to the road until the player is considered to be \"off-road\" is adjustable and should reflect the requirements of the individual content. Unavailable: This state means that no localization information is available. Provisions should be made for the content of an experience to respond to different localization states: Since the Unavailable state does not show any movement at all, even though the vehicle may in fact be moving, it is suggested not to show any indication of false movement that occurs when the Player's localization is not present but the VR headset's IMU interprets a turning car as a head rotation. In many scenarios, this means that it is not even recommended to show the player a world . The experience should start in this mode until localization is available and Map data is ready. Caution Any experience must be designed to reflect this state at any point in time to comfort the user in those situations where valid data is not available to present an elastic environment. One suggestion is to fade out the world when this mode is activated and fade it in once another state becomes active. The other interesting state is the Off-road state where there appears to be normal localization but due to limited GPS reception (e.g. in a tunnel) the Player might be off the road. In this case the experience should make sure that the player is not colliding with any objects. How this is handled depends very much on the experience that is built and could range from unloading objects that are too close to loading a different scene. The Distance To Street Until Off Road setting for this mode makes it possible to tighten or loosen the constraints for this mode, depending on the individual content."
  }
}